# Дневник

```
# Если мы хотим в точности те же версии всех пакетов,
# какие были у остальных разработчиков этого проекта
npm ci
```

При слиянии можно указать флаг разрешения конфликтов
git merge dev -Xtheirs Все изменения возмутся из dev
`merge` одну из двух опций `-Xours` или `-Xtheirs`.

Пример эталонного проекта node с jest **[nodejs-package](https://github.com/hexlet-boilerplates/nodejs-package)**

```
# Вот теперь зависимости из devDependencies устанавливаться не будут
npm install --production

# Продакшен режим можно задать и с помощью переменной окружения
NODE_ENV=production npm install
```

Когда же проект собирается для деплоя на сервер (например, через Github Actions), то флаг нужно применять с `npm ci`:

```
npm ci --production
```

### 10.02.22

Чтобы в функуциях высшего порядка (forEach, map, reduce) досрочно выйти из цикла, по аналогии c

```javascript
for (const key of keys) {
  if (key === null) {
    return false;
  }
}
```

Можно использовать every some

```javascript
const mapDNA = new Map([
  ["G", "C"],
  ["C", "G"],
  ["T", "A"],
  ["A", "U"],
]);
const dnaToRna = (str) => {
  const res = [];
  return [...str].every((v) => mapDNA.has(v) && res.push(mapDNA.get(v)))
    ? res.join("")
    : null;
};
```

Они возвращают true или false и не доходят до конца

Реализуйте и экспортируйте функцию `flatten()`. Эта функция принимает на вход массив и выпрямляет его: если элементами массива являются массивы, то _flatten_ сводит всё к одному массиву, раскрывая один уровень вложенности.

```javascript
// BEGIN (write your solution here)
export const flatten = (arr) =>
  arr.reduce((acc, v) => (Array.isArray(v) ? [...acc, ...v] : [...acc, v]), []);
// END
```

Реализуйте и экспортируйте функцию `getMax()`, которая ищет в массиве максимальное значение и возвращает его.

## objects.js

Реализуйте и экспортируйте по умолчанию функцию, которая выполняет глубокое копирование объектов.

```javascript
const cloneDeep = (obj) =>
  Object.entries(obj).reduce(
    (acc, [k, v]) => ({
      ...acc,
      [k]: v.constructor === Object ? cloneDeep(v) : v,
    }),
    {}
  );
// END
export { cloneDeep as default };
```

**Внимание стандартная функции Object.is() выдает ошибку на типе null**

Узнал о функции сортировки по алфовиту с учетом локали

```javascript
function SortArray(x, y) {
  return x.LastName.localeCompare(y.LastName);
}
```

**Объекты сравниваются через JSON**

```javascript
// @ts-check
/* eslint no-restricted-syntax: ["off", "ForOfStatement"] */
// BEGIN (write your solution here)
export default (arr, param) =>
  arr.find(
    (obj) => JSON.stringify({ ...obj, ...param }) === JSON.stringify(obj)
  ) ?? null;
// END
```

\*\*Использование флага

```javascript
// @ts-check
/* eslint no-restricted-syntax: ["off", "ForOfStatement"] */
// BEGIN (write your solution here)
export default (arr, param) => {
  const entries = Object.entries(param);
  for (const obj of arr) {
    let find = true;
    for (const [k, v] of entries) {
      if (obj[k] !== v) {
        find = false;
      }
    }
    if (find) {
      return obj;
    }
  }
  return null;
};
// END
```

Разобрать решение учителя с объектами
https://ru.hexlet.io/code_reviews/508995
_Инкремент и декремент — единственные базовые арифметические операции в JS, которые обладают побочными эффектами (изменяют само значение в переменной)._

Command-query Separation (CQS) — принцип программирования, изобретённый Бертраном Мейером,

объекты первого рода (или класса)". Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным (или константам).

Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают всё сразу.
**CallBack**
У функции, которая передается внутрь метода `sort()` есть свое название. Подобные функции называют колбеками (callback, обратный вызов). Колбеком становится любая функция, которая вызывается не напрямую программистом, а ее вызывает какая-то функция, в которую мы передаем наш колбек.

```javascript
const myMap = (collection, callback) => {
  const result = [];
  for (const item of collection) {
    // Вызов переданного колбека на каждом элементе коллекции
    const newItem = callback(item);
    // Возврат из колбека добавляется в результирующий массив
    result.push(newItem);
  }

  return result;
};

const numbers = [5, 2, 3];
const newNumbers = myMap(numbers, (number) => number ** 2);
console.log(newNumbers); // => [25, 4, 9]
```

предикатом. То есть её задача вернуть либо `true`, либо `false` для каждого элемента коллекции.

агрегацией понимается операция, вычисляющая значение, зависящее от всего набора данных.

Подчеркну, что возвращать аккумулятор надо всегда, даже если он не изменился.
**Андрей Петраков**, здравствуйте! Вы можете обернуть одну функцию в другую и передать в неё все необходимые параметры, включая те значения, которые определены в окружении:

```javascript
Code (possible spoiler)students.reduce((prev, student) => fun(prev, student, mark), {});

// @ts-check



// BEGIN (write your solution here)

const cb = (data, obj, param) => {
const groupName = obj[param];
const group = data[groupName] ?? [];
return { ...data, [groupName]: [...group, obj] };
};

const groupBy = (users, key) => users.reduce((acc, user) => cb(acc, user, key), {});
// END
export default groupBy;
```

### 11.02.22

Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером. (Wikipedia)

Императивная парадигма — стиль написания кода в виде набора последовательных инструкций (команд) с активным использованием переменных.

В императивном стиле широко используется присваивание (а значит, и переменные) и циклы.

Ключевое отличие функционального стиля от императивного в том, что при таком стиле программа выглядит как спецификация (которая может быть очень сложной), а не как набор инструкций. То есть программа отвечает на вопрос _ЧТО_ («что мы хотим получить»).

Главное отличие декларативной парадигмы от императивной на практике — отсутствие присваивания.

Отсутствие присваивания автоматически означает то, что в функциональной парадигме невозможно использование циклов. Вместо них используется рекурсия.

Другой важной особенностью функционального стиля считается активное использование функций как объектов первого рода.

Главная причина создания функций — повышение уровня абстракции, а не сокращение дублирования кода.

1.  [Ментальное программирование 2](https://www.youtube.com/watch?v=vkUTX1hruF8)

### 14.02.22

- Воркфлоу / Workflows

  Каждый репозиторий на GitHub может содержать один или несколько воркфлоу. Каждый воркфлоу определяется в отдельном файле конфигурации в каталоге репозитория _.github/workflows_. Несколько воркфлоу могут выполняться параллельно.

- События / Events

  Воркфлоу может запускаться одним или несколькими событиями. Это могут быть внутренние события GitHub (например, пуш, релиз или пул-реквест), запланированные события (запускаются в определенное время — например, cron), или произвольными внешними событиями (запускаются вызовом Webhook API GitHub).

- Задания / Jobs

  Воркфлоу состоит из одного или нескольких заданий. Задание содержит набор команд, которые запускаются вместе с рабочим процессом. По умолчанию при запуске воркфлоу все его задания выполняются параллельно, однако между ними можно определить зависимость, чтобы они выполнялись последовательно.

- Раннеры / Runners

  Каждое задание выполняется на определённом раннере, — временном сервере на GitHub с выбранной операционной системой (Linux, macOS или Windows). Также существуют [автономные раннеры](https://docs.github.com/en/actions/hosting-your-own-runners), которые позволяют создать своё окружение для выполнения экшена.

- Шаги / Steps

  Задания состоят из последовательности шагов. Шаг — это либо команда оболочки (shell command), либо экшен (action). Все шаги задания выполняются последовательно на раннере, связанном с заданием. По умолчанию в случае сбоя шага все следующие шаги задания пропускаются.

- Экшен / Actions

  Экшен — многократно используемый блок кода, который может служить шагом задания. Каждый экшен может принимать на вход параметры и создавать любые значения, которые затем можно использовать в других экшенах. Разработчики могут создавать собственные экшены или использовать опубликованные сообществом GitHub. Общих экшенов около тысячи, все они доступны на [GitHub Marketplace](https://github.com/marketplace?type=actions).

предметную область

### 15.02.22

Какой подход был бы подходящим для фрагментации (разделения) массива на множество меньших массивов, скажем, максимум из 10 элементов?

```javascript
const chunk1 = (data, ch) =>
  data.reduce(
    (acc, _, i) => (i % ch ? acc : [...acc, data.slice(i, i + ch)]),
    []
  );
```

```javascript
const chunk = (data, ch) => {
  const result = [];
  for (let i = 0; i < data.length; i += ch) {
    result.push(data.slice(i, i + ch));
  }
  return result;
};
```

**solution.js**
Реализуйте и экспортируйте по умолчанию функцию, которая находит в массиве непрерывные возрастающие последовательности чисел и возвращает массив с их перечислением.
**Примеры**

```javascript
summaryRanges([]);
// []

summaryRanges([1]);
// []

summaryRanges([1, 2, 3]);
// ['1->3']

summaryRanges([0, 1, 2, 4, 5, 7]);
// ['0->2', '4->5']

summaryRanges([110, 111, 112, 111, -5, -4, -2, -3, -4, -5]);
// ['110->112', '-5->-4']
```

```javascript
const writeSegment = (segment) => `${segment.at(0)}->${segment.at(-1)}`;

const summaryRanges = (arr) => {
  const result = [];
  let segment = [];
  for (let i = 0; i < arr.length; i += 1) {
    const current = arr[i];
    const next = arr[i + 1];
    segment.push(arr[i]);
    if (next !== current + 1) {
      if (segment.length > 1) {
        result.push(writeSegment(segment));
      }
      segment = [];
    }
  }
  return result;
};
```

Пересечение интервалов лучше всего решать через Set

```javascript
const sumIntervals = (internals) => {
  const result = new Set();
  internals.forEach(([start, end]) => {
    for (let i = start; i < end; i += 1) {
	  result.add(i);
	}
  });
  return result.size;
};
```


### 31.03.22
---
#### План
- [x] Хеклет Деревья
- [x] Udemi Начать курс Петреченко
- [ ] Прорешать coderslang
- [ ] Повторить теорию по абстракциям

##### Сделано


##### Выводы

---

#### Важное
Вершины, находящиеся на одной глубине и имеющие общего родителя, называют братскими или сестринскими.
Нужно быть осторожнее при передаче по ссылке

### 01.04.22

#### План
- [x] Хеклет Деревья
- [x] Udemi Начать курс Петреченко
- [ ] Прорешать coderslang
- [ ] Повторить теорию по абстракциям

##### Сделано


##### Выводы

---

#### Важное
Вершины, находящиеся на одной глубине и имеющие общего родителя, называют братскими или сестринскими.
Нужно быть осторожнее при передаче по ссылке

### 08.04.22
#### <span style="color:red">План (внимание ответственность)</span>
- [ ] Хеклет ООП
- [ ] Udemi Начать курс Петреченко
- [ ] Прорешать coderslang
- [ ] Повторить теорию по абстракциям
- [ ] Pomidoro

##### Сделано


##### Выводы

---

#### Важное
Подход, в котором код представляет из себя набор ***объектов, взаимодействующих друг с другом***, называется объектно-ориентированным программированием (ООП). Объекты, в таком подходе, это не просто тип данных "объект", это сущности, которые **имеют поведение**, то есть методы для работы с ними.

Выше, когда давалось определение `this`, говорилось, что `this` ссылается на текущий объект, к которому привязан метод. И здесь кроется ключевое отличие `this` в JavaScript от `this` в других языках. В JavaScript `this` у метода может измениться:


```javascript
const company1 = { name: 'Hexlet', getName: function getName() { return this.name } };
const company2 = { name: 'Hexlet Plus' };

company1.getName(); // "Hexlet"

company2.getName = company1.getName;

// В обоих случаях одна и та же функция
company2.getName(); // "Hexlet Plus"
company1.getName(); // "Hexlet"
````

Внутри методов this ссылается на текущий объект, к которому привязан метод.

Что здесь произошло? Вызов той же самой функции из другого объекта привел к смене объекта, на который ссылается `this`. Эта особенность называется **поздним связыванием**.

Значение `this` ссылается на тот объект, из которого происходит вызов метода.

Функции, записанные внутрь свойств объектов, называют методами:

**Реализация функции bind**

```javascript
// @ts-check

// BEGIN (write your solution here)
// Вариант 1
export default (contex, fn, ...bindArgs) => {
  const res = { ...contex };
  res.fn = fn;
  return (...args) => res.fn(...args, ...bindArgs);
};
// Вариант 2
const bind =
  (context, fn, ...boundArgs) =>
  (...args) =>
    fn.apply(context, [...boundArgs, ...args]);

// END
```

Стрелочные функции отличаются от обычных не только способом записи. Главное их отличие проявляется в том, как они работают с контекстом. Вкратце:

**Контекст обычных функций зависит от места вызова, а контекст стрелочных функций — от того места, где они были определены.**

Стрелочная функция не имеет своего контекста, она связывается с лексическим окружением, то есть функцией, внутри которой определена стрелочная функция. Это очень важный момент. Именно функция верхнего уровня задаёт контекст стрелочной функции, а не что-то другое. И это поведение нельзя изменить с помощью функций `call` или `bind`.

`new` (как и многое в js, он работает не так как `new` в других языках). Фактически он создает объект, устанавливает его как контекст во время вызова конструктора (в данном случае `Company`) и возвращает созданный объект. Именно поэтому сам конструктор ничего не возвращает (хотя может, но это другой разговор), а внутри константы `company` оказывается нужный нам объект.

```javascript
// Упрощенная иллюстрация работы new внутри интерпретатора при таком вызове:
// new Company();

const obj = {};
Company.bind(obj)(name, website); // этот вызов просто наполнил this (равный obj) нужными данными
return obj;
```

```javascript
// Специальный синтаксис создания массивов
// Массивы это объекты, вспомните свойство length
const numbers = [10, 3, -3, 0]; // литерал

// Объектный способ создания через конструктор
// Результат ниже эквивалентен тому что происходит выше
const numbers = new Array(10, 3, -3, 0);

// У дат нет литералов, они создаются как объекты
const date = new Date("December 17, 1995 03:24:00");
// У дат очень много методов
date.getMonth(); // 11, в JS месяцы нумеруются с нуля

// Так можно создавать даже функции
// Последний аргумент это тело, все предыдущие – аргументы
const sum = new Function("a", "b", "return a + b");
sum(2, 6); // 8
```

Но не все функции могут быть конструкторами. Отсутствие своего контекста делает невозможным использование оператора `new` вместе со стрелочными функциями:

```javascript
const f = () => {};
// TypeError: function is not a constructor
const obj = new f();
```

Прототип – это обычный объект, хранящийся в специальном служебном поле [[prototype]] (к этому полю невозможно обратиться напрямую).

JavaScript автоматически упаковывает примитивные типы в соответствующие объекты, когда встречает вызовы методов на них (и затем автоматически распаковывает).

Все методы которые мы вызываем на строках, хранятся в прототипе конструктора `String`.

Интересно то, как происходит распаковка. Для этого JavaScript автоматически вызывает метод `valueOf()` у объекта:

toString() - вызывается автоматически в тех ситуациях, когда объект используют как строку.

Прототипы, с одной стороны, мощный механизм, с другой — он низкоуровневый.

В первом случае определятся статическое свойство. Оно принадлежит классу в целом, и не принадлежит каждому конкретному объекту этого класса.

Во втором случае это обычное свойство и при создании новых объектов класса Money, каждый из них будет получать свою собственную копию rates.

```javascript
Code (possible spoiler)
class Example {
  static prop = "static";
  prop2 = "not static";
};
console.log(Example.prop); // static
console.log(Example.prop2); // undefined
const obj = new Example();
console.log(obj.prop); // undefined
console.log(obj.prop2); // not static


class Money {
	constructor(value) {
	this value = value;
	}
}

```

С исключениями нужно запомнить две вещи: код, в котором произошла ошибка, выбрасывает исключение, а код, в котором ошибка обрабатывается – его ловит.

`throw` прерывает дальнейшее выполнение кода. В этом смысле оно подобно `return`, но в отличие от него, прерывает выполнение не только текущей функции, но и всего кода, вплоть до ближайшего в стеке вызовов блока `catch`.

ООП для меня это сообщения, локальное удержание и защита, скрытие состояния и позднее связывание всего. Это можно сделать в Smalltalk и в LISP.
Аланом Кеем
Как говорят математики, найти базис (минимальный набор элементов, из которых можно вывести всё остальное).

**_JS: Объектно-ориентированный дизайн_**
Шаблон - это типовое решение типовой задачи
Антипатерн - типовое решение типовой задачи, которое приносит больше вреда чем пользы
Абстракция подразумевает наличие некоторого понятия (типа), значения которого обладают *временем жизни*. Это значит, что она создается и затем многократно и по-разному используется. Например, невозможно представить работу с пользователем в виде одной функции.
Существует формальное правило, позволяющее это определить. Если создание объекта и вызов метода можно заменить на обычную функцию, то ни о какой абстракции речи не идёт, и правильный подход, в данной ситуации, сводится к переносу данных из конструктора в сам метод.

Абстракция данных подразумевает то, что объект представляет из себя не способ выполнить операцию, а конкретный набор данных, который, как правило, может меняться с течением времени. Изменение такого объекта должно отражаться на всех остальных.

Привет! Интересный вопрос. Мое мнение - причина в том, что Object.assign мутирует исходный целевой объект, а слияния через деструктуризацию - возвращает новый объект. И получается, что используя Object.assign мы мутируем static свойства инстанса Truncatter. Изменения сохраняются и влияют на следующий тест.

**Объекты сущности:**

- Объекты облажают временем жизни
- Идентификация

**Объекты значения** Нам не важны объекты, нам важны значения. Объект здесь служит лишь способом организации кода, но он никак не идентифицирует хранящиеся внутри него данные.

**Встраиваемые объекты**

Предметно-ориентированный язык) — язык, специализированный под конкретную область применения.
[Текучий интерфейс (Fluent Interface)](https://ru.wikipedia.org/wiki/Fluent_interface). При таком способе организации кода, обработка выглядит как цепочка подряд идущих методов.
`this` — ссылка на тот объект, в контексте которого вызывается метод,

Валидация — это процесс проверки данных на корректность по заданным условиям. А валидатор — это что-то, выполняющее данную проверку.\_

```javascript
// методы positive() и integer() есть только у number
const schema1 = yup.number().required().positive().integer();

// массив должен содержать от 5 до 10 элементов
const schema2 = yup.array().min(5).max(10);
```

Подобный способ формирования объекта-схемы называется сборкой, а сам объект – сборщиком.

### 19.04.22

#### <span style="color:red">План (внимание ответственность)</span>

- [ ] JS: Объектно-ориентированный дизайн
- [ ] JS: Прототипы
- [ ] Udemi Начать курс Петреченко
- [ ] Прорешать coderslang
- [ ] Повторить теорию по абстракциям
- [ ] Pomidoro

##### Сделано

##### Выводы

---

#### Важное

Генеральная идея звучит так: грамотная абстракция – ключ к успеху. Обозначьте границы, рассмотрите варианты использования и реализуйте как-нибудь.
Для старта достаточно здравого смысла.

HTTP работает по клиент-серверной модели. Это значит, что во время взаимодействия существует две стороны: клиент – запрашивает данные, сервер – отдает клиенту ответ на его запрос.

![[public/Pasted image 20220419123719.png]]\
Сначало устанавливается TCP соединение
Для этого нужно знать два параметра: ip-адрес компьютера, к которому нужно подключиться, и порт, на котором "висит" нужная программа.
После подключения веб-сервер входит в режим ожидания HTTP-запроса. Осталось его послать.
Запрос состоит из нескольких частей. Первая часть — *request line*. Вторая — заголовки.

- глагол (HEAD, GET)
- \_request URI (путь к ресурсу) (/ - корень сайта)
- название протокола и его версию (HTTP 1.0
  Заголовки позволяют передавать дополнительную информацию, например браузеры предоставляют информацию о себе, чтобы было понятно откуда идет запрос. Кроме этого они указывают какие форматы сжатия поддерживают, в каком формате готовы принимать ответ и так далее. Количество стандартных заголовков достаточно большое, помимо них можно добавлять любые свои.
  Давайте рассмотрим, как выглядят заголовки. Мы указываем имя и через двоеточие какое-то значение: *REFERER: value*. Заголовки часто указывают заглавными буквами, но регистр здесь не важен. Порядок заголовков также не специфицирован. В каком бы порядке мы не передали заголовки, тело ответа будет разбираться только всё вместе.
  В HTTP это делается с помощью двух переводов строки. После этого сервер считает что все данные были отправлены и больше данных не будет
  ![[public/Pasted image 20220419125923.png]]
  Ответ сервера  Он состоит из *status line* `HTTP/1.0 200 OK`.
  HTTP 1.1 ввел такое понятие как виртуальные хосты.
  Кроме request line стал обязательным ещё и заголовок, который называется host.

```http
HEAD / HTTP/1.1
host: hexlet.io
```

Главные отличия протокола версии 1.1 от 1
Виртуальные хосты
*keep-alive* - означает, что соединение TCP, по которому ходит HTTP, не закрывается.

Основная цель введения этой фичи в том, чтобы сократить использование ресурсов, уменьшить нагрузку на процессор, открывать меньше TCP-соединений (установка каждого TCP-соединения занимает время), уменьшить время ожидания (latency)
![[Pasted image 20220419160623.png]]

```http
# число — количество байт
Content-Length: 218
_Content-Type: application/octet-stream_.
```

```http
POST /session/new HTTP/1.1
Host: hexlet.local
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Connection: close

username=admin&password=secret
```

Transfer-Encoding:chunked _если мы не знаем размер_

Помимо того, что данные на сервер можно передавать через *body*, которое используется при *POST* запросах и отправке форм, мы также можем передать так называемую строку запроса *query string*.
_query string_. Это параметры *ключ=значение* которые располагаются в *request line* после указания глагола *POST* или *GET*.
_query string_ или передать параметры в теле запроса

```http
Authorization: Basic aHR0cHdhdGNoDmY=
```

Куки делятся как минимум на два типа:

- Сессионные
- Постоянные
  Длиной жизни куков можно управлять при помощи параметра

```HTTP
expires=Thu, 16-Jul-2020 03:39:50 GMT;
// или
MAX-AGE=2592000;
domain=.hexlet.io; path=/;
```

Уникальность куки определяется тремя параметрами *key* (имя куки), *domain* и *path*. Это значит, что если какую-то куку нужно переустановить, например, поменять время её жизни, то при следующем запросе в *set-cookie* эти параметры должны совпадать.
**Удаление куки**
Заголовка для удаления куки не существует, чтобы удалить её, нужно установить нулевой или отрицательный *MAX-AGE*, либо задать *expires* в прошлом, тогда кука будет немедленно удалена.
**HttpOnly cookie**
Можно заметить, что в нашем примере установлен дополнительный параметр *HttpOnly*. HttpOnly куки передаются с AJAX-запросами, но их нельзя получить через JavaScript на странице сайта. Это дополнительный уровень безопасности от XSS атак.
Все куки отправляются одним заголовком в формате *key=value; key=value* без дополнительных параметров.

### 20.04.22

#### <span style="color:#f44336">План (внимание ответственность)</span>

- [x] СИКП на JS
- [ ] Udemi Начать курс Петреченко
- [ ] Прорешать coderslang
- [x] Повторить теорию по абстракциям
- [x] Pomodoro

##### Сделано

##### Выводы

---

#### Важное

**Цикломатическая сложность** - количество линейно-независимых маршрутов через программный код.
Если нет ветвлений или циклов сложность равно 1;

![[public/Pasted image 20220420124921.png]]

```javascript
// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // 4

// Complexity: 2
const abs = (n) => (n >= 0 ? n : -n);

abs(10); // 10
abs(-3); // 3
```

Паттерн - **Guard Expression** (избегать вложенных конструкция)

```javascript
// Вмечто
const f = (age, sex) => {
  if (age >= 18) {
    if (sex === "male") {
      return "yes";
    }
    if (sex === "female") {
      return "no";
    }
  }

  return null;
};

// Лучше

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === "male") {
    return "yes";
  }

  if (sex === "female") {
    return "no";
  }
};
```

Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.

-   Выражения — вычисляются.
-   Инструкции — исполняются.

К выражениям относятся:

-   Вызов функции
-   Арифметические и логические операции
-   Тернарный оператор
-   и другие

К инструкциям относятся:

-   `for`
-   `while`
-   `break`
-   `return`
-   `if`
-   и другие


**Объекты первого класса** - элементы которые могут быть переданы в функцию, возвращены из нее, присвоены переменным.
Функции в js являются объектами первого класса (определение функций)
**Анонимные функции или лямбда функции** - не имеют собственного имени
**Функции высшего порядка** - функции которые могут принимать в качестве аргументов другие функции, возвращают другие функции;

**Словарь — это набор пар «ключ - значение»**

**LexicalEnvironment** - служебное свойства функции, где сохраняются значения переменных к которым может получить доступ функция.
Замыкание - это функция, которая запоминает значения своих переменных и может получить к ним доступ.
Лексическое окружение создается в момент вызова, а после выполнения функции очищается (память - освобождается)

Перекрытием называется ситуация, когда во внутреннем окружении создается идентификатор с таким же именем, как и во внешнем. Причем не важно, что это: аргумент функции, константа или переменная.

```javascript
const f = (coll) => {
  const iter = (item, coll) => {
    // using coll
  }
  // ...
}
```

**Замыкание** — это функция, «запомнившая» часть окружения, где она была задана.
**Частичное применение** - техника основанная из возможности возвращать функцию из других функций.
**или**
Процесс фиксации части аргументов функции, который создает другую функцию с меньшим количеством аргументов

Правильнее говорить что функция применена к данным аргументам.

```javascript
const getProgrammersSalaryByCountry = partialApply(getAverageSalary, 'programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

const partialApply = (fn, arg1) => (arg2) => fn(arg1, arg2);
```

**Каррирование** — это процесс превращения функции от `n` аргументов в цепочку вложенных `n`-функций от одного аргумента. Соответственно, каррированная функция — это множество функций от одного аргумента.


### 21.04.22

#### План (внимание ответственность)

- [ ] СИКП на JS
- [ ] Udemi Начать курс Петреченко
- [ ] Прорешать coderslang
- [ ] Повторить теорию по абстракциям
- [ ] Pomodoro

##### Сделано

##### Выводы

---

#### Важное
Абстракция — один из главных способов борьбы со сложностью реального мира.
**Абстракция данных** — это метод отделения частей программы, которые имеют дело с представлением объектов данных, от тех частей, где эти объекты используются.
**Барьеры абстракции** позволяют изолировать разные части и разные уровни системы друг от друга.
Функции полноправные данные
**Интерфейс** — это набор функций, обычно разделяемых на конструкторы и селекторы. Конструкторы позволяют из набора данных строить составной объект, а с помощью селекторов из составного объекта извлекают его части. В нашем случае, если говорить о точках, селекторы позволяют извлекать координаты x и y. Вот как выглядит интерфейс нашей библиотеки:

**Барьеры абстракции** в современной литературе часто именуют другим термином — **принцип одного уровня абстракции**. Это означает, что, работая в одной предметной области на определённом срезе, оперируют объектами только этого среза, избегая объектов, к нему не относящихся.

> Как видно, совершенство достигается не тогда, когда уже нечего прибавить, но когда уже ничего нельзя отнять.

 Антуан де Сент-Экзюпери
 **Последовательность** — это упорядоченная совокупность объектов данных.
 [Single Page Application](https://en.wikipedia.org/wiki/Single-page_application), когда не происходит перезагрузки страницы(запрос-ответ), а всё меняется прямо на самом сайте.
 _Множество замкнуто относительно операции, если применение операции к элементам этого множества даёт результат, который так же является элементом этого множества._
 **Абстрактный список** (см. первый абзац) может быть реализован в **конкретных структурах данных**. В нашем случае это [односвязный список](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA#.D0.9E.D0.B4.D0.BD.D0.BE.D1.81.D0.B2.D1.8F.D0.B7.D0.BD.D1.8B.D0.B9_.D1.81.D0.BF.D0.B8.D1.81.D0.BE.D0.BA_.28.D0.BE.D0.B4.D0.BD.D0.BE.D0.BD.D0.B0.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D1.81.D0.B2.D1.8F.D0.B7.D0.BD.D1.8B.D0.B9_.D1.81.D0.BF.D0.B8.D1.81.D0.BE.D0.BA.29).
 -   Хорошая абстракция делает код более понятным и повышает его читабельность. Теперь, видя в коде `l`, мы однозначно понимаем, что здесь происходит. Тогда как в ином случае, цепляясь глазом за множественные, разбросанные среди строк `cons`, мы каждый раз должны будем определять, что же делает данная конкретная пара: то ли создаёт список, то ли хранит временные данные, то ли печёт пирожки ?! ;)
Давайте начнём с того, что всё, что является значением, _имеет тип_. Буквально всё. Структуры данных, функции, классы, объекты — это всё _значения некоторых типов_.

В языках программирования типы могут быть _встроенными_ (в язык) и _пользовательскими_. Встроенные всегда доступны в любой программе и количество этих типов ограничено (задано в спецификации языка). Пользовательские типы создаются программным путём, поэтому их количество и состав не ограничены. Встроенные типы есть в каждом языке, при этом в некоторых языках нет возможности объявлять пользовательские типы данных (например, bash, BASIC).

Важно: типы, определённые в стандартной библиотеке, но реализованные на самом языке, а не встроенные в компилятор или интерпретатор — это тоже пользовательские типы данных. Ведь они созданы _с использованием_ языка, пусть даже самими авторами оного.

Типы могут быть _примитивными_ и _составными_.

Примитивные типы не используют значения других типов для описания своих значений. Часть таких типов может иметь конечное количество значений, (например, типы-перечисления вида "цвет = красный | синий | зелёный"), другие же могут иметь бесконечное пространство значений (безразмерные целые, BigInts). Кроме того, практически всегда часть встроенных в язык примитивных типов является _машинными типами_, значения которых обрабатываются напрямую процессором без каких-либо предварительных преобразований (целые числа фиксированного размера — Int64, Word8; числа с плавающей точкой фиксированной точности — Single, Double).

Составные типы описывают свои значения с помощью значений других типов. Собственную "нагрузку" такие типы могут как нести (размеченные объединения/tagged unions), так и не нести (запись/record/struct, пара, кортеж/tuple). В большинстве случаев конкретные составные типы — пользовательские, то есть могут быть описаны силами языка.

Теперь стоит сказать о _поведении_. Когда мы работаем силами языка с различными типами (данных), мы пользуемся неким их "поведением" — совокупностью операций, которые можно применять к значениям этих типов. Поведение может быть жёстко привязано к конкретному типу. А может быть обобщено на любые/некоторые типы — это уже будет проявлением полиморфизма (одинаковое поведение у разных типов)

_Абстрактные Типы Данных_ — типы, обладающие некоторым известным поведением, но не известной (нам, пользователям) структурой. Причём дело не в какой-то там "реализации". Мы в принципе не знаем, как тип устроен, что представляют собой его значения, из чего они состоят — мы абстрагированы от этого! Мы знаем лишь, что к некоему значению можно применять известные операции, то есть рассчитывать на некое поведение.

Я не стал углубляться в виды систем типов, сравнивать _структурные_ системы типов и _номинальные_ — просто "по верхам" прошёлся. Надеюсь, помог.


**Преимущества map**

-   Универсальный код
-   Декларативный код
-   Абстрагирование от структуры, То есть `map` строит барьер абстракции, удаляя нас от деталей того, как реализовано то, с чем мы работаем. Поэтому за `map` может скрываться всё, что угодно. Деревья, множества, какие-то сложные вещи, которые не так просто обходить, но можем об этом уже даже не задумываться

Теперь давайте посмотрим, как реализуется `map`:

```javascript
export const map = (func, elements) => {
  if (isEmpty(elements)) {
    return l();
  }

  const newElement = func(head(elements));
  return cons(newElement, map(func, tail(elements)));
};
```
Дело в том, рекурсивный и итеративный процессы - это рекурсия. То есть в любом случае происходят вложенные вызовы. Разница лишь в том, что при использовании итеративного процесса на каждом этапе рекурсивного вызова мы вычисляем промежуточный результат и передаём его далее вглубь, и уже следующее вычисление будет происходить с ним. И так далее. Когда мы дойдём до самой глубокой вложенности (сработает guard expression), готовый результат будет возвращён наверх по всей цепочке вызовов. В рекурсивном процессе, происходит всё то же самое, но вычисления делаются не на этапе "погружения", а при "подъеме наверх". То есть вначале создаётся цепочка вложенных вызовов, а далее начинают происходить вычисления. Вначале будет возвращен l(), далее к этому значению, будет присоединён последний элемент. Список, который был получен будет возвращен выше и к нему будет присоединён предпоследний элемент и так далее...

Порекомендую вам почитать статью на эту тему "[Рекурсия, рекурсивный процесс и итеративный процесс](https://ru.hexlet.io/blog/posts/recursive)". Также посмотрите визуализации [рекурсивного](https://goo.gl/gWCcgm) и [итеративного](https://goo.gl/3ggX0S) процессов.
```javascript
const sum = (...args) => args.reverse();

function curry(fn) {
  const argumentsArray = [];
  function subCurry(...args) {
    argumentsArray.push(...args);
    return subCurry;
  }
  subCurry[Symbol.toPrimitive] = () => {
    const result = fn.apply(this, argumentsArray);
    argumentsArray.length = 0;
    return result;
  };

  return subCurry;
}
const curriedSum = curry(sum);
console.log(String(curriedSum(1, 2, 3)));
```

## select.js

Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход имя тега и HTML список, а возвращает список всех нод, соответствующих имени. Ноды возвращаются в том виде, в котором они представлены в дереве. Порядок, в котором ноды возвращаются — не важен.
```javascript
// @ts-check
import { /* eslint-disable */
  l, cons as consList, isList, isEmpty, head, tail, concat, toString as listToString,
} from '@hexlet/pairs-data';

import {
  is, hasChildren, children, filter, reduce, toString as htmlToString,
} from '@hexlet/html-tags'; /* eslint-enable */

// BEGIN
const select = (tagName, html) => reduce((element, acc) => {
  const acc2 = hasChildren(element) ? concat(select(tagName, children(element)), acc) : acc;
  return is(tagName, element) ? consList(element, acc2) : acc2;
}, l(), html);

export default select;
// END
```

### 21.04.22

#### План (внимание ответственность)

- [ ] СИКП на JS
- [ ] Udemi Начать курс Петреченко
- [ ] Прорешать coderslang
- [ ] Повторить теорию по абстракциям
- [ ] Pomodoro

##### Сделано

##### Выводы

---

#### Важное
Для колоды из трёх или какого-нибудь другого количества карт надо будет модифицировать функцию. Можно сразу написать более универсальный вариант:

```javascript
const customRandom = (cardIndex, minIndex, maxIndex) => {
  return () => {
    if (cardIndex > maxIndex) {
      cardIndex = minIndex;
    }

    const currentIndex = cardIndex;
    cardIndex += 1;
    return currentIndex;
  };
};

console.log('Выводим индексы с 0 до 2. Начинаем с 0');

const getIndex = customRandom(0, 0, 2);

for (let i = 0; i < 6; i += 1) {
  console.log(getIndex());
}

console.log('Выводим индексы с 1 до 5. Начинаем с 2');

const getIndex2 = customRandom(2, 1, 5);

for (let i = 0; i < 10; i += 1) {
  console.log(getIndex2());
}

// => Выводим индексы с 0 до 2. Начинаем с 0
// => 0
// => 1
// => 2
// => 0
// => 1
// => 2
// => Выводим индексы с 1 до 5. Начинаем с 2
// => 2
// => 3
// => 4
// => 5
// => 1
// => 2
// => 3
// => 4
// => 5
// => 1
```