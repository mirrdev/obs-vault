# Дневник
```
# Если мы хотим в точности те же версии всех пакетов,
# какие были у остальных разработчиков этого проекта
npm ci
```
4.02.2020
При слиянии можно указать флаг разрешения конфликтов
git merge dev -Xtheirs Все изменения возмутся из dev 
`merge` одну из двух опций `-Xours` или `-Xtheirs`.

Пример эталонного проекта node с jest **[nodejs-package](https://github.com/hexlet-boilerplates/nodejs-package)**

```
# Вот теперь зависимости из devDependencies устанавливаться не будут
npm install --production

# Продакшен режим можно задать и с помощью переменной окружения
NODE_ENV=production npm install
```

Когда же проект собирается для деплоя на сервер (например, через Github Actions), то флаг нужно применять с `npm ci`:

```
npm ci --production
```

### 10.02.22
Чтобы в функуциях высшего порядка (forEach, map, reduce) досрочно выйти из цикла, по аналогии c 
```javascript
for (const key of keys) {
	if (key === null) {
		return false
	}
}
```
Можно использовать every some 
```javascript
const mapDNA = new Map([['G', 'C'], ['C', 'G'], ['T', 'A'], ['A', 'U']]);
const dnaToRna = (str) => {
const res = [];
return [...str].every((v) => mapDNA.has(v) && res.push(mapDNA.get(v))) ? res.join('') : null;
};
```
Они возвращают true или false и не доходят до конца

Реализуйте и экспортируйте функцию `flatten()`. Эта функция принимает на вход массив и выпрямляет его: если элементами массива являются массивы, то _flatten_ сводит всё к одному массиву, раскрывая один уровень вложенности.
```javascript
// BEGIN (write your solution here)
export const flatten = (arr) =>
  arr.reduce((acc, v) => (Array.isArray(v) ? [...acc, ...v] : [...acc, v]), []);
// END
```
Реализуйте и экспортируйте функцию `getMax()`, которая ищет в массиве максимальное значение и возвращает его.

## objects.js

Реализуйте и экспортируйте по умолчанию функцию, которая выполняет глубокое копирование объектов.
```javascript
const cloneDeep = (obj) => Object.entries(obj).reduce((acc, [k, v]) => ({ ...acc, [k]: v.constructor === Object ? cloneDeep(v) : v }), {});
// END
export { cloneDeep as default };
```
**Внимание стандартная функции Object.is() выдает ошибку на типе null**

Узнал о функции сортировки по алфовиту с учетом локали 
```javascript
function SortArray(x, y){
    return x.LastName.localeCompare(y.LastName);
}
```

**Объекты сравниваются через JSON**
```javascript
// @ts-check
/* eslint no-restricted-syntax: ["off", "ForOfStatement"] */
// BEGIN (write your solution here)
export default (arr, param) =>
  arr.find(
    (obj) => JSON.stringify({ ...obj, ...param }) === JSON.stringify(obj)
  ) ?? null;
// END
```

**Использование флага 
```javascript
// @ts-check
/* eslint no-restricted-syntax: ["off", "ForOfStatement"] */
// BEGIN (write your solution here)
export default (arr, param) => {
  const entries = Object.entries(param);
  for (const obj of arr) {
    let find = true;
    for (const [k, v] of entries) {
      if (obj[k] !== v) {
        find = false;
      }
    }
    if (find) {
      return obj;
    }
  }
  return null;
};
// END
```

Разобрать решение учителя с объектами 
https://ru.hexlet.io/code_reviews/508995
_Инкремент и декремент — единственные базовые арифметические операции в JS, которые обладают побочными эффектами (изменяют само значение в переменной)._

Command-query Separation (CQS) — принцип программирования, изобретённый Бертраном Мейером,

объекты первого рода (или класса)". Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным (или константам).

Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают всё сразу.
**CallBack**
У функции, которая передается внутрь метода `sort()` есть свое название. Подобные функции называют колбеками (callback, обратный вызов). Колбеком становится любая функция, которая вызывается не напрямую программистом, а ее вызывает какая-то функция, в которую мы передаем наш колбек.

```javascript
const myMap = (collection, callback) => {
  const result = [];
  for (const item of collection) {
    // Вызов переданного колбека на каждом элементе коллекции
    const newItem = callback(item);
    // Возврат из колбека добавляется в результирующий массив
    result.push(newItem);
  }

  return result;
};

const numbers = [5, 2, 3];
const newNumbers = myMap(numbers, (number) => number ** 2);
console.log(newNumbers); // => [25, 4, 9]
```

предикатом. То есть её задача вернуть либо `true`, либо `false` для каждого элемента коллекции.

агрегацией понимается операция, вычисляющая значение, зависящее от всего набора данных.

Подчеркну, что возвращать аккумулятор надо всегда, даже если он не изменился.
**Андрей Петраков**, здравствуйте! Вы можете обернуть одну функцию в другую и передать в неё все необходимые параметры, включая те значения, которые определены в окружении:

```javascript
Code (possible spoiler)students.reduce((prev, student) => fun(prev, student, mark), {});

// @ts-check

  

// BEGIN (write your solution here)

const cb = (data, obj, param) => {
const groupName = obj[param];
const group = data[groupName] ?? [];
return { ...data, [groupName]: [...group, obj] };
};

const groupBy = (users, key) => users.reduce((acc, user) => cb(acc, user, key), {});
// END
export default groupBy;
```

### 11.02.22

Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером. (Wikipedia)

Императивная парадигма — стиль написания кода в виде набора последовательных инструкций (команд) с активным использованием переменных.

В императивном стиле широко используется присваивание (а значит, и переменные) и циклы.

Ключевое отличие функционального стиля от императивного в том, что при таком стиле программа выглядит как спецификация (которая может быть очень сложной), а не как набор инструкций. То есть программа отвечает на вопрос _ЧТО_ («что мы хотим получить»).

Главное отличие декларативной парадигмы от императивной на практике — отсутствие присваивания.

Отсутствие присваивания автоматически означает то, что в функциональной парадигме невозможно использование циклов. Вместо них используется рекурсия. 

Другой важной особенностью функционального стиля считается активное использование функций как объектов первого рода.

Главная причина создания функций — повышение уровня абстракции, а не сокращение дублирования кода.
1.  [Ментальное программирование 2](https://www.youtube.com/watch?v=vkUTX1hruF8)

### 14.02.22
-   Воркфлоу / Workflows
    
    Каждый репозиторий на GitHub может содержать один или несколько воркфлоу. Каждый воркфлоу определяется в отдельном файле конфигурации в каталоге репозитория _.github/workflows_. Несколько воркфлоу могут выполняться параллельно.
    
-   События / Events
    
    Воркфлоу может запускаться одним или несколькими событиями. Это могут быть внутренние события GitHub (например, пуш, релиз или пул-реквест), запланированные события (запускаются в определенное время — например, cron), или произвольными внешними событиями (запускаются вызовом Webhook API GitHub).
    
-   Задания / Jobs
    
    Воркфлоу состоит из одного или нескольких заданий. Задание содержит набор команд, которые запускаются вместе с рабочим процессом. По умолчанию при запуске воркфлоу все его задания выполняются параллельно, однако между ними можно определить зависимость, чтобы они выполнялись последовательно.
    
-   Раннеры / Runners
    
    Каждое задание выполняется на определённом раннере, — временном сервере на GitHub с выбранной операционной системой (Linux, macOS или Windows). Также существуют [автономные раннеры](https://docs.github.com/en/actions/hosting-your-own-runners), которые позволяют создать своё окружение для выполнения экшена.
    
-   Шаги / Steps
    
    Задания состоят из последовательности шагов. Шаг — это либо команда оболочки (shell command), либо экшен (action). Все шаги задания выполняются последовательно на раннере, связанном с заданием. По умолчанию в случае сбоя шага все следующие шаги задания пропускаются.
    
-   Экшен / Actions
    
    Экшен — многократно используемый блок кода, который может служить шагом задания. Каждый экшен может принимать на вход параметры и создавать любые значения, которые затем можно использовать в других экшенах. Разработчики могут создавать собственные экшены или использовать опубликованные сообществом GitHub. Общих экшенов около тысячи, все они доступны на [GitHub Marketplace](https://github.com/marketplace?type=actions).

предметную область

### 15.02.22

