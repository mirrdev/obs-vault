## Введение—JS: DOM API

Что вообще такое фронтенд-разработка?

Современные сайты обладают высокой степенью интерактивности. Страницы перезагружаются всё реже, а манипуляции с содержимым происходят прямо на месте. Программные решения стали настолько сложными (комплексными), что уже сейчас в браузере реализуются полноценные среды разработки (например, редактор Хекслета), программы, подобные Photoshop или пакеты, аналогичные Microsoft Office. Существует большая индустрия игр, созданных для браузеров. Причём благодаря аппаратной поддержке эти игры не уступают тому, что делается и для обычного десктопа.

Язык, который изначально использовался как способ добавить снежинки на сайт, стал мощнейшим инструментом в руках профессионалов. На текущий день JavaScript — единственный язык, исполняемый браузерами.

Но одного языка недостаточно для того, чтобы оживить страницу. Браузер должен предоставить способ управлять как страницами, так и самим браузером. Большинство этих возможностей стандартизировано и описано в спецификациях HTML5. Вот некоторые из них:

- Манипуляция содержимым страницы
- Управление внешним видом
- Реакция на действия пользователя
- Работа с куками
- Управление браузером (адресная строка, навигация, история)
- Взаимодействие с сервером
- Проигрывание видео
- Ввод/Вывод. Взаимодействие с файловой системой и сетью
- 2D/3D рисование

С точки зрения языка, большинство этих возможностей выглядят как некие глобальные объекты, с которыми можно взаимодействовать в программе. Самым базовым и ключевым объектом этой системы является представление DOM-дерева.

В этом курсе мы научимся внедрять js на сайт, пройдём по основным способам манипулирования страницей, познакомимся с полифиллами, сделаем свой первый ajax-запрос и откроем для себя мир событий.

После этого курса вы сможете попробовать свои силы в создании простых фронтенд-игр (в практике после курса).

### Подготовка

Этот курс посвящен тому как оживлять страницы в браузере используя JavaScript. Подразумевается, что сам JavaScript уже хорошо изучен ранее, на других курсах Хекслета или за его пределами.

## JavaScript в браузере—JS: DOM API

JavaScript подключается на страницы сайта через тег `<script>`. Причем двумя разными способами: инлайн и внешним скриптом.

### Инлайн скрипты

Инлайн (in line) означает то, что JavaScript находится прямо внутри HTML. Такой способ подохдит для самых простых сценариев, когда кода мало:

```javascript
<html>
  <head>
  </head>
  <body>
    <!-- JS внутри тега script -->
    <script>
      const greeting = 'hello, world!';
      // Выводит приветствие на экран в модальном окне браузера
      alert(greeting);
    </script>

    <script>
      // Таких тегов может быть любое количество на странице
    </script>
  </body>
</html>
```

В примере используется функция `alert()`. Она выводит на экран модальное окно, с указанным текстом. В реальном коде `alert()` почти не используется, но её иногда используют для обучения. Нажмите сюда, чтобы увидеть результат выполнения этой функции.

Чаще всего, таким способом подключаются скрипты внешних сервисов, например, [систем аналитик](https://developers.google.com/analytics/devguides/collection/analyticsjs). Выглядит это так:

```javascript
// Код минифицирован, чтобы занимать как можно меньше места (ускоряет загрузку)
(function (i, s, o, g, r, a, m) {
  i["GoogleAnalyticsObject"] = r;
  (i[r] =
    i[r] ||
    function () {
      (i[r].q = i[r].q || []).push(arguments);
    }),
    (i[r].l = 1 * new Date());
  (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m);
})(
  window,
  document,
  "script",
  "https://www.google-analytics.com/analytics.js",
  "ga"
);

ga("create", "UA-XXXXX-Y", "auto");
ga("send", "pageview");
```

Если прямо сейчас открыть исходный код этой страницы, внутри HTML вы увидите множество тегов `<script>` с подобными вставками. Большая часть этих вставок находится ближе к началу HTML, так как для систем аналитики важно загружаться как можно раньше для отслеживания действий пользователя.

### Внешние скрипты

Во фронтенд приложениях инлайн-скриптинг не используется. Весь код грузится через подключаемые файлы. Загружаются внешние скрипты следующим образом:

```javascript
<html>
  <body>
    <head>
      <script src="/assets/application.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/core.js"></script>
    </head>
  </body>
</html>
```

JavaScript подключаемый таким образом, проходит предварительную обработку через системы сборки, например, Webpack. Они оптимизируют код для браузеров, делают его меньше, удаляют ненужное, разбивают по файлам для ускорения загрузки и многое другое. Подробнее об этом [тут](https://guides.hexlet.io/webpack/).

### Порядок выполнения

Тег `<script>` по умолчанию выполняется в том порядке, в котором он встречается в HTML независимо от того работаем мы с внешним файлом или инлайновым скриптом, поэтому расположение имеет значение. Чем ближе к концу страницы распологаются скрипты, тем быстрее пользователь увидит страницу на экране. Поэтому в идеальном случае все скрипты подключаются сразу перед `</body>`.

Порядком загрузки можно управлять с помощью атрибутов `defer` и `async`. Об этом можно прочитать [тут](https://flaviocopes.com/javascript-async-defer/).

### REPL

Существует и третий способ выполнения JavaScript кода на странице, который подходит для отладки и экспериментов. В браузере есть аналог REPL Node.js. Для этого в меню браузера нужно найти DevTools (инструменты разработчика) и вызвать их. Тогда снизу откроется блок, внутри которого будет вкладка console (консоль). В этой вкладке можно выполнять любой JavaScript код как и в серверном REPL. Но это не все, консоль соединена с той страницей, на которой она находится. То есть отсюда мы можем управлять содержимым экрана. Обязательно доберитесь до нее, она нам понадобится для экспериментов во всех последующих уроках.

### Особенности браузерного JavaScript

JavaScript в браузере и на сервере (через Node.js) это один и тот же язык. То есть Node.js это не отдельный язык программирования. Несмотря на это, у каждой из сред есть свои особенности, о которых нужно знать:

#### Модули

Большая часть встроенных модулей в Node.js недоступна в браузере. Поэтому их приходится заменять отдельными библиотеками. Некоторые модули доступны как глобальные объекты, например `URL` в браузере доступен по умолчанию.

#### Версии

Версия JavaScript на сервере определяется программистами, которые ставят конкретную версию Node.js. Во фронтенде контролировать версию JavaScript невозможно, так как мы не знаем в каком браузере загружается страница с нашим кодом. Вдруг это браузер встроенный в телевизор или машину? Поэтому во фронтенде очень опасно использовать новейшией возможности языка. Они могут просто не поддерживаться браузерами и часть пользователей увидит ошибки вместо сайта. Как решается эта проблема - в одном из следующих уроков.

#### Браузер и контент

JavaScript в браузере должен уметь взаимодействовать с самим браузером и структурой страницы. Иначе мы бы не смогли сделать ничего полезного, что делают современные веб-приложения. Для этого браузер встраивает в JavaScript объекты, через которые мы можем манипулировать происходящим на экране. Дальнейшие уроки, во многом, посвящены изучению этих объектов.

---

##### Самостоятельная работа

1. Откройте консоль в своем браузере.
2. Попробуйте позапускать в ней код на выполнение, например обычные арифметические операции

---

##### Дополнительные материалы

1. [Гайд "Зачем нужно собирать фронтенд"](https://guides.hexlet.io/webpack/)
2. [Урок по DevTools](https://ru.hexlet.io/courses/html/lessons/devtools/theory_unit)
3. [Курс "Протокол HTTP"](https://ru.hexlet.io/courses/http_protocol)

## Глобальный объект Window—JS: DOM API

`window` — это глобальный объект предоставляемый браузером. Через него происходит управление окнами (вкладками) в браузере. Он содержит функции для открытия вкладки, управление положением страницы и многим другим.

```javascript
// Открывает новую вкладку
window.open();
```

Window доступен в консоли DevTools, через который его удобно изучать. Попробуйте вызвать там метод из примера выше.

![Window](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImRkNWViYmY4MDZmY2NjMTI4YTgzMTgwZjUwYTYzMWZjLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e2c8a1d922d487aa73f8b79d92ad449443cf67b705a1362efb65250b22cc1170)

Вот некоторые примеры его возможностей:

```
// Возвращает объект, содержащий информацию об экране
window.screen;
// Screen {availWidth: 1280, availHeight: 775, width: 1280, height: 800, …}

// Перемещает страницу до точки (top, left)
window.scrollTo(0, 1000);

// Видимые высота и ширина страницы
// Меняются при изменении размеров окна
window.innerHeight;
window.innerWidth;
```

Кроме того, внутри `window` находится объект `document` через который, мы будем работать с содержимым страниы в следующих уроках.

С другой, window задает глобальный контекст выполнения. `window` хранит внутри себя все остальные глобально доступные свойства и объекты. Каждый раз, когда мы вызываем глобальные функции, такие как `alert()` или `console.log()`, браузер ищет их в объекте `window`. То есть в действительности происходит вызов `window.alert()`. То же самое относится и ко всем остальным функциям используемым напрямую, без импортов:

```javascript
console.log("hey");
// window.console.log('hey');

Math.abs(5);
// window.Math.abs(5);

// Можно даже так
close();
// вместо window.close()
```

### Опасность глобального состояния

Наличие объекта `window` — это техническая реализация JavaScript, на которую не стоит полагаться при разработке. Представьте себе код:

```javascript
window.globalProperty = "Global variables are evil";
```

Установка свойства в `window` автоматически делает это свойство доступным из любой точки кода в браузере. Другими словами так создаются глобальные переменные. Такие переменные создают массу проблем при разработке. Непонятно откуда они берутся и кто и как их меняет. На глобальные переменные нельзя полагаться, они ненадёжны. В любой момент любая часть кода может поменять их, что часто приводит к ошибкам в работе.

Более того, на страницах сайтов практически всегда подключаются скрипты, которые между собой никак не связаны. Это могут быть различные счётчики аналитических систем, маркетинговые инструменты и тому подобное. Все они имеют доступ к одному и тому же `window`. Это значит, что установка каких-то свойств в `window` в одном скрипте может случайно сломать работу другого скрипта, который использует такое же глобальное свойство.

В хорошо написанном коде объект `window` напрямую никогда не встречается. Однако знать про его существование важно для понимания того, как функционирует JavaScript в браузере.

---

##### Самостоятельная работа

1. Откройте консоль в своем браузере.

2. Изучите объект `window`.

3. Попробуйте выполнить открытие новой вкладки:

   ```javascript
   window.open();
   ```

---

##### Дополнительные материалы

1. [Window](https://developer.mozilla.org/ru/docs/Web/API/Window)

## BOM объекты—JS: DOM API

BOM - это набор глобальных объектов, управляющих поведением браузера. Все они также находятся внутри `window`. Разберем некоторые из них.

![BOM – Объектная модель браузера](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImM4YmE5NDc3ODVkOTk0Yzg5ZTkyZGYwYTgwYzc1ODliLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ca2489abf0a8fd240e483a23e2feb3511ecb58050e1757893a4b357b3573f7df)

#### Navigator

Предоставляет информацию о браузере, такую как версия, название, используемая локаль, доступные права, подключенные плагины.

![Navigator](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijc3ZWIyNjM4ODIwNjdjNGRjYTEzY2U0OGEyNTQ0MWZmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f991245a751c1195f276d3cbbc3fbbad23a77a0e4260e1c1272b56822a110c9d)

#### Location

Позволяет управлять адресной строкой. Например, вот так можно инициировать загрузку другой страницы:

```javascript
location.href = "https://hexlet.io";
```

![Location](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjRjMWRiOGEzZjI2M2ViZmYwMWU3OTFjMTI1ZGU4MTAzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e62e4b008fc43a32eecbd0baf17d39bcce7a1ee99e5923ec2c7c6bf5fbfec289)

#### History

С помощью этого объекта можно перемещаться по истории переходов, а также формировать её в тех ситуациях, когда не происходит реального перехода по страницам.

![History](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImY4ZTljNWQyNzdkYzRjNTNjNDY3NDk2ZjdlNmIxNDNkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c7f53d67dd2d51a97a22ed77458f6c42447c74c4c4bc9162a85e84d123d432e1)

#### Fetch

Современный метод для выполнения AJAX запросов. Именно с помощью функции `fetch()` происходит общение с сервером и другими сайтами. Подробнее об этом в одном из следующих уроков.

![Fetch](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjFhOTVmNTQwMTU4MmJmYmNjOGM4YTFiNGNlYmM4ZjlmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=dc3239a160ec12ac033dde9f414cdde64995e8e197f3c96d08e465e258b02656)

## Что такое DOM?—JS: DOM API

Для работы с JavaScript в браузере важно понимать то, как браузеры работают хотя бы в общих чертах. Возьмём любую страницу и рассмотрим основные шаги, которые выполняет браузер для её отображения.

![Произвольная страница](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImFkN2I3MzgxOGQ2MDQ3MGM0YjU1YzkwYTE1MDk0NTUxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=b301a291931c8af02a9cbf815f1a5c66ae42006f7e1c984df6e698b8f4680231)

С высоты птичьего полета процесс отображения страницы можно представить следующим образом:

1. Браузер выполняет запрос на сервер (предварительно выяснив этот адрес с помощью [DNS](https://guides.hexlet.io/dns/))

   ```
   GET /courses HTTP/1.1
   HOST: ru.hexlet.io
   ```

   В ответ сервер отправляет HTML.

2. Когда HTML получен, браузер начинает его разбор (говорят парсинг) и формирование внутренней структуры под названием DOM-дерево.

3. Затем это дерево (а не исходный HTML) используется для физической отрисовки страницы, которую мы и наблюдаем.

![Процесс отрисовки страницы браузером](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjcxYjE3YWVmODEwYzljMTQyMTg0YzEyZmY5NTc1MjZlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=670b148d9265efa53b8d26dbac4cec486e5ff6391616167b09c99f49939fcdbb)

Что такое DOM-дерево и зачем оно нужно для формирования страницы, когда у нас есть HTML? Дело в том, что HTML это просто текст. Его крайне неудобно использовать напрямую (скорее даже невозможно в данном случае). Гораздо проще создать на его базе объект, который будет соответствовать структуре самого HTML. Затем использовать его для формирования страницы. Именно этим объектом и является DOM-дерево.

Слово _дерево_ здесь используется не просто так. HTML имеет древовидную структуру. Теги вкладываются в другие теги, которые вкладываются в другие теги и так до бесконечности. Поэтому и получившийся объект имеет такую же, древовидную структуру.

![Связь между HTML и DOM](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImIwMmE3ZDVjNzYzNmRmNDQ4NjRhODViYzdiY2JmMDhjLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=5c2a7f1c496b3bf5d62ec6b29a0177b5b2e13109cd5371c2634769bbba7650ea)

_Примерно то же самое происходит с исходным текстом программы на JavaScript. Для интерпретатора текст неудобен и поэтому код внутри JavaScript сначала превращается в AST (Абстрактное Синтаксическое Дерево), которое уже затем используется для запуска_

Браузер формирует DOM-дерево где-то внутри себя, но вместе с этим, он предоставляет механизм для создания DOM-дерева прямо из JavaScript.

```javascript
const html = `
  <body>
    <p>hello, <b>world</b>!</p>
  </body>
`;

const parser = new DOMParser();

// Каждый html-тег становится узлом этого дерева,
// а теги, вложенные в него, становятся дочерними узлами.
// Для представления текста создаются специальные текстовые узлы.
// Важно то, что в DOM-дерево попадают все элементы,
// представленные в html, включая пробелы и переводы строк.
const doc = parser.parseFromString(html, "text/html");

// Выводим содержимое тега <body>
console.log(doc.body.innerHTML);
```

Объект, полученный выше, имеет определенную структуру, которая будет одинаковой во всех браузерах и других программах, работающих с HTML. Именно поэтому он содержит приставку DOM. Объектная модель документа (Document Object Model) — это не зависящий от платформы и языка формат, позволяющий программам и скриптам получить доступ к содержимому HTML-документов, а также изменять их содержимое, структуру и оформление.

Благодаря наличию этого стандарта у нас есть возможность писать одну версию кода для всех браузеров. Иначе, если бы каждый браузер делал, что хотел, пришлось бы писать код под каждый браузер индивидуально из-за их несовместимости. Однако, различия всё равно присутствуют. Браузеры развиваются с разной скоростью и не всегда поспевают за изменениями в стандарте DOM. Поэтому программистам приходится ждать появления новых возможностей в большинстве браузеров перед тем как они смогут их использовать. В более поздних уроках мы поговорим о том, как современные разработчики справляются с этими проблемами, используя полифиллы.

DOM-дерево текущей страницы доступно в JavaScript в виде объекта `document`, который наполнен большим количеством методов (согласно спецификации DOM) для манипулирования этим деревом. Любые изменения, которые производятся с ним, сразу же отображаются браузером на странице.

Например:

```javascript
// Вся страница (тег body) заменится на этот заголовок
document.body.innerHTML = "<h1>For Hexlet!</h1>";
```

### Восстановление

Те, кто сталкивались с HTML в реальной жизни, прекрасно знают, что если подать на вход браузеру ошибочный HTML с незакрытыми тегами, нарушенной вложенностью и другими проблемами, то мы не получим сообщений об ошибках. Браузер переварит этот HTML и что-то отобразит на экране. Возможно, вам не понравится увиденное, но оно будет работать.

```javascript
// Этот HTML содержит ошибки, но браузер его отобразит
const html = "</p>hello, hexlet<div>";
```

Браузер действительно восстанавливает структуру документа и делает это по очень хитрым правилам. И это логично, иначе было бы невозможно произвести парсинг в принципе. Но есть и другая причина: даже если сам HTML будет правильным, браузер при создании DOM-дерева добавляет в него узлы, представленные тегами в html, которые вы, возможно, пропустили, но стандарт требует их наличия. Например, в таблицы добавляется `<tbody>` и не важно был он в исходном HTML или нет.

![Восстановление невалидного HTML](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImUyMjJlZWM5OGI2ZWNlNDE3N2VmZmZhYTlkMDczOTY0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ac2695ca7ba996ecf53ec2fde33264f2ab372c53eac9cacdfb4f12b49543c33a)

Именно DOM открывает практически безграничные возможности по изменению страниц. Все библиотеки (jquery и другие) и фреймворки (angular, react) внутри себя манипулируют DOM. Это та база, вокруг которой построено всё во фронтенд-разработке.

---

##### Самостоятельная работа

1. Откройте консоль в своем браузере.

2. Используйте объект `document` для замены тела документа (как в примере выше) на следующий фрагмент:

   ```javascript
   <h1>This is my territory</h1>
   ```

## Навигация по DOM-дереву—JS: DOM API

Знакомство с DOM деревом проще всего начать с изучения структуры этого дерева. Если коротко, то DOM-дерево, состоит из узлов (нод, node), которые вместе образуют иерархию, аналогичную HTML. Часть узлов, при этом, являются _листовыми_, то есть не содержат внутри себя других узлов (детей), а часть _внутренними_ – у них есть дети. Конкретные узлы, чаще всего, описывают собой конкретные теги из HTML и содержат их атрибуты внутри себя. У узлов есть тип, который определяет набор свойств и методов узла. Ниже мы с ними познакомимся.

Корневой элемент в DOM-дереве соответствует тегу `<html>`. Доступ к нему можно получить так:

```javascript
const html = document.documentElement;
// Свойство tagName узла содержит имя тега в верхнем регистре
console.log(html.tagName); // => 'HTML'

// Содержимое тега HTML в виде узлов DOM-дерева.
// Текст тоже представлен узлом
html.childNodes; // [head, text, body]

// Потому что head выше body
html.firstChild; // <head>...</head>
html.lastChild; // <body>...</body>

// Второй ребенок. Обращение по индексу.
html.childNodes[1]; // #text
```

![Корневой узел DOM-дерева](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijg2ZGM1NDI2NGY0YmY0OGQwYTBhZGNlZGVhYjFjOGNmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9eeaa818f60b0c6ee8fadb1e82bb0da9c29be6d094c494f5cdf09bfb19afeb64)

Из-за того, что `<body>` и `<head>` всегда присутствуют внутри документа, их вынесли на уровень объекта `document` для более простого доступа:

```javascript
document.head;
document.body;
```

По дереву можно не только спускаться, но и подниматься:

```
// Родитель body это html
document.documentElement === document.body.parentNode; // true
document.body === document.body.childNodes[2].parentNode; // true
```

Итого, если представить дерево, то по нему можно двигаться как наверх к родительским, вниз к дочерним, так и вбок (влево и вправо) к сестринским (или братским). Картинка ниже это демонстрирует:

![Отношения узлов в DOM-дереве](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImM3NTQzOWViNGJkZWE0NzRjMjg0ZTZiYTkwMjU2OGMxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c61b02ddb8a8ad010ab445d4a04653d550a9c4305aa2df5364cefe26dbf4b3d2)

### childNodes

`childNodes` – свойство, с помощью которого можно получить детей, то есть узлы, вложенные в текущий (но только на один уровень вложенности). Еще говорят что это потомки первого уровня. В работе с `childNodes` есть несколько интересных моментов.

1. Это свойство доступно только для чтения. Попытка что-то записать в конкретный элемент не приведет к успеху:

   ```javascript
   // Ошибки не будет, но ничего не поменяется
   document.body.childNodes[0] = "hey";
   ```

   Изменение DOM дерева осуществляется специальным набором методов, которые будут рассмотрены в соответствующем уроке.

2. Хотя `childNodes` и возвращает набор элементов, это всё же не массив. В нём отсутствуют привычные методы, такие как `map()`, `filter()` и другие. Но, зато есть `forEach()`:

   ```javascript
   // Тип NodeList
   const nodes = document.documentElement.childNodes;

   nodes.forEach((el) => console.log(el));
   ```

   Если очень хочется, то его можно преобразовать в массив и затем уже работать привычным способом:

   ```
   Array.from(nodes).map(/*...*/);
   ```

### Иерархия

Узлы DOM-дерева не просто имеют типы, но эти типы выстраиваются в иерархию (отношение общее-частное). В иерархии подтипы наследуют свойства и методы родительских типов и добавляют специфичные свои:

![DOM Tree](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjkxYjQ4MTU2ZWJjOWU3MDdmNzk5MTI5NGZhODA3MTYyLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f840a9ad001a4172624f7145876a3dae3428cfeb9cc6cdb8725f0910ad1b8298)

```
// Самый простой способ посмотреть тип
document.body.toString(); // "[object HTMLBodyElement]"
document.body instanceof HTMLBodyElement; // true
```

Узлы с типами Text и Comment являются листовыми, то есть они не могут иметь детей. А вот элементы (производные типы от Element) — это то, с чем приходится иметь дело чаще всего. К элементам относятся все типы, представленные тегами в HTML.

При работе с деревом естественным образом возникают понятия _дети_ и _потомки_. Применительно к DOM-дереву это означает, что тег, у которого есть содержимое (тело), имеет детей и потомков. Чем они отличаются друг от друга?

```javascript
const html = `
  <html>
    <head></head>
    <body>
      <div id="parent-div">
        <h1>Заголовок</h1>
        Привет!
        <div class="child-div">
          <span>Какой-то <b>текст</b></span>
          <ol>
            <li>1</li>
            <li>2</li>
          </ol>
          <!-- End List -->
        </div>
      </div>
    </body>
  </html>
`;
```

Тег `<div>` (с id `parent-div`) содержит внутри себя три дочерних узла и 14 потомков. Почему?

Дочерние узлы: `<h1>`, текст `"Привет!"` и `<div>` (с классом `child-div`). Дочерними (по отношению к узлу) являются только те узлы, которые непосредственно в нём лежат (находятся на "первом уровне вложенности").

Потомками (по отношению к узлу) являются все вложенные в него узлы (находящиеся на "всех уровнях вложенности"). Потомками тега `<div>` (с id `parent-div`), помимо вышеупомянутых трёх дочерних тегов, являются ещё и все вложенные в эти дочерние теги узлы (а также узлы, вложенные в эти вложенные узлы, и т.д. ... согласно рекурсивной природе деревьев).

![Дети и Потомки в DOM-дереве](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImE2ZjUyOWIwNWZkZDU4YTY5YjE0ODVmOWEwZDlhZjRiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e2f28875010c251023f3fed214ea8c9fa8c4cd837f6d4a8ad78c3fbabc363fe5)

Дочерние узлы одновременно являются потомками. Обратное утверждение неверно: потомок необязательно является дочерним элементом (в примере тег `<span>` приходится потомком, но не ребёнком по отношению к тегу `<div>` с id `parent-div`).

### Элементы

На практике, чаще всего, нас интересуют не любые узлы, а элементы. Именно ими мы манипулируем, перемещаемся сквозь них. Это настолько важно, что в DOM есть альтернативный способ обхода дерева, который построен только на элементах.

![Отношения между элементами в DOM-дереве](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE5NTk5YTc5ODE3Y2Q3ZTkyMjdmZjk0ZDBkYzM2NzViLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=87847a85e03e0f33b85e94ba4d3b2cd1f932e6ac606f9993825efc83f577b378)

Все эти методы возвращают объекты типа Element и пропускают объекты Text или Comment. Это видно в примере ниже, где свойство `children` возвращает только теги. Этим `children` отличается от `childNodes`, который возвращает все узлы, включая листовые.

```
const node = document.documentElement;
node.children; // [head, body]
```

Между `children` и `childNodes` есть еще одно довольно важное отличие. Они возвращают не только разный набор узлов, но и сам тип коллекции в первом и втором случае разный. `childNodes` возвращает NodeList, а `children` – HTMLCollection. Они немного по-разному работают, но рассматривать эту разницу будет иметь смысл позже, когда мы познакомимся с селекторами.

### Специальная навигация

Некоторые элементы обладают специальными свойствами для навигации по ним, к таким элементам относятся, например, формы и таблицы.

```javascript
<table>
  <tr>
    <td>1.1</td>
    <td>1.2</td>
    <td>1.3</td>
  </tr>
  <tr>
    <td>2.1</td>
    <td>2.2</td>
    <td>2.3</td>
  </tr>
</table>;
const table = document.body.firstElementChild;
table.rows[0].cells[2];
```

Этот способ навигации не заменяет основные. Он сделан исключительно для удобства в тех местах, где это имеет смысл.

### Заключение

Нужно ли все эти методы знать наизусть? В реальности — нет. Важно понимать общие принципы устройства DOM-дерева, знать иерархию типов и то, как принципиально происходит обход элементов. Конкретные же методы и свойства всегда можно прочитать в документации. Наизусть их мало кто помнит и в этом нет практического смысла.

Кроме того, обход дерева данными способами – это низкоуровневый способ работы. На практике для выборки нужных элементов используют селекторы, которые изучаются далее.

---

##### Самостоятельная работа

1. Откройте консоль в своем браузере.
2. Начиная от `document.body` доберитесь до самых глубоких узлов, содержащих этот текст.

## Декларативный поиск по DOM-дереву—JS: DOM API

Как правило, в реальных фронтенд-задачах нужно манипулировать наборами элементов (или одним), находящимися где-то глубоко в DOM-дереве. Причём зачастую эти элементы разбросаны по его разным частям. Например, мы можем отметить список файлов на удаление и выполнить это действие. С точки зрения изменения DOM-дерева эта задача сводится к выборке всех элементов, которые представляют файлы (с точки зрения визуализации), и их последующему удалению.

### Специализированные поисковые методы

В такой ситуации ручной проход по дереву окажется крайне утомительным занятием. DOM предлагает сразу несколько способов решения этой задачи. Самый простой вариант поиска — это поиск по идентификатору:

```javascript
<p id="content">Это параграф</p>;
const el = document.getElementById("content");
```

Так как `id` в соответствии со спецификацией обязан быть уникальным на странице, то и метод `getElementById()` всегда возвращает один элемент. С другой стороны, по случайности в HTML может оказаться несколько тегов с одним `id`. В такой ситуации браузер вернёт первый встреченный элемент.

Если нужна обработка сразу нескольких элементов, то тут лучше подойдёт поиск по классу:

```javascript
// Поиск по всему дереву
// Возвращаются все элементы с таким классом. Они могут быть совершенно разными.
const collection = document.getElementsByClassName("row");

// Этот метод позволяет искать не только в целом документе,
// но и среди потомков любого элемента.
el.getElementsByClassName("row");
```

При необходимости можно искать по тегу. На практике такое встречается не часто, но знать про этот метод полезно:

```javascript
document.getElementsByTagName("span");

// поиск всех элементов
document.getElementsByTagName("*");

// поиск среди потомков el
el.getElementsByTagName("span");
```

### Поиск по селектору

Наиболее универсальным способом поиска является поиск по селектору. Напомню, что селектор — это правило, позволяющее описать набор элементов в DOM-дереве.

```javascript
<ul id="menu">
  <li class="odd">
    <span>Первый</span> пункт
  </li>
  <li>Второй</li>
  <li class="odd">
    <span>Третий</span> пункт
  </li>
</ul>;
// Возвращает первый найденный элемент по указанному селектору
// Ищется элемент с id=menu
const ul = document.querySelector("#menu");

// Все спаны, вложенные в теги с классом .odd
const spans = ul.querySelectorAll(".odd > span");
```

Оба метода `querySelector()` и `querySelectorAll()` могут применяться как ко всему документу, так и к конкретному элементу. Поиск, как обычно, будет вестись среди всех потомков.

### Полезные методы

#### matches

Предикат `el.matches(css)` проверяет, удовлетворяет ли `el` селектору `css`.

```
<p class="font-weight">This is Hexlet!</p>
const el = document.querySelector('p');
el.matches('.unknown-class'); // false
el.matches('.font-weight'); // true
```

#### closest

Метод `el.closest(css)` ищет ближайший элемент выше по иерархии, удовлетворяющий селектору. Сам элемент тоже анализируется. Если такой элемент найден, то возвращается он, иначе возвращается `null`.

```javascript
<div class="row" id="one">
</div>
<div class="row" id="two">
  <div class="row" id="three">
    <span>where is the closest?</span>
  </div>
</div>
const el = document.querySelector('span');
const ancestor = el.closest('.row');
ancestor.id; // 'three'
```

### XPath

Язык запросов, изначально разработанный для навигации по DOM в XML. Поддерживается браузерами.

```javascript
<html>
  <body>
    <div>
      Первый слой
      <span>блок текста в первом слое</span>
    </div>
    <div>Второй слой</div>
    <div>
      Третий слой
      <span class="text">первый блок в третьем слое</span>
      <span class="text">второй блок в третьем слое</span>
      <span>третий блок в третьем слое</span>
    </div>
    <span>четвёртый слой</span>
    <img />
  </body>
</html>
```

XPath-путь `/html/body/*/span/@class` будет соответствовать в нём двум элементам исходного документа — `<span class="text">первый блок в третьем слое</span>` и `<span class="text">второй блок в третьем слое</span>`.

В повседневной практике он практически не встречается при работе с DOM, поэтому здесь он показан только для полноты картины. А вот при работе с XML-документами, XPath – основной способ навигации по документу.

## Консоль разработчика—JS: DOM API

DevTools – мощный инструмент отладки и анализа происходящего на странице. Эффективная фронтенд–разработка невозможна без его использования. Современные браузеры поголовно оснащены этим полезным инструментом, его нужно только найти в меню и активировать. А дальше стоит потратить время и изучить возможности DevTools. Сейчас они настолько широки, что не хватит и целого курса на изучение всех его возможностей. В интернете полным полно статей (в том числе на русском), которые рассказывают про самые интересные способы использования и скрытые возможности. Поэтому здесь мы пройдемся только по базовым возможностям.

### Анализ ошибок

![DevTools Stack Trace](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImRlYjQ4NWUyMmI3MjQ3NmIwYzYyYWVhNjU3NzFjMGQwLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=b7facc0a750fcb61fdecb272733db704266670e66c715d007a79554e7ac02356)

Все ошибки, которые происходят в браузерном js, выводятся в консоль. Их можно не только посмотреть, но также и открыть исходник, чтобы изучить место возникновения ошибки.

### Выбранный элемент

![devtools доступ к выбранному элементу](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjA1NWVlYWJiMTcyNzIyMDNlNzI2MTZlNzNkYWZhNDFjLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=b2c07369cd38d61cfaf4ecb148c33ba5ead9d3cf3d9792044f57145f59f1c609)

Выбрав таким образом элемент, можно переключиться на вкладку `console` и набрать `$0`. Так вы получите доступ к этому элементу.

### Поиск

![devtools поиск элементов](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImRjOGE5Y2FiZjdkOTEyNDRhMDVkMjIxMDI1YjBjYTdiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e99efcc30be22c8cccbdf4ffd6ef09f7fdb1490d4e4d2d021fef218da6f7065d)

Используя функцию `$()` можно упростить поиск элементов по селектору. Сравните:

```javascript
document.querySelector(".row");

// Технически похоже на работу с JQuery, но это не он
$(".row");
```

### console.dir

![devtools console.dir](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImMwMjA0NDllMTI3OGM0YTE2ZDI3NGYyNGZlYzRhMjY2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=60306755df121141f37c6e5263cd39365a990676da74a92f76a0a3a56fe7a47c)

Функция `console.dir` выводит узлы DOM в формате, удобном для анализа.

---

##### Дополнительные материалы

1. [Отладка кода в браузере (видео)](https://www.youtube.com/watch?v=hNIvcEcj-XA&feature=youtu.be)
2. [Chrome DevTools](https://ru.hexlet.io/courses/html/lessons/devtools/theory_unit)

## Манипулирование DOM деревом—JS: DOM API

То, что DOM-дерево может меняться, уже будучи отрисованным в браузере, и есть ключевая возможность для создания интерактивных приложений.

### innerHTML

Самый простой способ обновить часть DOM — это свойство `innerHTML`:

```javascript
<ul>
  <li>item 1</li>
  <li>item 2</li>
</ul>;
const body = document.body;
console.log(body);
// <ul><li>item 1</li><li>item 2</li></ul>

body.innerHTML = "<b>make</b> love";
console.log(body.innerHTML);
// <b>make</b> love

console.log(body.childNodes);
// [b, text]
```

Значение этого свойства целиком заменяет потомков элемента, на котором оно было вызвано. Весь встречающийся внутри HTML анализируется и становится частью дерева. Если вы пытаетесь вставить обычный текст, который потенциально может содержать HTML (Это позволяет проводить XSS атаки), то лучше воспользоваться другим свойством – `textContent`.

`textContent` работает практически идентично, оно также заменяет всех потомков. Главное отличие между этими свойствами заключается в том, что `textContent` рассматривает свое содержимое как обычный текст в любом случае, даже если там есть HTML.

```javascript
document.body.textContent = "<b>make</b> love";
console.log(document.body.innerHTML);
// Все специальные символы оказываются замененными
// "&lt;b&gt;make&lt;/b&gt; love"
```

`innerHTML` работает со строками, такой подход удобен только в том случае, когда мы работаем со статическим представлением DOM. Для динамического формирования хорошо подходят специальные функции.

### Создание узлов

```javascript
// Создаем текстовый узел
const textNode = document.createTextNode("life is life");

// Создаем элемент p
const pEl = document.createElement("p");

// Добавляем textNode в конец списка childNodes элемента pEl
pEl.append(textNode);
// pEl.textContent = 'life is life';

const el = document.createElement("div");
el.append(pEl);

console.log(el);
// <div><p>life is life</p></div>
```

Код, создающий DOM динамически, похож на матрешку. После создания одни элементы все время вкладываются в другие. Так выглядит код, который конструирует деревья в любом языке.

### Вставка

[ParentNode.prepend()](https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend) добавляет переданный узел (или узлы) первым ребенком в `ParentNode`:

```javascript
const div = document.createElement("div");
div.innerHTML = "<span>Hexlet</span>";

const el = document.createElement("p");
el.textContent = "prepend";
div.prepend(el);
// <div>
//   <p>prepend</p>
//   <span>Hexlet</span>
// </div>
```

[ParentNode.append()](https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append) добавляет переданный узел (или узлы) последним ребенком в `ParentNode`:

```javascript
const div = document.createElement("div");
div.innerHTML = "<span>Hexlet</span>";

const el = document.createElement("p");
el.textContent = "append";
div.append(el);
// <div>
//   <span>Hexlet</span>
//   <p>append</p>
// </div>
```

[childNode.before(...nodes)](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/before) – вставляет `nodes` в список детей родительского узла `childNode` прямо перед `childNode`.

```javascript
const div = document.createElement("div");
div.innerHTML = "<span>Hexlet</span>";
// Должен быть вставлен в DOM-дерево
document.body.append(div);

const el = document.createElement("p");
el.textContent = "content";
div.before(el);
// <p>content</p>
// <div>
//   <span>Hexlet</span>
// </div>
```

[childNode.after(...nodes)](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/after) – вставляет `nodes` в список детей родительского узла `childNode` сразу после `childNode`.

```javascript
const div = document.createElement("div");
div.innerHTML = "<span>Hexlet</span>";
// Должен быть вставлен в DOM-дерево
document.body.append(div);

const el = document.createElement("p");
el.textContent = "content";
div.after(el);
// <div>
//   <span>Hexlet</span>
// </div>
// <p>content</p>
```

[node.replaceWith(...nodes)](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/replaceWith) – вставляет nodes вместо `node`. Сама `node` пропадает из DOM-дерева, но остается доступной в коде.

```javascript
const div = document.createElement("div");
div.innerHTML = "<span>Hexlet</span>";
// Должен быть вставлен в DOM-дерево
document.body.append(div);

const el = document.createElement("p");
el.textContent = "content";
div.replaceWith(el);
// В Dom-дереве вместо div остался p
// <p>content</p>
```

`node.remove()` – удаляет текущий узел.

### Старый API

Описанные выше функции появились не так давно. Большая часть кода написана с использованием других функций, список которых ниже:

- `parent.appendChild(el)` – добавляет `el` в конец списка детей
- `parent.insertBefore(el, nextElSibling)` – добавляет `el` в список детей `parent` перед `nextElSibling`
- `parent.removeChild(el)` – удаляет `el` из детей `parent`
- `parent.replaceChild(newEl, el)` – заменяет `el` на `newEl`

### Клонирование

Иногда требуется создать элемент, подобный уже существующему. Можно, конечно, это сделать полностью руками, копируя свойства одного в свойства другого, но есть способ проще:

```javascript
const newEl = el.cloneNode(true);
```

`true` говорит о том, что нужно сделать "глубокую" копию, другими словами, вы получите копию не только этого элемента, но и всех его потомков.

## Управление узлами DOM—JS: DOM API

Самая большая часть DOM API сосредоточена в свойствах конкретных элементов. В этом уроке мы рассмотрим только самые базовые свойства, исключительно с целью показать то, как они работают в принципе. В повседневной практике программисты постоянно обращаются к [документации](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model), чтобы узнать, какие есть свойства и методы у узлов для управления ими.

![Атрибуты и свойства](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE0NTUzNDI1NzUyNjEwMmI2MTc0MGRiN2QyNDQ3YmVlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=fd533140c62bfbc2817a59d713e219533c28290c780cf9e03da9d838baa9e15e)

### Атрибуты

У каждого тега в HTML есть атрибуты. Некоторые из них общие для всех, другие специфичные для конкретных тегов.

```javascript
<a id="aboutPage" href="/pages/about" class="simple">
  About
</a>
```

В примере выше, атрибуты `id` и `class` могут использоваться с любым тегом. Атрибут `href` только с некоторыми, например, с тегом `<a>`.

Когда браузер загрузил HTML, на его основе строится DOM. Во время обработки, каждый тег становится узлом, а атрибуты – свойствами этого узла. Обычно имена атрибутов и свойств узлов совпадают между собой:

```javascript
// <a id="aboutPage" href="/pages/about" class="simple">About</a>
const el = document.querySelector("#aboutPage");
el.id; // aboutPage
el.href; // https://ru.hexlet.io/pages/about
```

Существуют и исключения, например, атрибуту `class` соответствует свойство `className`. Более того, для удобной работы с классами предусмотрены дополнительные способы работы. Это нужно по той причине, что классов может быть много и задаются они обычной текстовой строкой. Соответственно, если возникает задача изменения этого списка, то придется оперировать строчками, что совсем неудобно. А вот как можно это делать, используя возможности DOM:

```javascript
// У тега с таким id класс содержит строку "simple"
const el = document.querySelector("#aboutPage");
el.classList.add("page");
el.classList.remove("simple");
// После всех изменений
el.className; // page
```

Дополнительные методы:

- `el.classList.contains("class")` – проверяет содержит ли элемент нужный класс. Возвращает true/false.
- `el.classList.toggle("class")` – если класс есть, удаляет его, и наоборот.

Именование – не единственное различие между атрибутами и свойствами. Отличий значительно больше и они не всегда очевидны. Вот лишь некоторые из них:

1. Атрибут — всегда строка, а свойство — не всегда. Например:

   ```
   <textarea rows="5"></textarea>
   ```

   Значение свойства `rows` соответствующего элемента в DOM дереве будет числом.

2. Атрибуты не чувствительны к регистру

   ```
   <a Id="aboutPage" hrEf="/pages/about" CLASS="simple">About</a>
   ```

   Так писать, конечно же, не стоит, но по крайней мере знать о том, что оно работает — полезно.

3. Атрибут всегда присутствует в HTML, а значит доступен через `innerHTML`. А вот многие свойства не имеют соответствующих атрибутов. Например у тега `<a>` есть свойство `hash`, но нет такого атрибута.

Как мы увидели выше, атрибут и свойство, в общем случае — не одно и то же. Поэтому существует набор методов для управления атрибутами:

- `el.hasAttribute(name)` – проверяет наличие атрибута
- `el.getAttribute(name)` – получает значение атрибута
- `el.setAttribute(name, value)` – устанавливает атрибут
- `el.removeAttribute(name)` – удаляет атрибут
- `el.attributes` – список html атрибутов

```javascript
// Методы работают с атрибутами html
el.getAttribute("class");
```

Обратите внимание на то, что они работают именно с атрибутами (их именами), а не свойствами. И позволяют не только их извлекать, но и менять. Возникает закономерный вопрос: поменяется ли атрибут, если поменять свойство и наоборот?

В основном синхронизация осуществляется только в сторону свойств. То есть меняется атрибут и автоматически обновляется свойство. Но существуют и исключения. Из этих тезисов не следует делать вывод, что нужно стараться работать через атрибуты. Наоборот, по возможности, всегда работайте со свойствами DOM-дерева, а атрибуты используйте только для чтения, чтобы получить то состояние, которое было в DOM на момент инициализации (парсинга HTML).

```javascript
<a id="aboutPage" href="/pages/about" class="simple">
  About
</a>;
const el = document.querySelector("#aboutPage");
el.setAttribute("class", "page");
el.className; // page
el.getAttribute("class"); // page
```

В отличие от свойств значение атрибута всегда совпадает с тем, что мы видим в HTML, а вот свойства иногда приводятся в нормализованный вид:

```javascript
<!-- В этот момент браузер открыт на https://ru.hexlet.io -->
<a id="link-to-courses" href="/courses">Курсы</a>
const el = document.querySelector('#link-to-courses');
el.href; // https://ru.hexlet.io/courses
el.getAttribute('href'); // /courses
```

Нестандартные атрибуты никогда не превращаются в свойства соответствующих элементов DOM дерева. То есть, если мы добавим в тег `p` атрибут `href`, то он будет проигнорирован. Хотя это не отменяет возможность его извлечения через `getAttribute`.

Для работы с произвольными свойствами в html зарезервирован специальный атрибут `data-*`, где на месте звездочки может стоять любое слово.

```javascript
<a href="#" data-toggle="tab">
  Мои проекты
</a>
```

Такие атрибуты активно используются в JavaScript плагинах и позволяют не завязываться на классы. В элементах DOM они доступны через специальное свойство `dataset`:

```javascript
console.log(el.dataset.toggle); // => tab
```

Внутри объекта `dataset` имя каждого свойства — это строка после `data-` в атрибуте. Если имя содержит дефис, то он удаляется, а следующая за ним буква становится заглавной:

```javascript
<a href="#" data-nav-toggle="tab">
  Мои проекты
</a>;
console.log(el.dataset.navToggle); // => tab
```

### Свойства

В зависимости от типа элемента меняется и набор свойств. Кроме, конечно, тех, что достались в наследство от Node и Element.

Чтобы узнать список этих свойств, можно обращаться к спецификации. Они описаны в специальном формате, который несложно понять:

```javascript
// HTMLLinkElement – Просто название интерфейса
// HTMLElement – родительский тип, от которого наследуются свойства и методы
// attribute – обозначение конкретного атрибута, его типа и имени
interface HTMLLinkElement : HTMLElement {
  // Последнее слово в каждой строке это имя свойства в объекте
  attribute USVString href;
  attribute DOMString? crossOrigin;
  attribute DOMString rel;
  attribute RequestDestination as; // (default "")
  readonly attribute DOMTokenList relList;
  attribute DOMString media;
  attribute DOMString nonce;
  attribute DOMString integrity;
  attribute DOMString hreflang;
  attribute DOMString type;
}
```

Как и в случае с навигацией по DOM-дереву, нет нужды запоминать все особенности поведения атрибутов и свойств. Как правило, хорошее понимание приходит на практике во время экспериментов, методом проб и ошибок.

## Полифиллы—JS: DOM API

DOM непрерывно развивается. Какие-то браузеры его адаптируют быстрее, какие-то медленнее. Все это не позволяет легко и непринужденно пользоваться последними новинками. Разработчикам каждый раз нужно думать о том, какие браузеры распространены у пользователей их проектов.

_Информацию о том какие браузеры актуальны, обычно, узнают из аналитики, например google analytics, которая в режиме реального времени собирает её со всех, кто заходит на сайт._

В некоторых, особо сложных ситуациях, приходится поддерживать совсем старые браузеры, которые практически ничего не могут. Такое нередко встречается в государственных организациях.

Например, есть метод `matches()`, который ищет элементы по CSS-селекторам. Он поддерживается Internet Explorer, но только с 9й версии. Если в вашем проекте заявлена совместимость с 8й, то на вызов этого метода будет получена ошибка.

```javascript
const div = document.querySelector("div");
div.matches(".someClass"); // Uncaught TypeError: matches is not a function
```

К счастью, природа JavaScript позволяет частично компенсировать недостатки старых браузеров. Благодаря прототипам у разработчиков есть возможность добавить недостающую функциональность прямо в реализацию DOM. Делается это с помощью полифиллов.

Общий принцип работы этих библиотек следующий:

1. Проверяем наличие нужного метода или свойства.
2. Если их нет, то добавляем.

Важно чтобы библиотека с полифиллами грузилась до выполнения любого другого кода. Только в этом случае остальной код может рассчитывать на наличие нужных свойств.

### Добавление метода

Ниже пример полифилла для метода `node.matches()`. Этот полифилл работает для всех популярных браузеров и задействует их специфику (видно по именам свойств).

```javascript
(function (constructor) {
  const p = constructor.prototype;
  if (!p.matches) {
    p.matches =
      p.matchesSelector ||
      p.mozMatchesSelector ||
      p.msMatchesSelector ||
      p.oMatchesSelector ||
      p.webkitMatchesSelector;
  }
})(window.Element);
```

После выполнения этого кода, можно использовать метод `element.matches()`, не боясь его отсутствия в старых браузерах.

### Добавление свойства

Значительно более сложный вариант – добавление свойства `ParentNode.lastElementChild`. Здесь прямо приходится программировать логику поиска нужного элемента.

```javascript
// Обратите внимание на то, что добавление свойства производится особым образом,
// таким, который позволяет сделать свойство динамическим и ленивым.
// То есть его значение будет вычисляться только в момент обращения.
if (!("lastElementChild" in document.documentElement)) {
  Object.defineProperty(Element.prototype, "lastElementChild", {
    get: function () {
      for (let nodes = this.children, n, i = nodes.length - 1; i >= 0; --i) {
        if (((n = nodes[i]), 1 === n.nodeType)) {
          return n;
        }
      }
      return null;
    },
  });
}
```

Примеры выше не являются полными. Если посмотреть исходники соответствующих библиотек, то хочется их быстрее закрыть. Количество кода иногда зашкаливает до неприличия. Обеспечение универсальной работы во всех браузерах (и всех их версиях) непростая задача.

Чтобы узнать поддержку определенных фич в разных браузерах, можно воспользоваться прекрасным ресурсом https://caniuse.com/. А самый простой способ добавить полифиллы на свой сайт — это воспользоваться проектом [polyfill.io](https://polyfill.io/v3/). Кроме этого проекта, на гитхабе огромное количество готовых полифиллов для любых частей DOM. Они разбросаны по разным репозиториям разных людей, поэтому если вам понадобится что-то полифиллить, то сначала придется потратить время на поиск нужной библиотеки.

![Can I Use](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImNhMjE3NWNmYWRmMTZiMDc4YTRmOTBlOGMwMzc5MWQ4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a6805fc585e3d6e31e4baa783137124ffe23ee0838e0f9d246d4084c2c6baf8c)

Иногда бывает нужно просто проверить наличие определенной фичи, и в зависимости от результата выполнять разный код. В такой ситуации поможет библиотека _modernizr_.

```javascript
// Проверяется наличие flash
Modernizr.on("flash", (result) => {
  if (result) {
    // the browser has flash
  } else {
    // the browser does not have flash
  }
});
```

### Ядро JavaScript

Но полифиллы бывают не только для DOM. Сам JavaScript тоже непрерывно развивается, особенно последние годы. Многие фичи современного JavaScript настолько упрощают разработку, что без них уже сложно. Поэтому практически ни один современный проект не обходится без библиотеки [core-js](https://github.com/zloirock/core-js). Эта библиотека закрывает почти все возможности современного JavaScript.

Она устанавливается, как зависимость проекта и один раз подключается на самом верхнем уровне приложения и делает сама всю работу, без необходимости сборки приложения [вебпаком](https://ru.hexlet.io/courses/js-dom/lessons/js/theory_unit).

```javascript
import "core-js/stable";
// другие зависимости
```

Далее в курсе будут упражнения, где в _index.js_ вы увидите подключение этой библиотеки.

## Введение в события—JS: DOM API

Интерактивные системы, такие как сайты в браузере или даже терминал, устроены по одному и тому же принципу. После загрузки они находятся в режиме "ожидания" действий от пользователя. К таким действиям относятся клики, набор текста, перемещение мышки, горячие клавиши и многое другое.

С точки зрения кода, все действия представлены событиями. Вот некоторые из них:

- click
- submit
- keyup/keydown
- focus
- contextmenu
- mouseover
- mousedown/mouseup

Детализация событий достаточно высокая, набор текста раскладывается на два события: кнопка зажата и кнопка отпущена. Кроме этого, есть специальное событие _keypress_, которое позволяет отличать горячие клавиши от нормального ввода.

Любое событие связано с конкретным элементом в DOM. Чтобы добавить новое поведение, нужно найти элемент и добавить колбек в метод `addEventListener()`, который будет вызван тогда, когда произойдет событие:

```javascript
<button id="myButton"></button>;
const button = document.getElementById("myButton");

// Добавляем обработчик, который вызовется при клике на элементе button
button.addEventListener("click", () => alert("Boom 1!"));

// Добавляем второй обработчик
button.addEventListener("click", () => alert("Boom 2!"));
```

Каждый обработчик события представляет собой функцию, которая будет вызвана в момент наступления события. Обработчики вызываются один за другим, в том же порядке, в котором они были определены. Обратите внимание, что обработчик — это функция, а не результат вызова функции. Вот так делать неверно:

```javascript
const button = document.getElementById("myButton");
const handler = () => alert("Boom 1!");
button.addEventListener("click", handler()); // вызывается обработчик
```

При необходимости, можно удалить обработчик:

```javascript
const button = document.getElementById("myButton");

const handler = () => alert("Boom 1!");
button.addEventListener("click", handler);

// Важно что сюда передается ровно та же самая функция (по ссылке)
button.removeEventListener("click", handler);
```

События можно вызывать программно. Например это актуально для [фокуса](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus). Представьте, что вы открываете чат в надежде написать туда сообщение, но текст не набирается. Для набора текста, нужна фокусировка на поле для ввода. По умолчанию этого не происходит и именно в этом месте мы должны поучаствовать:

```
const input = document.getElementById('textInput');
input.focus();
```

### Объект события

С каждым возникающим событием связана информация, зависящая от типа события. Например, событие _click_ это не только факт сам по себе, но также и координаты точки на экране, где был совершен клик. Эта информация доступна через специальный объект-событие, передающийся в обработчик события. Такой объект всегда передается в любой обработчик как единственный параметр.

```javascript
<div id="myElement">Бум!</div>;
const button = document.getElementById("myElement");

button.addEventListener("click", (e) => {
  // Координаты точки, в которой произошел клик
  console.log(e.clientX);
  console.log(e.clientY);
});
```

Базовые свойства объекта-события Event:

- `event.target` - элемент, на котором произошло событие
- `event.type` - тип события

У каждого типа событий свой набор свойств, подробнее о них смотрите в [документации](https://developer.mozilla.org/ru/docs/Web/API/Event).

### Действие по умолчанию

Для некоторых элементов, браузер выполняет действие по умолчанию при срабатывании определенных событий. Например, если повесить обработчик на клик по ссылке, то, выполнив этот клик, мы внезапно перейдем на другую страницу, ту, которая была указана в атрибуте `href`. Здесь мы видим пример того самого действия по умолчанию, на которое никак не влияет наличие обработчиков. Чтобы отменить это действие, а такое бывает нужно часто, необходимо вызвать метод `event.preventDefault()` внутри обработчика.

```javascript
<a href="#" id="myElement">
  Бум!
</a>;
const button = document.getElementById("myElement");

button.addEventListener("click", (e) => {
  // Если этого не сделать, то браузер выполнит загрузку новой страницы
  e.preventDefault();
  alert(e.target.textContent);
});
```

Действиями по умолчанию обладают следующие элементы:

- Клик по ссылке приводит к переходу на страницу указанную в _href_ атрибуте.
- Клик на кнопку с типом _submit_ начинает отправку формы на сервер.
- Вращение колесом мышки в `textarea` передвигает текст, если он не помещается
- Вызов контекстного меню с помощью правого клика мышки

### Конкуренция между событиями

В процессе выполнения обработчиков могут возникать новые события как от действий пользователя, так и программно, в самих обработчиках, а некоторые события всегда возникают целым блоком, например _mouseup_ и _click_. Но это не означает, что выполнение кода сразу переключается на обработку этих событий. Вместо этого события складываются в очередь и выполняются последовательно.

Но некоторые события все же берутся в обработку сразу. Это касается тех событий, которые генерируются программно, например _focus_.

Возникает закономерный вопрос, что происходит со страницей во время выполнения обработчика? И здесь возможны варианты. Если обработчик выполняет некоторый код синхронно, например, занимается вычислениями, то в этот момент блокируется всё остальное и страница замирает (говорят "фризится"). Если такое поведение длится слишком долго, то некоторые браузеры зависают, а другие предлагают закрыть вкладку. Отсюда вывод, обработчики должны выполнять свою задачу максимально быстро. А что если задача асинхронная, например, выполняется запрос к серверу? В таком случае все продолжает прекрасно работать, так как HTTP-запросы не блокируют выполнение кода.

Вообще говоря, из этого урока должно стать понятно, почему JavaScript именно такой, какой есть. Событийная система возможна только в асинхронном коде. По сути, при загрузке страницы происходит инициализация и установка обработчиков, а дальше, как правило, не выполняется никакой код, вся страница находится в ожидании действий от пользователя.

## События на практике—JS: DOM API

В этом уроке мы рассмотрим решение типичной фронтенд задачи, пользуясь полученными ранее знаниями. Представьте себе обычное меню, в котором по клику меняется активный элемент.

<iframe allowfullscreen="true" allowpaymentrequest="true" allowtransparency="true" class="cp_embed_iframe " frameborder="0" height="265" width="100%" name="cp_embed_1" scrolling="no" src="https://codepen.io/hexlet/embed/bGEMXPY?height=265&amp;theme-id=light&amp;default-tab=html%2Cresult&amp;user=hexlet&amp;slug-hash=bGEMXPY&amp;editable=true&amp;pen-title=js_dom_events_in_action_nav&amp;name=cp_embed_1" title="js_dom_events_in_action_nav" loading="lazy" id="cp_embed_bGEMXPY" style="box-sizing: border-box; border: 0px; width: 742.5px; overflow: hidden; display: block;"></iframe>

Принцип работы здесь следующий. Ссылке, на которую кликает пользователь, добавляется класс `active`, благодаря чему выделяется новый пункт меню. Со предыдущим выбранным пунктом происходит ровно наоборот, там, у ссылки, удаляется класс `active`.

Если решать эту задачу в лоб, то нам понадобится извлечь из DOM все ссылки меню и повесить на каждую из них обработчик нажатия. Этот обработчик будет активировать текущий элемент и деактивировать предыдущий:

```javascript
// Нужно извлечь все ссылки
const links = document.querySelectorAll("a");
// На каждую кнопку вешается событие
// Для этого обходим все ссылки и на каждую вешаем обработчик
links.forEach((link) => {
  link.addEventListener("click", () => {
    // Нужно деактивировать предыдущий выбранный элемент

    // Выделяем текущий
    link.classList.add("active");
  });
});
```

Как правильно снять выделение с предыдущего элемента? Проблема в том, что мы не знаем какой элемент был выбран. У этой задачи есть несколько решений.

Запоминать выделенный элемент и снимать с него нужный класс в момент клика по новому элементу. Этот способ требует введения состояния, какой-то переменной, которая хранит текущий выделенный элемент. Дополнительную сложность добавляет первая загрузка, так как выделенный элемент скорее всего уже приходит в готовом HTML, а значит в js еще нет информации о том, кто активен. В целом этот способ довольно затратен в реализации.

Гораздо проще пойти другим путем. Вместо того, чтобы пытаться обновлять элементы точечно, мы просто снимем выделение со всех элементов сразу. И не важно был ли выделен элемент или нет – операция удаления класса идемпотентная, то есть она не приводит к ошибке если у элемента не было класса, который удаляется.

```javascript
links.forEach((link) => {
  link.addEventListener("click", () => {
    // Удаляем активный класс со всех ссылок
    links.forEach((link) => link.classList.remove("active"));
    link.classList.add("active");
  });
});
```

Такое решение намного проще, хотя и делает немного лишней работы. На этом можно было бы закончить, если бы не одно серьёзное но. Инициализация меню работает неправильно. Почему?

Не каждое меню управляется js, но текущий код этого не учитывает. Он будет пытаться работать с любым меню на странице, что неправильно. Правильный способ основан на использовании специального указателя, который говорит о том, что меню должно управляться с помощью js. Хорошей практикой считается использовать для этого \*data-\*\* атрибуты.

То есть добавление js логики работает только для тех меню, у которых есть нужный атрибут:

```html
<ul class="nav">
  <li>
    <a class="active" data-toggle="tab" href="#home">Home</a>
  </li>
  <li>
    <a class="active" data-toggle="tab" href="#profile">Profile</a>
  </li>
  <li>
    <a class="active" data-toggle="tab" href="#contact">Contact</a>
  </li>
</ul>
```

Соответственно наш код должен поменяться на следующий:

```javascript
const links = document.querySelectorAll('[data-toggle="tab"]');
```

Но даже в этом случае код работает неверно. Сейчас он построен исходя из расчета одного меню на страницу. А компонент _nav_ может добавляться на одну страницу неограниченное число раз. Например, на Хекслете есть места с тремя меню на одной странице.

Если запустить текущий код с несколькими меню, то можно заметить следующий баг. Клик по любому из пунктов в одном меню приводит к снятию активности с другого меню. Происходит это из-за этой строчки:

```javascript
// links относится вообще ко всем ссылкам всех меню на странице
links.forEach((link) => link.classList.remove("active"));
```

Для решения этой задачи, нужно обновлять только те ссылки, которые относятся к текущему меню, но как узнать какие относятся, а какие нет? Для этого нужно выполнить два действия:

1. Сначала найти корневой элемент текущего меню, того, по элементу которого произошел клик.
2. Найти активную ссылку внутри текущего меню и убрать с нее активность.

```javascript
links.forEach((link) => {
  link.addEventListener("click", () => {
    // closest находит ближайшего родителя по нужному селектору
    // Наше меню имеет класс .nav
    const nav = link.closest(".nav");
    // Находим активный элемент внутри меню
    const activeElement = nav.querySelector(".active");
    activeElement.classList.remove("active");
    link.classList.add("active");
  });
});
```

## Формы—JS: DOM API

В современных фронтенд приложениях существует два подхода при работе с формами. В некоторых изменение данных на странице происходит сразу по мере изменения формы. У такой формы нет кнопки "сохранить" или "отправить". Здесь каждый элемент формы связан с обработчиком, который отслеживает любые изменения. Типичный пример – фильтрация данных на странице.

В более классическом варианте отправка формы происходит по кнопке. В таком случае нужно использовать событие _submit_ самой формы.

```javascript
const form = document.querySelector(/* селектор формы */);
form.addEventListener("submit", (e) => {
  // Если хотим работать с формой через javascript, то нужно остановить отправку (действие по умолчанию)
  e.preventDefault();
  // что-то делаем
});
```

_Почему не повесить событие `click` на кнопку отправки формы? Технически так сделать можно, но тогда сломается стандартное поведение. Браузеры позволяют отправлять формы с клавиатуры, нажав клавишу Enter. В таком случае кнопка не нажимается, а форма отправляется._

Сама обработка формы строится обычно так (упрощенно):

- Извлекаются данные формы
- Выполняется запрос на сервер / Меняются данные в приложении
- Изменяется внешний вид

Второй и третий пункт мы рассмотрим в следующих уроках, когда поговорим про AJAX, а здесь поговорим о первом. О том как получить данные формы.

Существует два подхода: правильный и неправильный. Сначала неправильный:

```javascript
const input = document.querySelector(/* селектор поля ввода */);
form.addEventListener("submit", (e) => {
  e.preventDefault();
  const { value } = input;
  // Что-то делаем с данными
});
```

При таком подходе придется работать с каждым элементом формы индивидуально. Сначала извлечь их из DOM, затем собрать значения. Делать так не нужно, потому что есть правильный способ.

Правильный способ – использовать специальный объект [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData), доступный в браузере:

```javascript
<form method="post">
  <input name="email" value="example@example.com">
  <input name="password" value="supersecret">
  <input type="submit" value="Sign Up">
</form>
const form = document.querySelector(/* селектор нужной формы */);
form.addEventListener('submit', (e) => {
  e.preventDefault();
  // Данные формы извлекаются из DOM автоматически
  // На вход передается элемент формы взятый из события
  const formData = new FormData(e.target);
  // Теперь с ними можно работать
  formData.get('email'); // example@example.com
  // values() возвращает итератор, поэтому преобразуем в массив
  [...formData.values()]; // ['example@example.com', 'supersecret']
  // Тоже итератор
  [...formData.entries()];
  // [['email', 'example@example.com'], ['password', 'supersecret']]

  // Преобразование в обычный объект
  Object.fromEntries(formData);
  // { email: 'example@example.com', password: 'supersecret' }
});
```

### Извлечение элементов формы

Иногда, все же, приходится обращаться к элементам формы напрямую. Например при реализации валидации во время изменения формы, а не её отправки. В таких случаях, работа с элементами формы идет напрямую:

```javascript
const input = document.querySelector(/* селектор до поля ввода */);
input.addEventListener("change", (e) => {
  // Логика
});
```

Если элементов много, то код, выполняющий запросы в DOM, станет громоздким. Этого можно избежать, если использовать возможности DOM, относящиеся к формам. Каждая форма содержит свойство `elements`, которое возвращает объект cо всеми элементами данной формы. Ключи объекта – имена элементов, значения – сами элементы.

```javascript
<form method="post">
  <input name="email" value="example@example.com">
  <input name="password" value="supersecret">
  <input type="submit" value="Sign Up">
</form>
const form = document.querySelector(/* селектор до формы */);
form.elements.email // <input name="email" ...
form.elements.password // <input name="password" ...

// Обработка
form.elements.email.addEventListener('change', () => {
  // Обработка
});
```

## Перехват и всплытие—JS: DOM API

Предположим, что у нас есть два вложенных элемента, на каждом из которых висит обработчик события _click_. Если выполнить щелчок по области внешнего элемента, не затрагивающей внутренний, то выполнится обработчик, привязанный к этому внешнему элементу. Если выполнить щелчок по внутреннему элементу, автоматически выполнится щелчок и по внешнему, а значит, отработают оба события.

```javascript
<div>
  <button>Send</button>
</div>;
button.addEventListener("click", () => alert("Boom 1!"));
div.addEventListener("click", () => alert("Boom 2!"));
```

Возникает закономерный вопрос, в каком порядке выполнятся эти события после щелчка на кнопку? В общем случае событие проходит сквозь дерево, начиная от корня до самого глубокого элемента, на котором событие сработало, и затем в обратном направлении. Путешествие события туда и обратно называется его стадиями или фазами, ниже о них подробнее.

### Погружение (Capturing)

Когда событие только возникло, оно начинает двигаться по DOM-дереву, начиная от корневого узла, до самого глубокого, на котором произошло событие.

```
               | |
---------------| |---------------
| div          | |              |
|   -----------| |-----------   |
|   | button   \ /          |   |
|   -------------------------   |
|        Event CAPTURING        |
---------------------------------
```

Попутно на стадии погружения будут выполнены обработчики, которые были привязаны к этой стадии. Привязка регулируется третьим параметром функции `addEventListener`.

```javascript
button.addEventListener("click", () => alert("Boom 1!"), true);
div.addEventListener("click", () => alert("Boom 2!"), true);
```

Значение `true` привязывает обработчики к стадии погружения. Получится такой вывод:

```
Boom 2!
Boom 1!
```

### Всплытие (Bubbling)

После остановки погружения на _target_ элементе, начинается всплытие.

```
               / \
---------------| |---------------
| div          | |              |
|   -----------| |-----------   |
|   | button   | |          |   |
|   -------------------------   |
|        Event BUBBLING         |
---------------------------------
```

Именно эта стадия подразумевается при вызове `addEventListener` без указания третьего параметра.

```javascript
button.addEventListener("click", () => alert("Boom 1!"));
div.addEventListener("click", () => alert("Boom 2!"));
```

На ней выполнение обработчиков происходит изнутри наружу:

```
Boom 1!
Boom 2!
```

### Зачем?

Всплытие событий - важная часть поведения DOM. Без него было бы невозможно реализовать события, которые срабатывают на целых блоках, а не только самых глубоких элементах. Самый простой пример - контекстное меню. Другой пример - таблицы, устроенные по принципу Exel (Microsoft Office). Эти таблицы огромны и добавление событий на каждую ячейку привело бы к созданию большого числа одинаковых обработчиков, которые нужно постоянно добавлять с ростом таблицы. Кроме дополнительного кода, такая схема еще и тормозит на больших объемах. Гораздо проще, повесить один обработчик на всю таблицу.

### W3C Модель

Согласно стандарту, большинство событий проходят обе стадии, сначала погружаясь в глубину дерева и затем поднимаясь до самого верха. Стадия погружения используется редко, большая часть обработчиков вешается на стадию всплытия.

В предыдущем уроке мы познакомились с объектом `e.target`. Это самый глубокий элемент, до которого идет погружение. Target не меняется в процессе всплытия. Благодаря ему всегда можно узнать, где конкретно произошло событие. Кроме него, доступен объект `currentTarget` - это элемент, к которому прикреплен данный обработчик. В зависимости от ситуации используется тот или иной.

![Event Stages](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjNjODQyMGIzMmY0YTI5N2U5YzNkOGE0OWEyNWVkYTM1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=91c4f8eccf5a34fcedb4053adff22e9619b959376c4bafa2accd8c2b7f19fb9b)

В обычной ситуации событие должно всплывать до конца, но иногда могут возникать ситуации, когда всплытие нежелательно.

Сделать это можно двумя способами:

- `event.stopPropagation()` - останавливает всплытие, но дает возможность доработать всем обработчикам, которые висят на текущем элементе,
- `event.stopImmediatePropagation()` - не дает выполниться больше ни одному обработчику

## События документа—JS: DOM API

Кроме событий, которые возникают в ответ на действия пользователей, существует ряд событий, которые живут своей жизнью. К таким событиям относятся события на загрузку и выгрузку страницы:

- _DOMContentLoaded_ – DOM-дерево построено
- _load_ – все ресурсы загружены (картинки, стили, скрипты, ...)
- _beforeunload_ – уйти со страницы

_DOMContentLoaded_ возникает в тот момент, когда DOM дерево полностью построено и готово к работе, но при этом стили, скрипты и картинки могут находиться в процессе загрузки.

Это событие привязано к `document`:

```javascript
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const coll = document.querySelectorAll('.help');
    coll.forEach((el) => el.classList.add('hidden'));
  });
</script>
```

Скорость построения DOM дерева очень зависима от тегов `<script>`. По стандарту, любой `<script>`, встреченный в HTML, будет выполняться до полного построения дерева. Следовательно, скорость отработки кода в этом блоке `<script>` будет сильно влиять на то, когда пользователь увидит сам сайт, и на то, когда сработает событие _DOMContentLoaded_.

Поскольку DOM полностью готов только тогда, когда срабатывает событие _DOMContentLoaded_, многие механизмы активизируются именно на нем, например, браузерная подстановка значений в поля форм. По этой же причине, большинство сайтов инициализируют интерфейсы также на этом событии.

Тема оптимизации загрузки скриптов и быстрой инициализации достаточно сложна. Это связано не только с большим количеством факторов влияющих на порядок и скорость, но также и с тем, что в разных браузерах этот механизм работает по-разному. Здесь мы не будем его разбирать, это тема продвинутого уровня, и по ней написано множество статей.

![Network](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQ5YTg2N2JmNTdkNDI1OTc4ZWQ3MGVkMmY2ZjAwNDVkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e7dcc8f3088a4feaee33a6ea85678ec0e0ef7dff78b91cb8858c4738f7541a4c)

Обратите внимание на красную и синюю полоску. Красная показывает момент, когда сработало событие _load_, а синяя - _DOMContentLoaded_. Внизу картинки указано время срабатывания каждого события, от начала загрузки страницы. Из картинки видно, что браузер сначала скачивает саму страницу (ее html), затем извлекает из нее ссылки на все внешние ресурсы и начинает их загрузку. Для большей эффективности, скачивание ресурсов идет параллельно настолько, насколько это возможно.

## AJAX—JS: DOM API

_Для понимания материала этого урока, необходимо иметь представление о [HTTP](https://ru.hexlet.io/courses/http_protocol) и [HTTP API](https://guides.hexlet.io/http-api/)_

Манипуляции с DOM деревом помогают сделать наши сайты более живыми, но их всё же недостаточно для создания автономных виджетов или полноценных (имеющих бекенд) [Single Page Application](https://ru.wikipedia.org/wiki/Одностраничное_приложение) (SPA).

Рассмотрим конкретный пример. Многие сервисы дают возможность использовать разные виджеты, например, погода или курсы валют. Работает это так: вы вставляете в свой html код, предоставленный сервисом. Далее этот код подгружает сам виджет и периодически обращается за необходимыми данными на сервера сервиса. Это может происходить в тот момент, когда пользователь виджета нажимает кнопки, требующие новых данных: например, показать погоду на следующую неделю.

Подобный виджет используется и на Хекслете: вы можете видеть его в правом нижнем углу на каждой странице. В нем есть поиск по нашей справке и форма для отправки письма в поддержку. Виджет работает с помощью специального сервиса и никак не взаимодействует с бекендом Хекслета.

Ключевая технология в этой истории — механизм для выполнения http-запросов прямо из браузера. Именно его называют AJAX, что расшифровывается как "Asynchronous JavaScript and XML". Несмотря на название, эта технология работает не только с xml.

### XMLHttpRequest

До появления html5, браузеры предоставляли (и сейчас предоставляют) специальный объект `XMLHttpRequest`:

```javascript
// пример типового запроса с использованием XMLHttpRequest
// просто для ознакомления

const request = new XMLHttpRequest();
request.onreadystatechange = () => {
  if (request.readyState == 4 && request.status == 200) {
    document.getElementById("demo").innerHTML = request.responseText;
  }
};
request.open("GET", "/api/v1/articles/152.json", true);
request.setRequestHeader("X-Requested-With", "XMLHttpRequest");
request.send();
```

Работать с ним крайне неудобно и, по сути, все использовали обертку, созданную в рамках библиотеки JQuery. Подробнее об этом будет в уроке, посвященном JQuery.

### Fetch

С появлением стандарта HTML5, появился новый механизм для http-запросов:

```javascript
// пример типового запроса с использованием fetch
// const promise = fetch(url[, options]);
fetch("/api/v1/articles/152.json")
  .then((response) => {
    console.log(response.status); // => 200
    console.log(response.headers.get("Content-Type"));
    return response.json();
  })
  .then((article) => {
    console.log(article.title); // => 'Как использовать fetch?'
  })
  .catch(console.error);
```

Как видно, `fetch` — это функция, возвращающая промис, а значит работать с ней удобно и приятно. А благодаря наличию [полифиллов](https://github.com/github/fetch), можно не переживать, что какой-то браузер не поддерживает этот механизм.

Обратите внимание на то, что `response.json` тоже возвращает промис. Кроме `json` данные можно получать, используя функции `blob`, `text`, `formData` и `arrayBuffer`.

Отправка формы POST запросом:

```javascript
const form = document.querySelector("form");

fetch("/users", {
  method: "POST",
  body: new FormData(form),
});
```

Отправка формы как json:

```javascript
fetch("/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "Hubot",
    login: "hubot",
  }),
});
```

При всех своих преимуществах `fetch` довольно низкоуровневый механизм. Например, работая с json (очень частый вариант), придется самостоятельно выставлять заголовки и делать разные манипуляции с данными, которые можно было бы автоматизировать.

На практике, это привело к созданию различных библиотек, которые работают схожим образом, но дают гораздо больше возможностей. Причем многие из этих библиотек изоморфные, то есть работают одинаково и в браузере, и на сервере. Одна из самых популярных библиотек на момент создания курса - [axios](https://github.com/mzabriskie/axios).

### URL

Как мы знаем из предыдущих курсов, клеить строчки для работы с путями или урлами это плохая идея. Можно легко ошибиться и, в целом, приходится выполнять работу, которую может выполнять машина. С одной стороны, можно всегда воспользоваться сторонними библиотеками, которых достаточно много, но с другой, в браузерах уже есть встроенный для этого механизм (для старых браузеров обычно добавляется полифиллами).

```javascript
const url = new URL("../cats", "http://www.example.com/dogs");
console.log(url.hostname); // => www.example.com
console.log(url.pathname); // => /cats

url.hash = "tabby";
console.log(url.href); // => http://www.example.com/cats#tabby

url.pathname = "démonstration.html";
console.log(url.href); // => http://www.example.com/d%C3%A9monstration.html
```

Что особенно приятно, `fetch` умеет работать с объектом `URL` напрямую:

```javascript
const response = await fetch(
  new URL("http://www.example.com/démonstration.html")
);
```

А вот как можно работать с query-параметрами:

```javascript
// https://some.site/?id=123
const parsedUrl = new URL(window.location.href);
console.log(parsedUrl.searchParams.get("id")); // => 123
parsedUrl.searchParams.append("key", "value");
console.log(parsedUrl); // => https://some.site/?id=123&key=value
```

### HTTP access control (CORS)

В отличие от бекенда, http запросы на клиенте могут использоваться злоумышленниками для кражи данных. Поэтому браузеры контролируют то, куда и как делаются запросы.

Подробно об этом механизме можно прочитать [тут](https://habr.com/ru/company/ruvds/blog/421347/)

---

##### Дополнительные материалы

1. [Что такое API](https://guides.hexlet.io/http-api/)

## JQuery—JS: DOM API

В августе 2006 года Джон Резиг выпустил библиотеку **JQuery**. За короткое время эта библиотека завоевала огромную популярность и стала стандартом де-факто при разработке интерактивных элементов на сайтах.

```javascript
// Знак $ — это функция JQuery, через которую все и делается
$(() => {
  // Эта функция выполнится на событии DOMContentLoaded
});
```

Во многом это случилось потому, что JQuery появилась в нужное время в нужном месте. В те года шел переход к верстке без использования таблиц, и css использовался все активнее и разнообразнее. JQuery позволил переиспользовать те же самые селекторы для добавления поведения.

К тому же в JQuery был реализован CSS3 гораздо раньше, чем он появился нативно в самих браузерах. Более того, JQuery в принципе позволила практически не думать о разных браузерах, так как её задачей было, в том числе, обеспечить работоспособность на всех платформах.

```
// Работает так же, как и document.querySelectorAll
// document.querySelectorAll('.section span')
// Возвращает специальную JQuery коллекцию со своим набором методов
const spans = $('.section span');
```

Ещё одной причиной успеха стало то, что JQuery популяризовал отделение верстки от поведения. Такую технику называют "ненавязчивый javascript". Её идея в том, что обработчики событий описываются не в самих тегах, а отдельно:

```javascript
const buttons = $("button");
// Вешает обработчик click на все кнопки в этой коллекции
buttons.click(() => {
  alert("hey!");
});
```

Вместо:

```javascript
<button onclick="alert('hey!')">
```

Сам JQuery при этом является прекрасным примером DSL (предметно-ориентированный язык). Как правило, код на JQuery выражает задачу в тех же терминах, в которых эта задача формулируется:

```javascript
// Прячем все элементы по селектору container.main
$("container.main").hide();

// Удаляем элемент с id=address
$("#address").remove();
```

И это еще не всё. JQuery долгое время предоставляла единственный нормальный способ делать AJAX запросы и анимацию на страницах. А благодаря расширяемости за счёт плагинов, экосистема библиотеки за десяток лет стала фантастических размеров. В какой-то период времени любая библиотека для фронтенда появлялась как плагин к JQuery. Вплоть до того, что некоторые люди вообще не догадываются о существовании javascript и DOM. Они сразу начали с JQuery и видят мир только сквозь него.

### Манипуляции

Функция `$` — это единая точка входа для всего. Если её вызвать и передать внутрь строчку, то JQuery считает, что строка — это селектор, и нужно сделать выборку элементов DOM. Этот вызов аналогичен вызову `querySelectorAll()`, с тем лишь отличием, что возвращается специализированная коллекция.

JQuery, в принципе, работает с элементами как с коллекциями, даже если это один элемент. И любые изменения применяются сразу ко всем элементам коллекции без необходимости итерирования.

```javascript
// Выбираются все элементы h1
const headings = $("h1");
// Добавления класса всем заголовкам h1
headings.addClass("header");

// Тоже самое без jquery
const headings = document.querySelectorAll("h1");
headings.forEach((el) => el.classList.add("header"));
```

Ниже приведено несколько примеров функций, изменяющих DOM элемент и его потомков. Главная особенность JQuery здесь в том, что если вызвать эти функции без параметров, то они возвращают значение, если вызвать с параметрами, то изменяют.

```javascript
// Если был найден один заголовок
const link = $("#home");
link.html("link to home"); // установка textContent
link.attr("href", "/about"); // установка атрибута
// Чтение атрибута
console.log(link.attr("href")); // => /about
```

### События

JQuery предоставляет собственные методы для подписки на события, выступая абстракцией над `addEventListener`. Например, так будет обрабатываться клик по кнопке:

```javascript
$("button").click(() => {
  // Установка атрибута href на элемент с идентификатором w3c
  // attr может принимать вторым параметром функцию. В нее передается оригинальное значение атрибута
  $("#w3c").attr("href", (i, origValue) => `${origValue}/jquery`);
});
```

### AJAX

JQuery умеет выполнять и Ajax запросы. Правда научился он это делать до появления стандартов, поэтому интерфейс работы этого механизма отличается от стандартных промисов.

```javascript
// Цепочка вызовов работает по такому же принципу как и промисы,
// хотя и отличается в деталях
const jqxhr = $.get("/api/v1/companies.json", (data) => {
  console.log("success");
})
  .done(() => {
    console.log("success");
  })
  .fail(() => {
    console.log("fail");
  })
  .always(() => {
    console.log("finished");
  });
```

### Анимация

JQuery, с одной стороны, даёт набор готовых анимаций, с другой — представляет механизм для создания более сложных эффектов, основанных на изменении CSS-свойств.

```html
<!-- Плавное появление элемента по клику -->
<div id="clickme">Click here</div>
<img id="book" src="book.png" alt="" width="100" height="123" />
<script>
  // Элемент #book загружается, как скрытый, а по клику медленно появляется
  $("#clickme").click(() => {
    $("#book").show("slow", () => {
      // Действия после завершения анимации
    });
  });
</script>
```

Для JQuery реализована группа плагинов [JQuery UI](https://jqueryui.com/), которая реализует типичную функциональность, необходимую при разработке интерактивных сайтов, например, перетаскивание, автокомплит, изменение размеров, сортировка и многое другое.

![JQuery UI](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjZjYzUwZDllY2JjNWNiNWJjYjBiNjQ3Zjg1MDI0OGFmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e11c2f5689322957cb36a00c771908aa9ba1eac1e9e821ddaffa2de05285fb72)

### Перспективы

В своё время JQuery была прекрасным выбором, но это время уходит. С момента выхода библиотеки, веб ушел вперёд. Стандарт DOM развился настолько, что многие вещи делать напрямую удобнее, чем через JQuery, а поддержка самого стандарта браузерами достаточно высока. В тех местах, где поддержки не хватает, всегда есть полифиллы. К тому же появились новые стандарты, в которые JQuery не вписывается. Ярким примером служат промисы и тот же AJAX.

Всё это приводит к тому, что постепенно происходит отказ от JQuery. Для любых задач на фронтенде можно найти множество популярных библиотек, которые в своей нише будут лучше, чем то, что предлагает JQuery.

С другой стороны, на JQuery уже столько понаписано, что его требуют знать в любой вакансии, связанной со фронтендом. Как вы могли убедиться из примеров выше, ничего сложного и фантастического в JQuery нет. Более того, в первую очередь надо знать DOM, а остальное — это просто внимательное чтение документации и примеров использования.

## Самостоятельная работа

### Курс «[JS: DOM API](https://ru.hexlet.io/courses/js-dom)»

Урок «[JavaScript в браузере](https://ru.hexlet.io/courses/js-dom/lessons/js/theory_unit)»

1. Откройте консоль в своем браузере.
2. Попробуйте позапускать в ней код на выполнение, например обычные арифметические операции

Урок «[Глобальный объект Window](https://ru.hexlet.io/courses/js-dom/lessons/window/theory_unit)»

1. Откройте консоль в своем браузере.

2. Изучите объект `window`.

3. Попробуйте выполнить открытие новой вкладки:

   ```javascript
   window.open();
   ```

Урок «[Что такое DOM?](https://ru.hexlet.io/courses/js-dom/lessons/dom/theory_unit)»

1. Откройте консоль в своем браузере.

2. Используйте объект `document` для замены тела документа (как в примере выше) на следующий фрагмент:

   ```html
   <h1>This is my territory</h1>
   ```

Урок «[Навигация по DOM-дереву](https://ru.hexlet.io/courses/js-dom/lessons/dom-hierarchy/theory_unit)»

1. Откройте консоль в своем браузере.
2. Начиная от `document.body` доберитесь до самых глубоких узлов, содержащих этот текст.

## Дополнительные материалы

### [JS: DOM API](https://ru.hexlet.io/courses/js-dom)

1. [Введение](https://ru.hexlet.io/courses/js-dom/lessons/intro/theory_unit)
   - Без материалов
2. [JavaScript в браузере](https://ru.hexlet.io/courses/js-dom/lessons/js/theory_unit)
   - [Гайд "Зачем нужно собирать фронтенд"](https://guides.hexlet.io/webpack/)
   - [Урок по DevTools](https://ru.hexlet.io/courses/html/lessons/devtools/theory_unit)
   - [Курс "Протокол HTTP"](https://ru.hexlet.io/courses/http_protocol)
3. [Глобальный объект Window](https://ru.hexlet.io/courses/js-dom/lessons/window/theory_unit)
   - [Window](https://developer.mozilla.org/ru/docs/Web/API/Window)
4. [BOM объекты](https://ru.hexlet.io/courses/js-dom/lessons/bom/theory_unit)
   - Без материалов
5. [Что такое DOM?](https://ru.hexlet.io/courses/js-dom/lessons/dom/theory_unit)
   - Без материалов
6. [Навигация по DOM-дереву](https://ru.hexlet.io/courses/js-dom/lessons/dom-hierarchy/theory_unit)
   - [Node](https://developer.mozilla.org/ru/docs/Web/API/Node)
7. [Декларативный поиск по DOM-дереву](https://ru.hexlet.io/courses/js-dom/lessons/search/theory_unit)
   - Без материалов
8. [Консоль разработчика](https://ru.hexlet.io/courses/js-dom/lessons/devtools/theory_unit)
   - [Отладка кода в браузере (видео)](https://www.youtube.com/watch?v=hNIvcEcj-XA&feature=youtu.be)
   - [Chrome DevTools](https://ru.hexlet.io/courses/html/lessons/devtools/theory_unit)
9. [Манипулирование DOM деревом](https://ru.hexlet.io/courses/js-dom/lessons/tree-manipulating/theory_unit)
   - Без материалов
10. [Управление узлами DOM](https://ru.hexlet.io/courses/js-dom/lessons/element-manipulating/theory_unit)
    - Без материалов
11. [Полифиллы](https://ru.hexlet.io/courses/js-dom/lessons/polyfills/theory_unit)
    - Без материалов
12. [Введение в события](https://ru.hexlet.io/courses/js-dom/lessons/events/theory_unit)
    - Без материалов
13. [События на практике](https://ru.hexlet.io/courses/js-dom/lessons/events-in-action/theory_unit)
    - Без материалов
14. [Формы](https://ru.hexlet.io/courses/js-dom/lessons/forms/theory_unit)
    - Без материалов
15. [Перехват и всплытие](https://ru.hexlet.io/courses/js-dom/lessons/event-stages/theory_unit)
    - Без материалов
16. [События документа](https://ru.hexlet.io/courses/js-dom/lessons/document-events/theory_unit)
    - Без материалов
17. [AJAX](https://ru.hexlet.io/courses/js-dom/lessons/ajax/theory_unit)
    - [Что такое API](https://guides.hexlet.io/http-api/)
18. [JQuery](https://ru.hexlet.io/courses/js-dom/lessons/jquery/theory_unit)
    - Без материалов
    -
