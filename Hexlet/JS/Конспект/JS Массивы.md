## О курсе—JS: Массивы

Программирование становится по-настоящему интересным, когда появляется возможность работать с наборами (коллекциями) элементов. Вот лишь некоторые примеры того, где они встречаются:

- Постраничный вывод данных на сайте
- Подсчёт общей суммы в заказе на основании каждой из позиций
- Вывод списка друзей, сообщений, фильмов и тому подобное
- Обработка набора DOM-узлов (HTML, фронтенд разработка)

Любые списки, которые окружают нас в реальном или виртуальном мире, являются коллекциями элементов с точки зрения программирования. В JavaScript для их хранения используется _массив_ – структура данных, позволяющая работать с набором как с единым целым.

```javascript
// Определение массива друзей
const friends = ["petya", "vasya", "ivan"];
```

В отличие от примитивных типов данных, массивы в JavaScript могут изменяться. Причем как по содержимому так и по размеру самого массива. Это сильно влияет на работу с ними и добавляет с одной стороны больше возможностей, а с другой – ответственности. Используя массивы, одну и ту же задачу можно решить множеством разных способов. Только некоторые из них будут хорошими, остальные же, не эффективными, сложными в отладке и анализе.

Именно поэтому массивам посвящено не несколько уроков, а целый и довольно большой курс. В этом курсе рассматривается множество ситуаций, которые традиционно решаются с помощью массивов. Знания, полученные в этом курсе, станут тем фундаментом, на котором основана вся дальнейшая разработка. Основные темы этого курса:

- Манипуляции с массивами
- Обработка массивов в циклах
- Работа с вложенными массивами используя вложенные циклы
- Сортировка массивов
- Работа со строками через массивы

Помимо массивов, мы коснемся темы алгоритмов и структур данных. Вы познакомитесь с понятием алгоритмической сложности, узнаете, как реализовывать некоторые типичные алгоритмы, которые часто спрашивают на собеседованиях. Знание этих тем, хотя бы на базовом уровне, критично для написания эффективного кода.

## Синтаксис—JS: Массивы

Массивом в программировании представляют любые упорядоченные наборы (или коллекции) элементов, будь то курсы на Хекслете, студенты в группе или друзья в вашей любимой социальной сети. Задача массива — представить такие коллекции в виде единой структуры, которая позволяет работать с ними как с единым целым.

### Определение массива

```javascript
// Создание пустого массива
const items = [];

// Создание массива с тремя элементами
const animals = ["cats", "dogs", "birds"];
```

В примере происходит определение массива `['cats', 'dogs', 'birds']`, который затем присваивается константе `animals`.

Обратите внимание на именование констант, содержащих массивы. Они во множественном числе. Это подчеркивает природу константы и делает код проще для анализа.

### Получение данных

Элементы в массиве упорядочены слева направо. Каждый элемент имеет порядковый номер, называемый **индексом**. Индексация массива начинается с нуля. То есть первый элемент массива доступен по индексу `0`, второй — по индексу `1` и так далее. Для извлечения элемента из массива по индексу используется особый синтаксис:

```javascript
const animals = ["cats", "dogs", "birds"];
animals[0]; // 'cats'
animals[1]; // 'dogs'
// Последний индекс в массиве всегда меньше размера массива на единицу.
// В этом массиве три элемента, но последний индекс равен двум
animals[2]; // 'birds'
```

Узнать размер массива можно, обратившись к его свойству `length`.

```javascript
const animals = ["cats", "dogs", "birds"];
// У массивов много других свойств и методов, с которыми мы познакомимся в процессе прохождения курсов.
animals.length; // 3
```

В реальных задачах индекс часто вычисляется динамически, поэтому обращение к конкретному элементу происходит с использованием переменных:

```javascript
let i = 1;
const animals = ["cats", "dogs", "birds"];
animals[i]; // 'dogs'
```

И даже так:

```javascript
let i = 1;
let j = 1;
const animals = ["cats", "dogs", "birds"];
animals[i + j]; // 'birds'
```

Такой вызов возможен по одной простой причине — внутри скобок ожидается _выражение_. А там, где ожидается выражение, можно подставлять всё, что вычисляется. В том числе вызовы функций:

```javascript
const getIndexOfSecondElement = () => 1;
const animals = ["cats", "dogs", "birds"];
animals[getIndexOfSecondElement()]; // 'dogs'
```

Довольно часто, в задачах с использованием массивов, нужно взять последний элемент. Для этого вычисляется последний индекс массива по формуле *размер*массива - 1\_, по которому и можно обратиться к последнему элементу:

```javascript
const animals = ["cats", "dogs", "birds"];
animals[animals.length - 1]; // 'birds'
```

### at()

Другой способ работать с индексами - метод `at()`. Его добавили для возможности указывать отрицательные индексы, это позволяет брать элементы с конца без вычисления индексов, как в примере выше:

```javascript
const animals = ["cats", "dogs", "birds"];
animals.at(0); // 'cats'
animals.at(1); // 'dogs'
// Первый с конца
animals.at(-1); // 'birds'
// Второй с конца
animals.at(-2); // 'dogs'
```

---

##### Дополнительные материалы

1. [Документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

## Модификация—JS: Массивы

Примитивные типы данных, с которыми мы работали до сих пор, невозможно изменить. Любые функции и методы над ними возвращают новые значения, но не могут ничего сделать со старым.

```javascript
const name = "Hexlet";
name.toUpperCase(); // 'HEXLET'
// Значение name не поменялось
console.log(name); // 'Hexlet'
```

С массивами это правило не работает. Массивы могут меняться: увеличиваться, уменьшаться, изменять значения по индексам. Ниже мы разберем все эти операции.

### Изменение элементов массива

Синтаксис изменения элемента массива практически такой же, как и при обращении к элементу массива. Разница лишь в наличии присваивания:

```javascript
const animals = ["cats", "dogs", "birds"];
// Меняется первый элемент массива
animals[0] = "horses";
console.log(animals); // => ['horses', 'dogs', 'birds']
```

Самое неожиданное в данном коде – изменение константы. Константы в JavaScript не совсем то, как мы себе это представляли раньше. Константы хранят ссылку на данные (подробнее об этом в следующих уроках), а не сами данные. Это значит что менять данные можно, но нельзя заменить ссылку. Технически это значит, что мы не можем заменить все значение константы целиком:

```javascript
const animals = ["cats", "dogs", "birds"];
// Меняем данные, а сам массив остался тем же
// Такой код работает
animals[2] = "fish";
console.log(animals); // => ['cats', 'dogs', 'fish']

// Произойдет ошибка, так как здесь идет замена константы
animals = ["fish", "cats"];
// Uncaught TypeError: Assignment to constant variable.
```

### Добавление элемента в массив

Метод `push()` добавляет элемент в _конец_ массива:

```javascript
const animals = ["cats", "dogs", "birds"];
animals.push("horses");

// массив animals изменён — стал больше
console.log(animals); // => ['cats', 'dogs', 'birds', 'horses']

// строка 'horses' была добавлена в конец массива (индекс = 3)
console.log(animals[3]); // => 'horses'
```

Метод `unshift()` добавляет элемент в _начало_ массива:

```javascript
const animals = ["cats", "dogs", "birds"];
animals.unshift("horses");

// массив animals изменён — стал больше
console.log(animals); // => ['horses', 'cats', 'dogs', 'birds']

// строка 'horses' была добавлена в начало массива (индекс = 0)
console.log(animals[0]); // => 'horses'
```

Иногда индекс добавления известен сразу и в таком случае добавление работает так же как и изменение:

```javascript
const animals = ["cats", "dogs", "birds"];
animals[3] = "horses";
console.log(animals); // => ['cats', 'dogs', 'birds', 'horses']
```

### Удаление элемента из массива

Удалить элемент из массива можно с помощью специальной конструкции [delete](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/delete): `delete arr[index]`.

Пример:

```javascript
const animals = ["cats", "dogs", "birds"];
delete animals[1]; // удаляем элемент под индексом 1
console.log(animals); // => ['cats', <1 empty item>, 'birds']
```

Этот способ обладает рядом недостатков, завязанных на особенности внутренней организации языка JavaScript. Например, после такого удаления, можно с удивлением заметить, что размер массива не изменился:

```javascript
animals.length; // 3
```

Есть и другие особенности и последствия использования этого оператора, в которые сейчас не будем углубляться. Здесь мы его привели лишь для примера и не рекомендуем использовать при написании кода. В общем случае уменьшение размера массива — нежелательная операция. Подробнее об этом поговорим в одном из следующих уроков.

## Проверка существования значения—JS: Массивы

При работе с массивами, часто допускается ситуация, называемая "выход за границу массива". Она возникает при обращении к несуществующему индексу:

```javascript
const animals = ["cats", "dogs", "birds"];
// Элемента с индексом 5 не существует
animals[5]; // undefined
```

В разных языках программирования поведение в случае выхода за границу реализовано совершенно по-разному. Иногда возникает ошибка, иногда нет, а иногда подобный выход возвращает случайные данные из соседнего блока памяти, как в Си, что может привести к катастрофе.

В JavaScript свой путь. Здесь дана бОльшая свобода, допускающая почти любые вольности. Обращение по несуществующему индексу возвращает значение `undefined`. При этом никаких ошибок не возникает, это рассматривается как нормальная ситуация:

```javascript
const animals = ["cats", "dogs", "birds"];

// Выход за границы массива
animals[5]; // undefined
animals[4]; // undefined
animals[3]; // undefined

// Ура, мы попали в границы массива :)
animals[2]; // 'birds'
```

В подавляющем большинстве ситуаций, выход за границу массива является нежелательным поведением. Он происходит из-за логических ошибок в программе. Программа, при этом, продолжает работать и, даже, иногда выдавать правильный результат. Самый простой способ проверить выход за границу, это убедиться в том что индекс не превышает длину массива:

```javascript
// Важно что <, а не <=.
// потому что такого индекса нет items[items.length]
if (index < items.length) {
  items[index]; // все отлично!
}
```

Со временем вы научитесь видеть такие ситуации и достаточно быстро исправлять их. Но даже опытные программисты регулярно ошибаются при обращении с массивами.

## Цикл for—JS: Массивы

Работа с массивами почти всегда завязана на одновременную обработку всех его элементов. Это нужно при выводе списков на экран, при выполнении различных расчетов или проверке данных. Во всех этих случаях нужен механизм для перебора элементов массива. Самый простой способ сделать это – использовать цикл.

### Обход

Циклы напрямую с массивами не связаны, но у циклов есть счетчик, который может выступать в качестве индекса массива. Поэтому соединить их не составляет никакого труда:

```javascript
// Создаем массив
const userNames = ["petya", "vasya", "evgeny"];

// Определяем цикл
// Начальное значение счетчика i = 0 – вычисляется один раз перед началом выполнения
// Условие остановки i < userNames.length – выполняется перед каждой итерацией
// Изменение счетчика i += 1 – выполняется после каждой итерации
for (let i = 0; i < userNames.length; i += 1) {
  // Этот код выполняется для каждого элемента
  console.log(userNames[i]);
}

// => 'petya'
// => 'vasya'
// => 'evgeny'
```

https://repl.it/@hexlet/js-arrays-for-print

В данном коде создаём массив из трёх элементов — имён. Далее в цикле обходим массив и выводим на экран все имена так, что каждое имя оказывается на новой строке (`console.log` автоматически делает перевод строки).

Рассмотрим этот этап подробнее. При обходе массива циклом `for` счётчик, как правило, играет роль индекса в массиве. Он инициализируется нулём и увеличивается до `userNames.length - 1`, что соответствует индексу последнего элемента. Именно поэтому мы используем строгое сравнение `<` (_меньше_) в условном выражении `i < userNames.length`, а не `<=` (_меньше либо равно_).

А что, если нам нужно вывести значения в обратном порядке? Для этого есть два способа. Один — идти в прямом порядке, то есть от нулевого индекса до последнего, и каждый раз вычислять нужный индекс по такой формуле `размер массива - 1 - текущее значение счётчика`.

```javascript
const userNames = ["petya", "vasya", "evgeny"];

for (let i = 0; i < userNames.length; i += 1) {
  const index = userNames.length - 1 - i;
  console.log(userNames[index]);
}
```

Другой способ подразумевает обход в обратном порядке, от верхней границы до нижней, то есть от последнего индекса массива к первому (нулю, так как индексирование начинается с нуля). В такой ситуации код меняется на следующий:

```javascript
const userNames = ["petya", "vasya", "evgeny"];

// Начальное значение i соответствует последнему индексу в массиве
for (let i = userNames.length - 1; i >= 0; i -= 1) {
  console.log(userNames[i]);
}
```

При таком обходе проверка остановки должна быть именно на `>=`, иначе элемент с индексом 0 не попадет в цикл.

### Изменение

Во время обхода массива его можно не только читать, но и модифицировать. Предположим, что перед нами стоит задача нормализации списка электронных адресов — например, приведение их к нижнему регистру. Тогда код будет выглядеть так:

```javascript
const emails = ["VASYA@gmAil.com", "iGoR@yandex.RU", "netiD@hot.CoM"];

console.log(emails);
// => [ 'VASYA@gmAil.com', 'iGoR@yandex.RU', 'netiD@hot.CoM' ]

for (let i = 0; i < emails.length; i += 1) {
  const email = emails[i];

  // toLowerCase() — стандартный метод js,
  // преобразующий строку в нижний регистр
  const normalizedEmail = email.toLowerCase();
  // Заменяем значение
  emails[i] = normalizedEmail;
}

console.log(emails);
// => [ 'vasya@gmail.com', 'igor@yandex.ru', 'netid@hot.com' ]
```

https://repl.it/@hexlet/js-arrays-for-update

Ключевая строчка: `emails[i] = normalizedEmail;`. В ней происходит перезапись элемента под индексом `i`.

### Резюме

Цикл `for` можно комбинировать с массивами в любых вариантах. Массив не обязательно перебирать полностью и от начала до конца. Можно например смотреть только каждый второй элемент или двигаться до половины. Все это зависит от конкретной задачи.

Точно так же массивы сочетаются с `while`. Единственное что нужно массивам – индекс.

---

##### Дополнительные материалы

1. [Официальная документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for)

## Ссылки—JS: Массивы

Переменные (и константы) в JavaScript могут хранить два вида данных: примитивные и ссылочные. К примитивным относятся все примитивные типы: числа, строки, булеан и так далее. К ссылочным – объекты. Объекты, в общем смысле, изучаются только в следующем курсе, но массив внутри – это тоже объект:

```javascript
typeof []; // 'object'
```

В чём разница между ссылочными и примитивными типами данных и почему об этом нужно знать?

С точки зрения прикладного программиста, разница проявляется при изменении данных, их передаче и возврате из функций. Мы уже знаем, что массив можно менять, даже если он записан в константу. Здесь как раз и проявляется ссылочная природа. Константа хранит ссылку на массив, а не сам массив, и эта ссылка не меняется. А вот массив поменяться может. С примитивными типами такой трюк не пройдёт.

Другой способ убедиться в том, что массивы являются ссылками – создать несколько констант, содержащих один массив, и посмотреть, как они меняются:

```javascript
const items = [1, 2];
// Ссылаются на один и тот же массив
const items2 = items;
items2.push(3);

console.log(items2); // => [1, 2, 3]
console.log(items); // => [1, 2, 3]
items2 === items; // true
```

Сравнение массивов тоже происходит по ссылке. Это может быть очень неожиданно с непривычки. Одинаковые по структуре массивы имеют разные ссылки и не равны друг другу:

```javascript
[1, 2, 3] === [1, 2, 3]; // false
```

Более того, если передать массив в какую-то функцию, которая его изменяет, то массив тоже изменится. Ведь в функцию передается именно ссылка на массив. Посмотрите на пример:

```javascript
const f = (coll) => coll.push("wow");

const items = ["one"];
f(items);
console.log(items); // => ['one', 'wow']
f(items);
console.log(items); // => ['one', 'wow', 'wow']
```

### Проектирование функций

Проектируя функции, работающие с массивами, есть два пути: менять исходный массив или формировать внутри новый и возвращать его наружу. Какой лучше? В подавляющем большинстве стоит предпочитать второй. Это безопасно. Функции, возвращающие новые значения, удобнее в работе, а поведение программы становится в целом более предсказуемым, так как отсутствуют неконтролируемые изменения данных.

Изменение массива может повлечь за собой неожиданные эффекты. Представьте себе функцию `last()`, которая извлекает последний элемент из массива. Она могла бы быть написана так:

```javascript
// Метод .pop извлекает последний элемент из массива
// Он изменяет массив, удаляя оттуда этот элемент
const last = (coll) => coll.pop();
```

Где-то в коде, вы просто хотели посмотреть последний элемент. А в дополнение к этому, функция для извлечения этого элемента, взяла и удалила его оттуда. Это поведение очень неожиданно для подобной функции. Оно противоречит большому количеству принципов построения хорошего кода (например cqs, этот принцип рассматривается в курсе по функциям). Правильная реализация данной функции выглядит так:

```javascript
const last = (coll) => coll[coll.length - 1];
```

В каких же случаях стоит менять сам массив? Есть ровно одна причина по которой так делают – производительность. Именно поэтому некоторые встроенные методы массивов меняют их, например `reverse()` или `sort()`:

```javascript
const items = [3, 8, 1];

// Нет присвоения результата, массив изменяется напрямую
items.sort();
console.log(items); // => [1, 3, 8]

items.reverse();
console.log(items); // => [8, 3, 1]
```

https://repl.it/@hexlet/js-arrays-references-sort

Обычно в документации каждой функции отдельно подчёркивают, изменяет ли она исходный массив или возвращает результатом новый массив, не модифицируя исходный. Например, метод [concat()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat), в отличие от `sort()`, возвращает новый массив, о чём написано в документации.

Несмотря на то, что подход, меняющий массивы напрямую, сложнее в отладке, его используют в некоторых языках для увеличения эффективности работы. Если массив достаточно большой, то полное копирование окажется дорогой операцией. В реальной жизни (веб-разработчика) это почти никогда не является проблемой, но знать об этом полезно.

---

##### Дополнительные материалы

1. [Продуманная оптимизация](http://optimization.guide/)

## Агрегация—JS: Массивы

Распространённый вариант использования циклов с массивами — **агрегация**. Агрегацией называются любые вычисления, которые, как правило, строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее. Процесс агрегации не требует знания нового синтаксиса, но влияет на алгоритм решения задач. Поэтому имеет смысл рассмотреть его отдельно. Начнем с поиска максимального.

```javascript
const calculateMax = (coll) => {
  // Если коллекция пустая, то у нее не может быть максимального
  // В подобных ситуациях принято возвращать null
  // Это классический пример использования идиомы guard expression
  if (coll.length === 0) {
    return null;
  }

  // Сравнение элементов нужно начать с какого-то первого элемента
  let max = coll[0]; // Принимаем за максимальное первый элемент
  // Обход начинаем со второго элемента
  for (let i = 1; i < coll.length; i += 1) {
    const currentElement = coll[i];
    // Если текущий элемент больше максимального,
    // то он становится максимальным
    if (currentElement > max) {
      max = currentElement;
    }
  }

  // Не забываем вернуть максимальное число
  return max;
};

console.log(calculateMax([])); // => null
console.log(calculateMax([3, 2, -10, 38, 0])); // => 38
```

https://repl.it/@hexlet/js-arrays-aggregation-max

Почему это пример агрегации? Здесь мы видим _вычисление_, которое включает в себя сравнение всех элементов для поиска одного, которое станет результатом этой операции.

Обратите внимание, что начальным значением `max` взят первый элемент, а не, скажем, число `0`. Ведь может оказаться так, что все числа в массиве меньше `0`, и тогда мы получим неверный ответ.

Теперь рассмотрим поиск суммы:

```javascript
const calculateSum = (coll) => {
  // Начальное значение суммы
  let sum = 0;
  for (let i = 0; i < coll.length; i += 1) {
    // Поочередно складываем все элементы
    sum += coll[i];
  }

  return sum;
};

// Сумма элементов всегда возвращает какое-то число
// Если массив пустой, то сумма его элементов 0
console.log(calculateSum([])); // => 0

console.log(calculateSum([3, 2, -10, 38, 0])); // => 33
// Процесс вычислений
let sum = 0;
sum = sum + 3; // 3
sum = sum + 2; // 5
sum = sum + -10; // -5
sum = sum + 38; // 33
sum = sum + 0; // 33
```

https://repl.it/@hexlet/js-arrays-aggregation-sum

Алгоритм поиска суммы значительно проще, но обладает парой важных нюансов.

Чему равна сумма элементов пустого массива? С точки зрения математики такая сумма равна `0`. Что в принципе совпадает со здравым смыслом. Если у нас нет яблок, значит у нас есть `0` яблок (количество яблок равно нулю). Функции в программировании работают по этой логике.

Второй момент связан с начальным элементом суммы. У переменной `sum` есть начальное значение равное 0. Зачем вообще задавать значение? Любая повторяющаяся операция начинается с какого-то значения. Нельзя просто так объявить переменную и начать с ней работать внутри цикла. Это приведет к неверному результату:

```
// начальное значение не задано
// js автоматически делает его равным undefined
let sum;

// первая итерация цикла
sum = sum + 2; // ?
```

В результате такого вызова, внутри `sum` окажется `NaN`, то есть не-число. Оно возникает из-за попытки сложить `2` и `undefined`. Значит какое-то значение все же нужно. Почему в коде выше выбран 0? Очень легко проверить, что все остальные варианты приведут к неверному результату. Если начальное значение будет равно 1, то результат получится на 1 больше чем нужно.

В математике существует понятие **нейтральный элемент операции** (у каждой операции свой элемент). Это понятие имеет очень простой смысл. Операция с этим элементом не изменяет то значение, над которым проводится операция. В сложении любое число плюс ноль дает само число. При вычитании то же самое. Даже у конкатенации есть нейтральный элемент – это пустая строка: `'' + 'one'` будет `'one'`.

Агрегация далеко не всегда означает, что коллекция элементов сводится к некоторому простому значению. Результатом агрегации может быть сколь угодно сложная структура, например, массив. Подобные примеры часто встречаются в реальной жизни. Самый простой пример – это список уникальных слов в тексте.

## Цикл for...of—JS: Массивы

`for` относится к низкоуровневым циклам. Он требует задания счетчика, правил его изменения и условия остановки. Было бы значительно удобнее обходить элементы коллекции напрямую, без счетчика. Многие языки программирования решают это введением специального вида цикла. В JavaScript тоже есть такой: `for...of`.

```javascript
const userNames = ["petya", "vasya", "evgeny"];

// name на каждой итерации свой собственный (локальный), поэтому используется const
for (const name of userNames) {
  console.log(name);
}
// => "petya"
// => "vasya"
// => "evgeny"
```

https://repl.it/@hexlet/js-arrays-for-of-example

Как видно из примера, код, использующий `for...of`, получается значительно чище, чем с использованием цикла `for`. `for...of` знает о том, как перебирать элементы и знает о том, когда они закончатся.

Этот цикл отлично подходит для задач агрегации:

```javascript
const calculateSum = (coll) => {
  let sum = 0;
  for (const value of coll) {
    sum += value;
  }

  return sum;
};
```

`for...of` — это больше, чем просто цикл для массивов. Для полного понимания принципов его работы, нужно разбираться в темах, которые мы еще не проходили, среди них объекты, упаковка/распаковка и итераторы. Если по-простому, то разные данные в JavaScript могут притворяться коллекциями элементов. Самый простой пример — это строка: `for...of` перебирает строку посимвольно.

```javascript
const greeting = "Hello";
// В этот момент со строкой происходит магия, которая разбирается в курсе ООП
for (const symbol of greeting) {
  console.log(symbol);
}
// => "H"
// => "e"
// => "l"
// => "l"
// => "o"
```

Однако не следует путать строку с массивом. Несмотря на внешнюю схожесть доступа к элементам строки по индексу, строка массивом не является.

### Применимость

В большинстве задач, использующих цикл, предпочтительнее `for...of`. Иногда его бывает недостаточно, и требуется ручное управление обходом. В таких случаях можно возвращаться к использованию `for`. Например, когда нужно идти не по каждому элементу массива, а через один:

```javascript
for (let i = 0; i < items.length; i += 2) {
  // какой-то код
}
```

Иногда нужно обходить массив в обратном порядке. `for...of` здесь бессилен и снова нужен `for`:

```javascript
for (let i = items.length - 1; i >= 0; i -= 1) {
  // какой-то код
}
```

Другие задачи вообще с массивами напрямую не связаны. К последним относятся ситуации, когда нужно перебирать числа в определённом диапазоне. В этом случае нет массива, по которому можно было бы пройтись с помощью `for...of`.

```javascript
for (let i = 5; i < 10; i += 1) {
  // какой-то код
}
```

Ну и наконец, встречаются задачи, в которых нужно во время обхода менять исходный массив:

```javascript
for (let i = 0; i < items.length; i += 1) {
  items[i] = /* что-то делаем */
}
```

_Если заглядывать в будущее и в то, как пишется реальный код на JavaScript, то там появляются функции высшего порядка. То есть на практике циклы, можно сказать, не нужны за редким исключением. Однако, невозможно перепрыгнуть работу с циклами, так как это база. А функции высшего порядка требуют понимания таких тем, которые за один присест не изучаются._

---

##### Дополнительные материалы

1. [Официальная документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...of)

## Управляющие инструкции—JS: Массивы

В циклах JavaScript доступны для использования две инструкции, влияющие на их поведение: `break` и `continue`. Их использование не является необходимым, но все же они встречаются на практике и поэтому про них нужно знать.

### Break

Инструкция `break` производит _выход из цикла_. Не из функции, а из цикла. Встретив её, интерпретатор перестаёт выполнять текущий цикл и переходит к инструкциям, идущим сразу за циклом.

```javascript
const coll = ["one", "two", "three", "four", "stop", "five"];

for (const item of coll) {
  if (item === "stop") {
    break;
  }
  console.log(item);
}
```

То же самое легко получить без `break`, используя цикл `while`. Этот цикл семантически лучше подходит для такой задачи, так как подразумевает неполный перебор:

```javascript
const coll = ["one", "two", "three", "four", "stop", "five"];

let i = 0;
while (coll[i] !== "stop") {
  console.log(coll[i]);
  i += 1;
}
```

### Continue

Инструкция `continue` позволяет пропустить итерацию цикла. Ниже пример с функцией `myCompact()`, которая удаляет `null` элементы из массива:

```javascript
const myCompact = (coll) => {
  const result = [];

  for (const item of coll) {
    if (item === null) {
      continue;
    }

    result.push(item);
  }

  return result;
};
```

Код без `continue` получается проще:

```javascript
const myCompact = (coll) => {
  const result = [];

  for (const item of coll) {
    if (item !== null) {
      result.push(item);
    }
  }

  return result;
};
```

### Резюме

`break` и `continue` призваны добавить гибкости в управление процессом обхода. На практике же, всегда можно построить код без них и, скорее всего, он будет даже проще. По возможности избегайте этих конструкций.

---

##### Дополнительные материалы

1. [Break](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/break)
2. [Continue](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/continue)

## Вложенные массивы—JS: Массивы

Значением массива может быть всё, что угодно, в том числе другой массив. Создать массив в массиве можно так:

```javascript
const arr1 = [[3]];
arr1.length; // 1

const arr2 = [1, [3, 2], [3, [4]]];
arr2.length; // 3
```

https://repl.it/@hexlet/js-arrays-nested-arrays-multidimensional-array

Каждый элемент, являющийся массивом, рассматривается как единое целое. Это видно по размеру второго массива. Синтаксис JavaScript позволяет размещать элементы создаваемого массива построчно, перепишем для наглядности создание второго массива:

```javascript
const arr2 = [
  1, // первый элемент (число)
  [3, 2], // второй элемент (массив)
  [3, [4]], // третий элемент (массив)
];
arr2.length; // 3
```

Вложенность никак не ограничивается. Можно создавать массив массивов массивов и так далее.

Обращение ко вложенным массивам выглядит немного необычно, хотя и логично:

```javascript
const arr1 = [[3]];
arr1[0][0]; // 3

const arr2 = [1, [3, 2], [3, [4]]];
arr2[2][1][0]; // 4
```

https://repl.it/@hexlet/js-arrays-nested-arrays-access

Возможно, с непривычки вы не всегда сразу точно увидите, как добраться до нужного элемента, но это всего лишь вопрос тренировок:

```javascript
const arr2 = [1, [3, 2], [3, [4]]];

arr2[2]; // [3, [4]]
arr2[2][1]; // [4]
arr2[2][1][0]; // 4
```

Изменение и добавление массивов в массив:

```javascript
const arr1 = [[3]];
arr1[0] = [2, 10];
arr1.push([3, 4, 5]);

// [[2, 10], [3, 4, 5]]
```

https://repl.it/@hexlet/js-arrays-nested-arrays-change-and-adding-elements

Вложенные массивы можно изменять напрямую, просто обратившись к нужному элементу:

```javascript
const arr1 = [[3]];
arr1[0][0] = 5;
// [[5]]
```

То же самое касается и добавления нового элемента:

```javascript
const arr1 = [[3]];
arr1[0].push(10);
// [[3, 10]]
```

Для чего же могут понадобиться вложенные массивы? Таких примеров довольно много: начиная от математических концепций, например, матриц, заканчивая представлением игровых полей. Помните игру крестики-нолики? Это как раз тот самый случай:

Разберём такую задачку. Дано игровое поле для крестиков-ноликов. Нужно написать функцию, которая проверяет, есть ли на этом поле хотя бы один крестик или нолик, в зависимости от того, что попросят проверить.

```javascript
// Инициализируем поле
const field = [
  [null, null, null],
  [null, null, null],
  [null, null, null],
];

// Делаем ход:
field[1][2] = "x";
// [
//     [null, null, null],
//     [null, null, 'x'],
//     [null, null, null],
// ]
```

Теперь реализуем функцию, которая выполняет проверку:

```javascript
const didPlayerMove = (field, symbol) => {
  // Обходим поле. Каждый элемент — это строчка в игровом поле.
  for (const row of field) {
    // метод includes проверяет присутствует ли элемент в массиве,
    if (row.includes(symbol)) {
      // Если присутствует, значит мы нашли то, что искали.
      return true;
    }
  }

  // Если поле было просмотрено, но ничего не нашли,
  // значит ходов не было.
  return false;
};
```

Проверим:

```javascript
didPlayerMove(field, "x"); // true
didPlayerMove(field, "o"); // false
```

https://repl.it/@hexlet/js-arrays-nested-arrays-tic-tac-toe

---

##### Дополнительные материалы

1. [Метод массива includes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)

## Генерация строки в цикле—JS: Массивы

Генерация строк в циклах — задача, часто возникающая на практике. Типичный пример — функция, помогающая генерировать HTML-списки. Она принимает на вход коллекцию элементов и возвращает HTML-список из них:

```javascript
const coll = ["milk", "butter"];

buildHTMLList(coll);
// <ul><li>milk</li><li>butter</li></ul>
```

Как можно решить эту задачу "в лоб":

1. Создать переменную `result` и записать в нее `<ul>`.
2. Пройтись циклом по элементам коллекции и дописать в результирующую строку очередной элемент `<li>`.
3. Добавить в конце `</ul>` и вернуть `result` из функции.

```javascript
const buildHTMLList = (coll) => {
  let result = "<ul>";
  for (const item of coll) {
    result = `${result}<li>${item}</li>`;
    // либо так: result += `<li>${item}</li>`;
  }
  result = `${result}</ul>`;

  return result;
};
```

Такой способ вполне рабочий, но для большинства языков программирования максимально неэффективный. Дело в том, что конкатенация и интерполяция порождают новую строчку вместо старой, — и подобная ситуация повторяется на каждой итерации. Причём строка становится всё больше и больше. Копирование строк приводит к серьёзному расходу памяти и может влиять на производительность. Конечно, для большинства приложений данная проблема неактуальна из-за малого объёма прогоняемых данных, но более эффективный подход не сложнее в реализации и обладает рядом плюсов. Поэтому стоит сразу приучить себя работать правильно.

Правильно, в случае с динамическими языками, – формировать массив, который затем с помощью метода `join()` можно превратить в строку:

```javascript
const buildHTMLList = (coll) => {
  const parts = [];
  for (const item of coll) {
    parts.push(`<li>${item}</li>`);
  }

  // Метод join объединяет элементы массива в строку
  // В качестве разделителя между значениями
  // используется то, что передано первым параметром
  const innerValue = parts.join("");
  const result = `<ul>${innerValue}</ul>`;
  return result;
};
```

Размер кода практически не изменился, но способ формирования результата стал другим. Вместо строки, сначала собирается массив, который затем превращается в строку с помощью метода [join()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join). Помимо эффективности, у такого подхода есть дополнительные плюсы:

- Такой код проще отлаживать. Данные, представленные массивом, легче вычленять визуально и программно.
- Массив это структура, с ним можно производить дополнительные манипуляции. С готовой строкой уже ничего особо не сделать.

Регулируя разделитель, строки можно объединять разными способами. Например, через запятую с пробелом:

```javascript
const parts = ["JavaScript", "PHP", "Python"];
const output = parts.join(", ");

console.log(output); // => JavaScript, PHP, Python
```

Если каждое слово надо вывести на новой строчке, то в качестве разделителя используем символ перевода строки `'\n'`:

```javascript
const parts = ["JavaScript", "PHP", "Python"];

// теперь каждое слово будет начинаться с новой строки
const output = parts.join("\n");

console.log(output); // =>
// JavaScript
// PHP
// Python
```

Последний пример особенно важен. Новички часто допускают ошибку и добавляют перевод строки в момент формирования массива, а не в `join()`. Посмотрите на пример с нашей функцией `buildHTMLList()`:

```javascript
// Неправильно

const parts = [];
for (const item of coll) {
  parts.push(`\n<li>${item}</li>`);
}
const innerValue = parts.join(""); // разделителя нет

// Правильно

const parts = [];
for (const item of coll) {
  parts.push(`<li>${item}</li>`);
}
const innerValue = parts.join("\n"); // перевод строки
```

---

##### Дополнительные материалы

1. [Джоэль Спольски. Назад к основам (английская версия)](https://www.joelonsoftware.com/2001/12/11/back-to-basics/)

## Обработка строк через преобразование в массив—JS: Массивы

На собеседованиях часто задают подобные задачки:

_Дана строка текста. Нужно сделать заглавной первую букву каждого слова в тексте. Для простоты считаем что мы работаем с текстом, который не содержит знаков препинания._

```javascript
const text = "hello hexlet";
capitalizeWords(text); // 'Hello Hexlet'
```

Решить её можно многими способами. Чем больше называет человек — тем лучше. К ним относятся:

1. Посимвольный перебор строки.
2. Через преобразование в массив.
3. Регулярные выражения. Рассматриваются в отдельном курсе.

Разберем решение через массив. Для этого воспользуемся методом строки [split()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split), который разделяет строку на части.

```javascript
const capitalizeWords = (sentence) => {
  // определяем разделитель — пробел
  const separator = " ";
  // split разделяет строку по указанному разделителю
  const words = sentence.split(separator);
  // ...
};
```

Следующим шагом нужно обойти массив получившихся слов и преобразовать первую букву каждого слова к верхнему регистру. Строки в JavaScript не имеют встроенного метода для этого, поэтому напишем его сами.

```javascript
const capitalize = (text) =>
  text.length === 0 ? text : `${text[0].toUpperCase()}${text.slice(1)}`;

const capitalizeWords = (sentence) => {
  const separator = " ";
  const words = sentence.split(separator);
  // Формируем массив обработанных слов
  const capitalizedWords = [];
  for (const word of words) {
    capitalizedWords.push(capitalize(word));
  }

  // Соединяем обработанные слова обратно в предложение
  return capitalizedWords.join(separator);
};
```

https://repl.it/@hexlet/js-arrays-strings-capitalize-words

Последнее действие обратно первому. Нужно соединить слова и вернуть получившуюся строку наружу.

Обратите внимание на интересную деталь. Преобразование к верхнему регистру происходит не в исходном массиве `words`, а в новом. Почему? Такой код значительно упрощает отладку. Если алгоритм работает неверно, то всегда можно посмотреть что находится в массиве `words` и что в массиве `capitalizedWords`. Изменяя массив `words` мы бы потеряли эту информацию.

---

##### Дополнительные материалы

1. [Функция words (Lodash)](https://lodash.com/docs#words)
2. [Функция capitalize (Lodash)](https://lodash.com/docs#capitalize)

## Вложенные циклы—JS: Массивы

Во многих языках программирования есть очень полезная функция _flatten_. В определённых задачах она сильно упрощает жизнь и сокращает количество кода. Эта функция принимает на вход массив и выпрямляет его: если элементами массива являются массивы, то _flatten_ сводит всё к одному массиву, раскрывая каждый вложенный. В js эта функция реализована как метод `flat()` у массивов:

```
[[3, 2], 5, 3, [3, 4, 2], 10].flat();
// [3, 2, 5, 3, 3, 4, 2, 10]
```

Реализуем эту функцию самостоятельно. В общем случае эта функция раскрывает массивы на всех уровнях вложенности. Но мы для простоты сделаем вариант функции, в котором происходит раскрытие только до первого уровня. То есть, если элемент основного массива — массив, то он раскрывается без просмотра его внутренностей (там тоже могут быть массивы).

Логика работы функции выглядит так:

```javascript
const flatten = (coll) => {
  const result = [];
  for (const item of coll) {
    // Array.isArray — функция-предикат стандартной библиотеки,
    // которая проверяет, является ли значение массивом.
    if (Array.isArray(item)) {
      // Если значение массив, то проходим по всем его элементам
      // Здесь появился вложенный цикл
      for (const subItem of item) {
        // и добавляем их в результирующий массив
        result.push(subItem);
      }
    } else {
      // Если значение не массив, то сразу добавляем его в результирующий массив
      result.push(item);
    }
  }

  return result;
};

console.log(flatten([3, 2, [], [3, 4, 2], 3, [123, 3]]));
// => [ 3, 2, 3, 4, 2, 3, 123, 3 ]
```

https://repl.it/@hexlet/js-arrays-nested-loops-flatten

Обратите внимание, что вложенный цикл запускается, только если текущий элемент — массив. Чисто технически во вложенных циклах нет ничего особенного. Их можно вкладывать внутрь любого блока и друг в друга сколько угодно раз. Но прямой связи между внешним и вложенным циклами нет. Внутренний цикл может использовать результаты внешнего, а может и работать по своей собственной логике независимо.

Вложенные циклы коварны. Их наличие может резко увеличить сложность кода, так как появляется множество постоянно изменяющихся переменных. Становится тяжело уследить за происходящими внутри процессами. Кроме того, вложенные циклы могут указывать на использование неэффективного алгоритма решения задачи. Это не всегда так, но вероятность такая есть.

Как избавиться от вложенных циклов? Есть три варианта. Первый – ничего не делать, иногда вложенные циклы это нормально, особенно в низкоуровневых алгоритмах. Второй – переписать алгоритм так, чтобы вложенного цикла не осталось вообще, даже в вызываемых функциях. Когда это невозможно – использовать третий вариант. Вынести вложенный цикл в функцию, либо заменить на встроенную функцию (или метод). Например в JavaScript у массивов есть метод `includes()`, который внутри себя представляет не что иное, как обход массива в цикле.

```javascript
// Эта функция заменяет собой цикл
// Но не забывайте что внутри все равно остается полный обход массива
[1, 10, 3].includes(10); // true
```

Пример выноса в отдельную функцию кода на flatten:

```javascript
// Изменяет первый массив напрямую
// В данном случае такая реализация оправдана
const append = (arr1, arr2) => {
  for (const item of arr2) {
    arr1.push(item);
  }
};

const flatten = (coll) => {
  const result = [];
  for (const item of coll) {
    if (Array.isArray(item)) {
      // Нет присваивания так как меняется сам result
      append(result, item);
    } else {
      result.push(item);
    }
  }

  return result;
};

flatten([3, 2, [], [3, 4, 2], 3, [123, 3]]);
// [3, 2, 3, 4, 2, 3, 123, 3]
```

---

##### Дополнительные материалы

1. [Метод Array.isArray, проверяющий, является ли значение массивом](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
2. [Встроенный метод flat](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
3. [.flat() и .flatMap(): новые методы для работы с массивами в ECMAScript](https://ru.hexlet.io/blog/posts/flat-i-flatmap-novye-metody-dlya-raboty-s-massivami-v-ecmascript)

## Теория Множеств—JS: Массивы

Теория множеств – крайне важная математическая концепция для любых разработчиков. Данные, с которыми работают программы, часто представляются как множества, а значит к ним применимы правила теории множеств. В первую очередь это касается различных операций над множествами, например, пересечения или объединения.

Это не значит, что нужно знать эту теорию от и до. Напротив, достаточно изучить ее основные понятия и некоторые операции. Этого хватит для эффективного решения подавляющего числа задач. Сама теория множеств относится к интуитивно понятным концепциям. Она хорошо ложится на здравый смысл и понятна людям даже без особой математической подготовки.

### Краткая терминология

Основное понятие теории множеств, как не удивительно — **множество**. Множеством обозначают набор объектов произвольной природы, рассматривающихся как единое целое. Простейший пример — цифры. Множество всех цифр включает в себя 10 элементов (от 0 до 9).

Но не каждый набор объектов можно назвать множеством. Существует важное условие – все элементы множества должны быть уникальными. Например, числа _1, 1 и 3_ не могут называться множеством, а _1, 3, 5_ могут.

Множества между собой могут находиться в определенных отношениях. Например, множество натуральных чисел является подмножеством целых чисел, которые в свою очередь являются подмножеством рациональных чисел и так далее. Понятие «подмножество» означает, что все элементы одного множества также входят в другое множество, называемое **надмножеством**.

![Real Set](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjRmZDU3YWYyNTZkNDUxOGU2N2Q0NTYxMWI5MDAzMzQxLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=54d69835128e1d4dc7028cb9bc5dd58691f7cd16a06e0616f99223253154bff0)

Представление множеств кружками довольно удобно. Можно быстро оценить как друг с другом соотносятся разные множества.

Но математические объекты, такие как числа, не единственные возможные объекты множеств. Множеством можно назвать группу людей, стоящих на остановке в ожидании своего автобуса, или жильцов квартир одного дома, города или страны.

В программировании в качестве множеств могут выступать массивы и таблицы в базе данных. В JavaScript для представления множеств есть встроенный механизм [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set). Но для работы с ним нужно немного понимать объектно-ориентированные возможности, которые рассматриваются в более поздних курсах.

### Операции над множествами

На практике, представление данных в виде множеств полезно тогда, когда мы хотим что-то сделать с ними. Простой пример. Когда в Фейсбуке вы заходите на страницу другого человека, то Фейсбук показывает вам блок с общими друзьями. Если принять, что ваши друзья и друзья вашего друга — два множества, то общие друзья — множество, полученное как пересечение исходных множеств друзей.

Пересечение — один из ярких примеров операции над множествами, которая в программировании встречается повсеместно. То же самое можно сказать и о некоторых других операциях. Важно, что результатом всех этих операций являются множества, а значит они подчиняются тем же правилам, что и исходные множества. Например, сохраняется уникальность элементов.

#### Пересечение

Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.

Пример с общими друзьями:

```javascript
// Друзья одного человека
const friends1 = ["vasya", "kolya", "petya"];

// Друзья другого человека
const friends2 = ["igor", "petya", "sergey", "vasya", "sasha"];

// Общие друзья
// Эта функция принимает любое количество массивов.
// То есть вы можете находить пересечение любого количества массивов за один вызов.
_.intersection(friends1, friends2); // ['vasya', 'petya']
```

#### Объединение

Объединением множеств называется множество, в которое входят элементы всех данных множеств.

```
const friends1 = ['vasya', 'kolya', 'petya'];
const friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];

_.union(friends1, friends2); // ['vasya', 'kolya', 'petya', 'igor', 'sergey', 'sasha']
```

Каждый друг в объединении встречается ровно один раз.

#### Дополнение (разность)

Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе. В программировании такая операция часто называется _diff_ (разница).

```javascript
const friends1 = ["vasya", "kolya", "petya"];
const friends2 = ["igor", "petya", "sergey", "vasya", "sasha"];

_.difference(friends1, friends2); // ['kolya']
```

#### Принадлежность множеству

Проверку принадлежности элемента множеству можно выполнить с помощью встроенного метода `includes()`:

```javascript
const terribleNumbers = [4, 13];

if (terribleNumbers.includes(10)) {
  console.log("woah!");
}
```

---

##### Дополнительные материалы

1. [Рассказы о множествах (pdf)](https://www.mccme.ru/free-books/vilenkin-rasomn.pdf)
2. [Встроенный метод includes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)
3. [Функция intersection из библиотеки Lodash](https://lodash.com/docs/#intersection)
4. [Функция union из библиотеки Lodash](https://lodash.com/docs/#union)
5. [Функция difference из библиотеки Lodash](https://lodash.com/docs/#difference)

## Сортировка массивов—JS: Массивы

Сортировка массивов — базовая алгоритмическая задача, которую нередко спрашивают на собеседованиях. Однако в реальном коде массивы сортируют, используя уже готовые функции стандартной библиотеки. В JavaScript сортировка выполняется с помощью метода `sort()` массивов:

```javascript
const numbers = [8, 3, 10];
// sort изменяет массив!
numbers.sort((a, b) => a - b); // сортировка по возрастанию
console.log(numbers); // => [3, 8, 10]

// В обратную сторону можно через reverse() выполненный после sort()
// Тоже изменяет массив
numbers.reverse();
console.log(numbers); // => [10, 8, 3]
```

Тогда для чего задают подобные вопросы? Обычно собеседующий хочет узнать следующее:

1. Насколько кандидат вообще в курсе о существовании алгоритмов.
2. Способен ли он программировать (составлять программу сам, думая своей головой).
3. Как работает его алгоритмическое мышление.

Знание алгоритмов действительно влияет на то, как мы думаем и насколько быстро соображаем. И хотя невозможно знать все алгоритмы, нужно хотя бы иметь представление о самых ключевых и в идеале уметь их реализовывать. В [нашем списке](https://ru.hexlet.io/pages/recommended-books) рекомендуемых книг есть как минимум одна книга, полностью посвящённая алгоритмам.

Кроме того, Роберт Мартин в своей книге "Идеальный программист" рассказывает о подходе [Ката](https://ru.wikipedia.org/wiki/Ката) — понятии, взятом из боевых искусств.

> Принцип изучения боевого искусства на основе ката состоит в том, что повторяя ката многие тысячи раз, практик боевого искусства приучает своё тело к определённого рода движениям, выводя их на бессознательный уровень. Таким образом, попадая в боевую ситуацию, тело работает "само" на основе рефлексов, вложенных многократным повторением ката. Также считается, что ката обладают медитативным воздействием.

Роберт Мартин рекомендует время от времени решать классические алгоритмические задачки для поддержания формы. Эта тема стала настолько популярной, что если загуглить _javascript github kata_, то вы увидите множество репозиториев с подобными задачками.

### Сортировка

Способов сортировать массив достаточно много. Самый популярный для обучения — [пузырьковая сортировка (bubble sort)](https://ru.wikipedia.org/wiki/Сортировка_пузырьком).

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма).

```javascript
// Функция изменяет входящий массив coll
const bubbleSort = (coll) => {
  let stepsCount = coll.length - 1;
  // Объявляем переменную swapped, значение которой показывает был ли
  // совершен обмен элементов во время перебора массива
  let swapped;
  // do..while цикл. Работает почти идентично while
  // Разница в проверке. Тут она делается не до выполнения тела, а после.
  // Такой цикл полезен там, где надо выполнить тело хотя бы раз в любом случае.
  do {
    swapped = false;
    // Перебираем массив и меняем местами элементы, если предыдущий
    // больше, чем следующий
    for (let i = 0; i < stepsCount; i += 1) {
      if (coll[i] > coll[i + 1]) {
        // temp – временная константа для хранения текущего элемента
        const temp = coll[i];
        coll[i] = coll[i + 1];
        coll[i + 1] = temp;
        // Если сработал if и была совершена перестановка,
        // присваиваем swapped значение true
        swapped = true;
      }
    }
    // Уменьшаем счетчик на 1, т.к. самый большой элемент уже находится
    // в конце массива
    stepsCount -= 1;
  } while (swapped); // продолжаем, пока swapped === true

  return coll;
};

console.log(bubbleSort([3, 2, 10, -2, 0])); // => [ -2, 0, 2, 3, 10 ]
```

https://repl.it/@hexlet/js-arrays-sorting-bubble

Весь код этой функции делится на два уровня:

1. Внутренний цикл _for_, который проходит по массиву от начала до конца, меняя элементы попарно, если нужно сортировать.
2. Внешний цикл _do...while_, который определяет, когда нужно остановиться. Обратите внимание, что в худшем случае этот цикл выполнится `coll.length` раз, что совпадает с теоретическим худшим случаем этого алгоритма, при котором самый большой или маленький элемент находятся в противоположных концах массива от сортированного варианта.

Пузырьковая сортировка – самый простой и интуитивно понятный алгоритм сортировки. Очень полезно уметь реализовывать по памяти. Попробуйте сделать это на собственном компьютере не подсматривая в теорию.

---

##### Дополнительные материалы

1. [Сортировка средствами JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
2. [Цикл do...while](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/do...while)
3. [Визуализация алгоритмов сортировок](https://visualgo.net/ru/sorting)

## Стек—JS: Массивы

Тема алгоритмов не существует сама по себе. Важно не только уметь составлять правильный алгоритм решения, но не менее важно использовать для работы с данными правильную структуру.

**Структура данных** — это конкретный способ хранения и организации данных. В зависимости от решаемых задач, удобным оказывается либо один способ организации данных, либо другой. Как минимум, одну структуру данных вы уже знаете достаточно хорошо — это массив. С точки зрения организации, массив представляет собой совокупность элементов, к которым имеется индексированный доступ (доступ по индексу), а вот с точки зрения физического хранения в памяти — всё сложнее. Массивы бывают разные и внутри языка реализуются тоже [по-разному](<https://ru.wikipedia.org/wiki/Массив_(тип_данных)>).

Кроме массивов существует множество других структур данных, таких как списки, хеш-таблицы, деревья, графы, стек, очередь и другие. Использование структуры данных, подходящей под решаемую задачу, позволяет кардинально упростить код, устраняя запутанную логику.

Некоторые из перечисленных структур данных мы рассмотрим в процессе прохождения курсов и проектов, другие вам нужно будет подтянуть самостоятельно из книг. В любом случае алгоритмы и структуры данных (без фанатизма) составляют базу, на которую нанизывается всё остальное в разработке.

Стоит разделять три понятия:

- Структура данных
- Конкретный тип данных (или просто "тип данных")
- Абстрактный тип данных (АТД)

Со структурой данных всё понятно, выше было определение. С типом данных тоже все просто. Например, _числа в JavaScript — это тип данных_. Понятие «тип данных» всегда привязано к конкретному языку и может быть абсолютно чем угодно в зависимости от предпочтений разработчиков языка. Другими словами, если бы разработчики JavaScript решили, что числа надо назвать типом данных String, то никто бы им этого не запретил, несмотря на абсурдность такого имени для чисел.

А вот абстрактные типы данных — теоретическое понятие. АТД целиком и полностью определяется набором операций, которые можно выполнять над ним. АТД абстрактный потому, что он ничего не говорит о способе хранения и существует лишь на бумаге и в головах. А вот уже в конкретных языках существуют конкретные типы, реализующие АТД. АТД нередко путают с понятием «структура данных», более того, часто, структуры данных и АТД имеют одно и то же название. Сильно погружаться в эти дебри не нужно, достаточно иметь общее представление.

В этом уроке мы разберем один из самых простых и важных абстрактных типов данных – стек (stack, переводится как стопка).

### Стек

Стек — упорядоченная коллекция элементов, в которой добавление новых и удаление старых элементов всегда происходит с одного конца коллекции. Обычно его называют вершиной стека.

![Стек](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImJjMGEzZjI4NTQ5NTliMzZkYTZhMDFlOWJlNmZkNzdiLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=672467ccd1e8171da0d787fcbf59ebf3be45faec7bf91052738022c347a72dbf)

У стека есть аналоги из реальной жизни. Например, магазин автомата. Патроны добавляются в магазин только друг за другом. Извлекаются тоже, только в обратном порядке. Последний вставленный патрон выйдет из магазина первым.

![Магазин](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjAxMDZmNDg1ZmY3NmUyZDhmNzg2NDdkYTg1NGZhYTI1LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ff641c80f6f3b5d615f738f1225b51cfdd4a13d2da7c7dce0222640d5edb7dc3)

Практически любая стопка может рассматриваться как стек. Если не применять грубую физическую силу, то со стопками мы работаем двумя способами. Либо кладём новый элемент (например, книгу) на верхушку стопки, либо снимаем элемент с верхушки. Поэтому стек ещё называют "Last In First Out" (LIFO), то есть "последним зашёл, первый вышел".

Перед тем, как разбирать конкретную задачу, посмотрим на роль, которую играет стек в программировании. Вспомните, как исполняется любая программа. Одни функции вызывают другие, которые, в свою очередь, вызывают третьи, и так далее. После того, как выполнение заходит в самую глубокую функцию, та возвращает значение, и начинается обратный процесс. Сначала идёт выход из наиболее глубоких функций, затем из тех, что уровнем выше, и так далее до тех пор, пока не дойдёт до самой внешней функции. Вызов функций — не что иное, как добавление элемента в стек, а возврат – извлечение из стека. Именно так всё устроено на аппаратном уровне. К тому же, если в процессе выполнения программы происходит ошибка, то её вывод часто называют _Stack Trace_ (трассировка стека).

Другой пример, связанный с программированием — кнопка "назад" в браузере. История посещений представляет собой стек, каждый новый переход по ссылке добавляет её в историю, а кнопка «назад» извлекает из стека последний элемент.

Работа со стеком включает в себя следующие операции:

- Добавить в стек (push)
- Взять из стека (pop)
- Вернуть элемент с вершины стека без удаления (peekBack)
- Проверить на пустоту (isEmpty)
- Вернуть размер (size)

Первые две – базовые, остальные нужны время от времени. В JavaScript стек можно создать на основе массивов. Для этого используются методы `push()`, `pop()` и свойство `length`.

```javascript
const stack = [];

stack.push(3);
console.log(stack); // => [ 3 ]
stack.push("Winterfall");
console.log(stack); // => [ 3, 'Winterfall' ]
stack.push(true);
console.log(stack); // => [ 3, 'Winterfall', true ]

const element1 = stack.pop();
console.log(element1); // => true
console.log(stack); // => [ 3, 'Winterfall' ]

const element2 = stack.pop();
console.log(element2); // => Winterfall
console.log(stack); // => [ 3 ]
```

https://repl.it/@hexlet/js-arrays-stack

Обратите внимание, что методы `pop()` и `push()` изменяют исходный массив. `pop` не только изменяет его, но и возвращает элемент, снятый со стека.

Рассмотрим задачку, решение которой тривиально при использовании стека. Кстати, её нередко задают на собеседованиях, как раз чтобы убедиться, хорошо ли вы знаете базовые структуры данных.

Задача:

Необходимо реализовать функцию, которая проверяет, что парные скобки сбалансированы. То есть каждая открывающая скобка имеет закрывающую: `()`, `((()()))`. А вот пример несбалансированных скобок: `(`, `(()`, `)(`. Для проверки баланса недостаточно считать количество, важен так же порядок в котором они идут.

_У этой задачи есть простое решение и без стека, но стек тоже хорошо подходит (и даже нагляднее)_

Решение со стеком выглядит так:

1. Если перед нами открывающий элемент, то заносим его в стек
2. Если закрывающий, то достаём из стека элемент (очевидно, последний добавленный) и смотрим, что он открывающий для данного закрывающего. Если проверка провалилась, значит выражение не соответствует требуемому формату.
3. Если мы дошли до конца строки и стек пустой, то всё хорошо. Если в стеке остались элементы, то проверка не прошла. Такое может быть, если в начале строки были открывающие элементы, но в конце не было закрывающих.

Разберём его построчно:

```javascript
const checkIsBalanced = (expression) => {
  // Инициализация стека
  const stack = [];
  // Проходим по каждому символу в строке
  for (const symbol of expression) {
    // Смотрим открывающий или закрывающий
    if (symbol === "(") {
      stack.push(symbol);
    } else if (symbol === ")") {
      // Если для закрывающего не нашлось открывающего, значит баланса нет
      if (!stack.pop()) {
        return false;
      }
    }
  }

  return stack.length === 0;
};

export default checkIsBalanced;
```

https://repl.it/@hexlet/js-arrays-stack-balancing

Предположим, что на вход функции попала следующая строка: `(()`. Ниже описание ключевых шагов при выполнении функции проверки:

1. Первая скобка `(` заносится в стек, так как она открывающая
2. Следующая скобка `(` также заносится в стек по той же самой причине
3. Последняя `)` является закрывающей, из стека извлекается последняя добавленная скобка
4. В стеке остался один элемент, значит баланса нет

### Семантика

Может возникнуть соблазн использовать эти функции в повседневной практике. Например, чтобы извлечь из массива последний элемент. Несмотря на то, что метод `pop()` действительно позволяет это сделать, такой вариант использования крайне нежелателен по нескольким причинам:

1. Побочный эффект данной операции — изменение исходного массива. Даже если массив потом не используется, такой код вносит потенциальные проблемы и заставляет его переписывать в будущем.
2. Нарушается семантика. Инструменты нужно использовать по назначению, иначе рождается код, который декларирует одно, но в реальности делает другое. Любой опытный программист, который видит `pop()` сразу считает, что массив в данной части программы используется как стек. Если это не так, то понадобятся дополнительные умственные усилия для понимания происходящего.

Для извлечения последнего элемента лучше использовать метод [last()](https://lodash.com/docs#last) библиотеки lodash.

```javascript
import _ from "lodash";

const items = ["first", "second", "third"];
_.last(items); // 'third'
```

---

##### Дополнительные материалы

1. [метод push](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
2. [метод pop](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)

## Big O—JS: Массивы

Когда заходит речь про алгоритмы, нельзя не упомянуть понятие «сложность алгоритма» (обозначается как Big O). Оно даёт понимание того, насколько эффективен алгоритм.

Как вы помните, алгоритмов сортировок существует [много](https://ru.wikipedia.org/wiki/Алгоритм_сортировки#Список_алгоритмов_сортировки). Все они выполняют одну и ту же задачу, но при этом отличаются друг от друга. В информатике алгоритмы сравниваются друг с другом по их алгоритмической сложности. Эта сложность оценивается как количество выполняемых операций алгоритмом для достижения своей цели. Например разные способы сортировки требуют очень разного количества "проходов" по массиву перед тем как массив будет полностью отсортирован. Понятно, что конкретное количество операций зависит от входных данных, например, если массив уже отсортирован, то количество операций будет минимальным (но они все равно будут, потому что алгоритм должен убедиться в том, что массив отсортирован).

Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.

Вот некоторые примеры того, как записывается сложность: _O(1)_, _O(n)_, _O(nlog(n))_.

![Sorting Big O](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImRiOTUxNTM0MzAwMDcwZmUwYjc0ZWYzOTM1ZTNmY2JiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ad96d9be1bd0f01197b85419ab56bfdd4a33adc41dd4074a3e50c8748c85c396)

_O(1)_ описывает константную (постоянную) сложность. Такой сложностью обладает операция доступа к элементу массива по индексу. Сложность (в алгоритмическом смысле) доступа к элементу не зависит от размеров массива и является величной постоянной. А вот функция, которая печатает на экран все элементы переданного массива, используя обычный перебор, имеет сложность _O(n)_ (линейная сложность). То есть количество выполняемых операций, в худшем случае, будет равно количеству элементов массива. Именно это количество символизирует символ _n_ в скобках.

Что такое худший случай? В зависимости от того в каком состоянии находятся начальный массив, количество операций будет разным даже при условии что массив одного и того же размера. Чтобы проще понять, возьмем в качестве аналогии кубик-рубик. Количество операций (действий) которые нужно проделать для сборки кубика рубика зависит от того, в каком положении находятся его грани перед сборкой. В некоторых случаях действий понадобится мало, в других много. И вот та ситуация, в которой таких действий понадобится больше всего и называется худшим случаем. Алгоритмическая сложность всегда оценивается по худшему случаю для выбранного алгоритма.

Ещё один пример — вложенные циклы. Вспомните как работает поиск пересечений в неотсортированных массивах. Для каждого элемента из одного массива проверяется каждый элемент другого массива (либо через цикл, либо с помощью метода `includes()`, чья сложность _O(n)_, ведь в худшем случае он просматривает весь массив). Если принять, что размеры обоих массивов одинаковы и равны _n_, то получается, что поиск пересечений имеет квадратичную сложность или _O(n2)_ (n в квадрате).

Существуют как очень эффективные, так и абсолютно неэффективные алгоритмы. Скорость работы подобных алгоритмов падает с катастрофической скоростью даже при небольшом количестве элементов. Нередко более быстрые алгоритмы быстрее не потому, что они лучше, а потому что они потребляют больше памяти или имеют возможность запускаться параллельно (и если это происходит, то работают крайне эффективно). Как и всё в инженерной деятельности, эффективность — компромисс. Выигрывая в одном месте, мы проиграем где-то в другом.

![Big O](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjliZDRiZjM2OWY3ZWMxZTQyZDQzODIyYjRjODEyZWZkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d3e2118a9ab13541df9aa496ea07ac533c8bb1a79ca7911d52911add1a5e8546)

Big O, во многом, теоретическая оценка, на практике всё может быть по-другому. Реальное время выполнения зависит от множества факторов среди которых: архитектура процессора, операционная система, язык программирования, доступ к памяти (последовательный или произвольный) и многое другое.

Вопрос эффективности кода довольно опасен. В силу того, что многие начинают учить программирование именно с алгоритмов (особенно в университете), им начинает казаться, что эффективность — это главное. Код должен быть быстрым.

Такое отношение к коду гораздо чаще приводит к проблемам, чем делает его лучше. Важно понимать, что эффективность — враг понимаемости. Такой код всегда сложнее, больше подвержен ошибкам, труднее модифицируется, дольше пишется. А главное, настоящая эффективность редко когда нужна сразу или вообще не нужна. Обычно тормозит не код, а, например, запросы к базе данных или сеть. Но даже если код выполняется медленно, то вполне вероятно, что именно тот участок, который вы пытаетесь оптимизировать, вызывается за все время жизни программы всего лишь один раз и ни на что не влияет, потому что работает с небольшим объёмом памяти, а где-то в это время есть другой кусок, который вызывается тысячи раз, и приводит к реальному замедлению.

> Программисты тратят огромное количество времени, размышляя и беспокоясь о некритичных местах кода, и пытаются оптимизировать их, что исключительно негативно сказывается на последующей отладке и поддержке. Мы должны вообще забыть об оптимизации в, скажем, 97% случаев. Поспешная оптимизация является корнем всех зол. И, напротив, мы должны уделить все внимание оставшимся 3%. — Дональд Кнут

Перед тем, как пытаться что-то оптимизировать, обязательно прочитайте [небольшую онлайн-книжку](http://optimization.guide/), которая хорошо объясняет суть всех оптимизаций.

---

##### Дополнительные материалы

1. [Big-O Cheat Sheet](https://bigocheatsheet.com/)

## Деструктуризация—JS: Массивы

Деструктуризация (destructuring) – синтаксическая возможность "раскладывать" элементы массива (и не только) в отдельные константы или переменные. Деструктуризация относится к необязательным, но очень приятным возможностям языка. Рассмотрим ее на примерах.

Представьте, что у нас есть массив из двух элементов, которыми мы хотим оперировать в нашей программе. Самый простой вариант использования его элементов — постоянное обращение по индексу `point[0]` и `point[1]`.

```javascript
const point = [3, 5];

console.log(`${point[0]}:${point[1]}`); // => 3:5
```

Индексы ничего не говорят о содержимом, и для понимания этого кода придется прикладывать дополнительные усилия. Гораздо лучше сначала присвоить эти значения переменным с хорошими именами. Тогда код станет читаемым:

```javascript
const x = point[0];
const y = point[1];

console.log(`${x}:${y}`); // => 3:5
```

Код стал значительно понятнее, хотя и длиннее. С помощью деструктуризации то же самое можно сделать короче:

```javascript
const [x, y] = point;
// Слева массив повторяет структуру правого массива
// но вместо значений используются идентификаторы
// они заполняются значениями, стоящими на тех же позициях в правом массиве
// [x, y] = [3, 5]
// x = 3, y = 5

console.log(`${x}:${y}`); // => 3:5
```

Получилось и короче, и понятнее (особенно если привыкнуть к этому способу записи). Деструктуризация позволяет извлечь из массива практически любые части, используя очень короткий и интуитивно понятный синтаксис. Она работает даже в том случае, когда нас интересует только часть массива. Причем как начало, так и его конец:

```javascript
// Извлекаем первый элемент
// Остальные игнорируются
const [x] = point;

// Извлекаем второй элемент
// Для этого просто не указываем первый
const [, y] = point;

// и даже так
const [, secondElement, , fourthElement, fifthElement] = [1, 2, 3, 4, 5, 6];

console.log(secondElement); // => 2
console.log(fourthElement); // => 4
console.log(fifthElement); // => 5
```

https://repl.it/@hexlet/js-arrays-destructuring-positional

Мы извлекли из массива `[1, 2, 3, 4, 5, 6]` значения второго, четвёртого и пятого элементов, сохранив их, соответственно, в константах `secondElement`, `fourthElement` и `fifthElement`. При этом на месте первого (нулевой индекс) и третьего (второй индекс) элементов мы сделали пропуски, не указав никаких переменных, потому что значения этих элементов в данном случае нам были не нужны.

Если при деструктуризации указать переменную так, что ей не будет соответствовать ни один элемент массива, то в переменную запишется значение `undefined`:

```javascript
const [firstElement, secondElement, thirdElement] = [1, 2];

console.log(firstElement); // => 1
console.log(secondElement); // => 2
console.log(thirdElement); // => undefined
```

Исходный массив состоит всего из двух элементов, поэтому в `thirdElement` сохранилось `undefined`. Но в таких случаях можно подстраховаться и определить значение по умолчанию:

```javascript
const [firstElement, secondElement, thirdElement = 3] = [1, 2];

console.log(firstElement); // => 1
console.log(secondElement); // => 2
console.log(thirdElement); // => 3
```

В массиве `[1, 2]` нет соответствия для `thirdElement`, поэтому в константу `thirdElement` было записано значение по умолчанию `3`.

Деструктуризация работает на любом уровне вложенности. Например с ее помощью можно извлекать данные из массивов внутри массивов:

```javascript
const [one, [two, three]] = [1, [2, 3]];
```

Количество возможных комбинаций и вариантов использования деструктуризации – бесконечное множество. Чем больше вы будете экспериментировать с ней, тем больше найдете вариантов использования.

### Деструктуризация в циклах

Разложение массива можно использовать не только как отдельную инструкцию в коде, но и, например, в циклах:

```javascript
const points = [
  [4, 3],
  [0, -3],
];

for (const [x, y] of points) {
  console.log([x, y]);
}

// => [ 4, 3 ]
// => [ 0, -3 ]
```

https://repl.it/@hexlet/js-arrays-destructuring-for-of

На самом деле такое разложение можно сделать почти во всех местах, где явно или неявно ожидается массив. Входные параметры, возвращаемые значения функций, циклы и некоторые другие ситуации, с которыми вы обязательно будете сталкиваться при написании кода.

```javascript
const swapValues = ([a, b]) => [b, a];

swapValues([1, 2]); // [2, 1]
```

### Деструктуризация строк

В JavaScript строки ведут себя подобно массивам и их также можно деструктурировать.

```javascript
const [first, second, third] = "two";
console.log(first); // => 't'
console.log(second); // => 'w'
console.log(third); // => 'o'
```

---

##### Дополнительные материалы

1. [Официальная документация](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring)

## Rest-оператор и деструктуризация—JS: Массивы

Мощь деструктуризации больше всего проявляется там, где она используется вместе с rest-оператором. Rest-оператор позволяет "свернуть" часть элементов во время деструктуризации. Например с его помощью можно разложить массив на первый элемент и все остальные:

```javascript
const fruits = ["apple", "orange", "banana", "pineapple"];

// ... – rest-оператор
const [first, ...rest] = fruits;
console.log(first); // 'apple'
console.log(rest); // ['orange', 'banana', 'pineapple']
```

Запись `...rest` означает, что нужно взять все элементы, которые остались от деструктуризации и поместить их в массив с именем `rest`. Этому массиву можно дать любое имя. rest-оператор срабатывает в самом конце, когда все остальные данные уже разложены по своим константам (или переменным). Именно поэтому он называется _rest_ (оставшиеся).

Подобным образом любой массив раскладывается на любое количество элементов + остальные. У rest-оператора есть ограничения. Он не может появляться нигде, кроме конца массива.

```javascript
const [head, ...tail] = fruits;
// tail = ['orange', 'banana', 'pineapple']

const [first, second, ...rest] = fruits;
// rest = ['banana', 'pineapple']

const [first, second, third, ...rest] = fruits;
// rest = ['pineapple']

// Если элементов нет, то в rest окажется пустой массив
const [first, second, third, oneMore, ...rest] = fruits;
// rest = []
```

В ситуациях, когда нас интересует только часть массива, но не важны первые элементы, лучше воспользоваться методом массива `slice()`:

```javascript
// slice возвращает новый массив, а не изменяет старый
const rest = fruits.slice(1);
console.log(rest); // ['orange', 'banana', 'pineapple'];
```

rest-оператор можно применять также и при деструктуризации строк.

```javascript
const [first, second, ...rest] = "some string";
console.log(first); // => 's'
console.log(second); // => 'o'
console.log(rest); // => [ 'm', 'e', ' ', 's', 't', 'r', 'i', 'n', 'g' ]
```

Обратите внимание, что после упаковки оставшейся части строки в `rest` в итоге мы получаем массив, а не строку.

## Spread-оператор и создание новых массивов—JS: Массивы

У оператора rest есть оператор-компаньон – spread-оператор. Этот оператор имеет такой же синтаксис, но выполняет противоположную задачу. Он не сворачивает элементы, а наоборот, растягивает их. С его помощью обычно копируют или сливают массивы.

Представьте, что нам нужно определить массив, добавив туда элементы из другого массива. Такая задача часто встречается при работе со значениями по умолчанию:

```javascript
const russianCities = ["moscow", "kazan"];
const cities = ["milan", "rome", ...russianCities];
// ['milan', 'rome', 'moscow', 'kazan']

// Массив russianCities при этом никак не меняется

// То же самое без spread-оператора
const cities = ["milan", "rome"].concat(russianCities);
```

`...` в данном случае spread-оператор. Он растянул массив, добавив все его элементы в новый массив. Как отличить его от rest-оператора? Все дело в контексте использования. Rest-оператор появляется слева от знака равно, там, где происходит деструктуризация. Spread-оператор – справа от знака равно, там где массив формируется.

Spread-оператор, в отличие от rest-оператора может, появляться в любой части массива. Например, мы можем дополнить исходный массив не справа, а слева:

```javascript
const cities = [...russianCities, "milan", "rome"];
// ['moscow', 'kazan', 'milan', 'rome']

// То же самое без spread-оператора
const cities = russianCities.concat(["milan", "rome"]);
```

И даже посередине:

```javascript
const cities = ["milan", ...russianCities, "rome"];
// ['milan', 'moscow', 'kazan', 'rome']

// Без spread-оператора подобный код нельзя выразить одной операцией
```

Spread-оператор работает с любым количеством массивов:

```javascript
const russianCities = ["moscow", "kazan"];
const ukrainianCities = ["kiev", "odessa"];
// слияние двух массивов
const cities = [...russianCities, ...ukrainianCities];
// ['moscow', 'kazan', 'kiev', 'odessa']

// То же самое без spread-оператора
const cities = russianCities.concat(ukrainianCities);
```

### Копирование массива

Spread-оператор нередко используется для копирования массива. Копирование предотвращает изменение исходного массива, в том случае, когда необходимо менять его копию:

```javascript
const russianCities = ["moscow", "kazan"];
const copy = [...russianCities];
copy.push("samara");
console.log(copy); // => ['moscow', 'kazan', 'samara']
console.log(russianCities); // => ['moscow', 'kazan']

// То же самое без spread-оператора
const russianCities = ["moscow", "kazan"];
const copy = russianCities.slice();
```

## Массивы в памяти компьютера—JS: Массивы

Работая на таких высокоуровневых языках, как JavaScript, позволительно не знать устройство массивов для решения повседневных задач. С другой стороны, подобное понимание делает код менее магическим и даёт возможность заглядывать чуть дальше.

### Массивы в Cи

Реальные массивы лучше всего рассматривать на языке **Cи**, который, с одной стороны, достаточно простой и понятный, с другой — очень близок к железу и не скрывает от нас практически ничего. Когда мы говорим про примитивные типы данных, такие как "строка" или "число", то на интуитивном уровне всё довольно понятно: под каждое значение выделяется некоторый размер памяти (в соответствии с типом), в которой и хранится само значение. А как должна выделиться память под хранение массива? И что такое массив в памяти? На уровне хранения понятия массив не существует. Массив представляется цельным куском памяти, размер которого вычисляется по следующей формуле: _количество элементов \* количество памяти под каждый элемент_. Из этого утверждения есть два интересных вывода:

- Размер массива — фиксированная величина. Те динамические массивы (изменяющие свой размер во время работы), с которыми мы имеем дело во многих языках, реализованы уже внутри языка, а не на уровне железа.
- Все элементы массива имеют один тип и занимают одно и то же количество памяти. Благодаря этому появляется возможность простым умножением (по формуле, описанной выше) получить адрес той ячейки, в которой лежит нужный нам элемент. Именно это происходит под капотом, при обращении к элементу массива под определённым индексом.

![Массив в Си](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImQyNmY4NWI2YjFhNGMzOTRiMTY3NDU2YWE2YTYyYjNhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ffb80b035f91ac0d821925bf19f22a7dcb84e4b1c774a527ec4e1255726c248f)

Фактически, индекс в массиве — смещение относительно начала куска памяти, содержащего данные массива. Адрес, по которому расположен элемент под конкретным индексом, рассчитывается так: _индекс \* количество памяти, занимаемое одним элементом (для данного типа данных на данной архитектуре)_. Пример на Си:

```javascript
// Инициализация массива из пяти элементов типа int
// Предположим, что int занимает 2 байта
// Общее количество памяти выделенное под массив int * 5 = 2 * 5 = 10 байт
int numbers[] = {19, 10, 8, 17, 9};
numbers[3]; // 17
```

Если предположить, что тип `int` занимает в памяти 2 байта, то адрес элемента, соответствующего индексу `3`, вычисляется так: _начальный адрес + 3 \* 2_. Начальный адрес — это адрес ячейки памяти, начиная с которой располагается массив. Он формируется во время выделения памяти под массив. Ниже пример расчёта адресов памяти под разные элементы массива `numbers`:

```javascript
// Первый элемент
// Начальный адрес + 2 * 0 = начальный адрес
numbers[0]; // 19

// Начальный адрес + 2 * 1 = начальный адрес + 2
// То есть сместились на 2 байта
numbers[1]; // 10

// Начальный адрес + 2 * 2 = начальный адрес + 4
// То есть сместились на 4 байта
numbers[2]; // 8

// Последний элемент
// Начальный адрес + 2 * 4 = начальный адрес + 8
// То есть сместились на 8 байт
// И сам элемент занимает 2 байта. В сумме как раз 10
numbers[4]; // 9
```

Теперь должно быть понятно, почему индексы в массиве начинаются с нуля. 0 — означает отсутствие **смещения**.

Но не все данные имеют одинаковый размер. Как будет храниться массив строк? Строки ведь имеют разную длину, а значит требуют разное количество памяти для своего хранения. Один из способов сохранить строки в массиве на языке Си – создать массив массивов (тут нужно понимать, что любая строка в Си это массив символов). Вложенные массивы обязательно должны быть одного размера, невозможно обойти физические ограничения массивов. Хитрость в том, что этот размер должен быть достаточно большой, чтобы туда поместились необходимые строки.

```javascript
// Массив из трех элементов, внутри которого массивы по 10 элементов
// Это значит, что здесь можно хранить 3 строки длиной не больше 10 символов
char strings[3][10] = {
   "spike",
   "tom",
   "jerry"
};

strings[0]; // spike
```

#### Безопасность

В отличие от высокоуровневых языков, в которых код защищён от выхода за границу массива, в таком языке, как **Си**, выход за границу не приводит к ошибкам (на самом деле он может приводить к segfault, но это здесь не важно). Обращение к элементу, индекс которого находится за пределами массива, вернёт данные, которые лежат в той самой области памяти, куда его попросили обратиться (в соответствии с формулой выше). Чем они окажутся — никому не известно (но они будут проинтерпретированы в соответствии с типом массива. Если массив имеет тип int, то вернётся число). Выход за границу массива активно эксплуатируется хакерами для взлома программ.

### Массивы в динамических языках

В динамических языках, таких как JavaScript, устройство массивов значительно сложнее чем в си. Так как типы данных вычисляются автоматически во время выполнения кода. Массив в такой среде не может работать как в си. Неизвестно, данные каких типов окажутся внутри в процессе работы.

Массивы в таких языках содержат не сами данные, а ссылки (адреса в памяти) на них. Тогда становится не важно, что хранить. Любое значение в массиве – адрес, имеющий одинаковый размер независимо от данных, на которые он указывает. Такой подход делает массивы гибкими, но с другой стороны, более медленными.

Кроме того, массивы в динамических языках тоже динамические. То есть их размер может увеличиваться или уменьшаться в процессе работы программы. Технически это работает так: если ссылки (помним, что данные там не хранятся) в массив не помещаются, то интерпретатор внутри себя создает новый массив большего размера (обычно в два раза) и переносит все ссылки туда. Динамические массивы очень упрощают процесс разработки, но за это тоже приходится платить скоростью.

## Дополнительные материалы

### [JS: Массивы](https://ru.hexlet.io/courses/js-arrays)

1. [О курсе](https://ru.hexlet.io/courses/js-arrays/lessons/about/theory_unit)
   - [Массивы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)
2. [Синтаксис](https://ru.hexlet.io/courses/js-arrays/lessons/syntax/theory_unit)
   - [Документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)
3. [Модификация](https://ru.hexlet.io/courses/js-arrays/lessons/modification/theory_unit)
   - Без материалов
4. [Проверка существования значения](https://ru.hexlet.io/courses/js-arrays/lessons/isset/theory_unit)
   - Без материалов
5. [Цикл for](https://ru.hexlet.io/courses/js-arrays/lessons/for/theory_unit)
   - [Официальная документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for)
6. [Ссылки](https://ru.hexlet.io/courses/js-arrays/lessons/references/theory_unit)
   - [Продуманная оптимизация](http://optimization.guide/)
7. [Агрегация](https://ru.hexlet.io/courses/js-arrays/lessons/aggregation/theory_unit)
   - Без материалов
8. [Цикл for...of](https://ru.hexlet.io/courses/js-arrays/lessons/for-of/theory_unit)
   - [Официальная документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...of)
9. [Удаление элементов массива](https://ru.hexlet.io/courses/js-arrays/lessons/removing/theory_unit)
   - Без материалов
10. [Управляющие инструкции](https://ru.hexlet.io/courses/js-arrays/lessons/control-statements/theory_unit)
    - [Break](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/break)
    - [Continue](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/continue)
11. [Вложенные массивы](https://ru.hexlet.io/courses/js-arrays/lessons/nested-arrays/theory_unit)
    - [Метод массива includes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)
12. [Генерация строки в цикле](https://ru.hexlet.io/courses/js-arrays/lessons/build-strings/theory_unit)
    - [Джоэль Спольски. Назад к основам (английская версия)](https://www.joelonsoftware.com/2001/12/11/back-to-basics/)
13. [Обработка строк через преобразование в массив](https://ru.hexlet.io/courses/js-arrays/lessons/strings/theory_unit)
    - [Функция words (Lodash)](https://lodash.com/docs#words)
    - [Функция capitalize (Lodash)](https://lodash.com/docs#capitalize)
14. [Вложенные циклы](https://ru.hexlet.io/courses/js-arrays/lessons/nested-loops/theory_unit)
    - [Метод Array.isArray, проверяющий, является ли значение массивом](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
    - [Встроенный метод flat](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
    - [.flat() и .flatMap(): новые методы для работы с массивами в ECMAScript](https://ru.hexlet.io/blog/posts/flat-i-flatmap-novye-metody-dlya-raboty-s-massivami-v-ecmascript)
15. [Теория Множеств](https://ru.hexlet.io/courses/js-arrays/lessons/set-theory/theory_unit)
    - [Рассказы о множествах (pdf)](https://www.mccme.ru/free-books/vilenkin-rasomn.pdf)
    - [Встроенный метод includes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)
    - [Функция intersection из библиотеки Lodash](https://lodash.com/docs/#intersection)
    - [Функция union из библиотеки Lodash](https://lodash.com/docs/#union)
    - [Функция difference из библиотеки Lodash](https://lodash.com/docs/#difference)
16. [Сортировка массивов](https://ru.hexlet.io/courses/js-arrays/lessons/sorting/theory_unit)
    - [Сортировка средствами JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    - [Цикл do...while](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/do...while)
    - [Визуализация алгоритмов сортировок](https://visualgo.net/ru/sorting)
17. [Стек](https://ru.hexlet.io/courses/js-arrays/lessons/stack/theory_unit)
    - [метод push](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    - [метод pop](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
18. [Big O](https://ru.hexlet.io/courses/js-arrays/lessons/big-o/theory_unit)
    - [Big-O Cheat Sheet](https://bigocheatsheet.com/)
19. [Деструктуризация](https://ru.hexlet.io/courses/js-arrays/lessons/destructuring/theory_unit)
    - [Официальная документация](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring)
20. [Rest-оператор и деструктуризация](https://ru.hexlet.io/courses/js-arrays/lessons/rest-operator/theory_unit)
    - Без материалов
21. [Spread-оператор и создание новых массивов](https://ru.hexlet.io/courses/js-arrays/lessons/spread-operator/theory_unit)
    - Без материалов
22. [Массивы в памяти компьютера](https://ru.hexlet.io/courses/js-arrays/lessons/implementation/theory_unit)
    - Без материалов
