# О курсе—JS: Введение в ООП

Объектно-ориентированное программирование – большая и сложная тема, которая пронизывает всю разработку на JS. Ей посвящено сразу несколько курсов. Этот курс знакомит с базовыми концепциями и синтаксисом, немного затрагивает особенности JS, которые сильно выделяют его среди других ООП-языков. Остальные больше посвящены принципам построения программ в ООП стиле и, наконец, внутренностям самого JS, например, прототипам.

Эта часть курса содержит большое количество нового синтаксиса и терминов. Основные темы:

- Инкапсуляция
- Объекты
- Классы
- Сокрытие данных (Data hiding)
- Исключения

Данные темы крайне важны даже для начинающего разработчика на JS потому, что с этими понятиями он начинает сталкиваться буквально с первых дней на новой работе. С другой стороны, требуется немало времени перед тем, как вы сможете действительно качественно использовать изучаемые подходы и техники. К теме объектно-ориентированного программирования мы вернемся в наших курсах еще не раз и углубим не только наше понимание, но и разберемся вместе с его синтаксисом, например, конструкторами и прототипами.

# Что понимается под ООП—JS: Введение в ООП

_Осторожно, в этом уроке много терминов. Не пытайтесь их гуглить и разбираться. Задача урока показать творящуюся вакханалию и помочь отделить мух от котлет._

Что же такое ООП? Ответ, который наверняка встретится в сети первым, будет звучать так: наследование, полиморфизм и инкапсуляция. Если копнуть глубже, то кроме этих понятий всплывут "передача сообщений", "класс", "абстрактный класс", "прототипы", "интерфейсы", "диспетчеризация", "миксины", "протокол", "мультиметоды" (и еще сотня других страшных слов!). Причем в каждом языке есть свой набор таких сущностей, который встречается только в этом языке или в языках похожих на него. И каждый будет утверждать, что ООП не ООП без этих понятий.

Дальнейший поиск покажет, что в сети очень много статей на тему "я не понял ООП" (в таких статьях всегда обвиняют автора в том, что он не осилил) или вопросов "как понять ООП?". Под этими статьями, обычно, сотни комментариев, где обязательно разворачиваются жаркие споры о сути ООП. Среди этих споров обязательно появятся люди, которые скажут, что JS не ООП язык, ООП без классов не бывает, а кто-то скажет, что единственные ООП-языки это Smalltalk и Lisp. Один из самых классных примеров — это статья на Хабре [Я не знаю ООП](https://habr.com/ru/post/147927/). Под этой статьей 870! комментариев.

Ну а вишенка на торте, непрерывный поток статей в стиле "ООП для чайников", которые на примере животных (или кораблей, машин, чего угодно из реального мира) пытаются объяснить ООП, создавая у программистов ложную иллюзию того, что они поняли о чем идет речь. А потом эти программисты открывают код, а там адаптеры к базе данных и никакого реального мира.

![Иерархия в ООП](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImVlMjM1OTMzMTYxODMzODkzYTY4NDY3ZjZiNDM0NzhmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=0d196d7276ea59f8cf6b42bfdf8a4e61ba34e6dcbc7ae40569d847099200d740)

## Кто виноват и что делать?

У ООП долгая и непростая история. Сам термин ООП был придуман Аланом Кеем в конце семидесятых (и реализован в языке Smalltalk) и вот что он сказал по этому поводу:

> ООП для меня это сообщения, локальное удержание и защита, скрытие состояния и позднее связывание всего. Это можно сделать в Smalltalk и в LISP.
>
> Я считал объекты чем-то вроде биологических клеток, и/или отдельных компьютеров в сети, которые могут общаться только через сообщения.

_Забавно, но в каком-то смысле он предвидел интернет_

Затем появился язык C++, по мотивам которого была создана книга "Объектно-Ориентированный Анализ", где Гради Буч (известен, в том числе, созданием [UML](https://ru.wikipedia.org/wiki/UML)), описал то самое "полиморфизм, наследование и инкапсуляция". C++ стал мейнстримом и все последующие "ООП-языки" стали его копировать. Когда Алана спросили про ООП в C++, он сказал следующее:

> Когда я придумал ООП, я не имел в виду C++

С тех пор прошло много времени. Современное (не значит, что оно лучшее, это всего лишь текущее состояние дел) понимание ООП невероятно сильно отличается от того, что имел в виду Алан Кей. Это не значит, что его идеи умерли. Они живы, но иногда в других формах и на другом уровне. Хотя некоторые разработчики продолжают настаивать на том, что настоящее ООП — это ООП Алана, всё остальное — не настоящее. Мы не будем подробно останавливаться на этом. Главное запомнить – когда программисты начинают говорить про ООП, очень важно понимать, про какое ООП они говорят, иначе будут возникать споры и даже конфликты. ООП относится к "религиозным" темам.

Современное ООП — это не строгая обоснованная теория, в отличие от функционального или автоматного программирования. Это большой набор разнообразных подходов к организации кода и сущностей (классы, объекты и т.п.), которые иногда настолько сильно различаются в разных языках, что это приводит к совершенно удивительным ситуациям. Программисты на PHP приходят в ужас от того, что называется ООП в Ruby. Создатели Ruby, при этом, говорят, что Ruby — "настоящий" ООП язык, потому что в Ruby "всё есть объект". А Java-разработчики никогда не поверят, что в JavaScript ООП вообще присутствует.

В такой ситуации очень важно отсечь всё лишнее и найти те вещи, без которых программу назвать объектно-ориентированной не получится. Как говорят математики, найти базис (минимальный набор элементов, из которых можно вывести всё остальное).

ООП приписывается множество вещей, которые существовали и прекрасно существуют без ООП прямо сегодня во многих языках. Поэтому когда вы слышите про какие-то преимущества ООП, не воспринимайте эти слова за чистую монету. Эти преимущества, как правило, являются преимуществами только потому, что именно в этом языке по-другому сделать сложнее либо невозможно. Вы всегда можете найти язык, в котором эти же концепции решены очень элегантно и эффективно, но без классов и объектов.

Почему же тогда надо учить ООП? Именно этот подход стал доминировать в популярных языках. В JS, к счастью, достаточно сильная мультипарадигменность (то есть можно писать в разных стилях). То есть программы на JS могут легко комбинировать внутри себя разные стили, например, функциональный и ООП. В тех местах, где это оправдано, мы будем реализовывать код, используя разные стили. Тогда вам будет проще отделять суть задачи от способа ее решения. Вы научитесь выбирать нужное решение по ситуации, а не на основе заученного синтаксиса.

## Обучение

При изучении ООП нужно иметь в виду одну важную мысль. Ни один курс не способен разложить в голове по полочкам ООП от и до. Для этого нужны годы опыта, копание в плохих и хороших архитектурах, переписывание кода и, самое главное, постоянный анализ сделанного, только в таком случае будет происходить улучшение.

Хорошая новость состоит в том, что от новичка этого и не требуют. Достаточно знать общие понятия, некоторые особенности JS и синтаксис всех нужных конструкций. Остальное разрешится по мере накопления опыта. То, что дает Хекслет в курсах, это намного больше, чем нужно для трудоустройства.

Отдельно стоит сказать про JS. Количество особенностей поведения разных элементов, связанных с ООП, просто огромно. Хватит на несколько книг и, сюрприз, эти книги написаны. Они бесплатны и доступны на русском языке на гитхабе. В тех местах, где это уместно, вы сможете найти ссылки на главы этих книг в дополнительных материалах. Сами же курсы фокусируются на больших идеях, без копания в кишках. Иначе легко потерять нить повествования.

---

#### Дополнительные материалы

1. [Алан Кэй, создатель ООП, про разработку, Лисп и ООП](https://habr.com/ru/company/hexlet/blog/303754/)

# Инкапсуляция—JS: Введение в ООП

Из всего многообразия возможностей ООП, есть одна базовая, которая для большинства программистов ассоциируется с ООП. Она называется инкапсуляция. Инкапсуляция – это объединение функций и данных в рамках одной структуры, внутреннее состояние которой (данные) скрыто от внешнего мира (этот аспект мы разберем позже). Такие функции называют методами. Мы уже встречались с ними много раз и, как вы заметили, в JavaScript они используются повсеместно.

**Сложно**

Перед тем как мы начнем рассматривать инкапсуляцию подробнее, надо сделать небольшое отступление по поводу терминологии и путаницы в среде разработчиков. Это особенно важно, учитывая, что многие студенты уже приходят, начитавшись разной литературы. Если для вас пока сложно понять, что написано в следующем абзаце, то просто не обращайте внимания, вернитесь к нему в конце курса.

В большом числе источников под инкапсуляцией понимают сокрытие данных (data hiding) от прямого внешнего обращения (обычно с помощью ключевых слов private, protected). Более того, именно это определение захотят от вас услышать на собеседовании, но оно правильно лишь частично. Несмотря на то, что это распространенное определение, стоит разделять объединение данных с методами и сокрытие этих данных. Есть языки, например JavaScript и Python, в которых есть объединение данных, но нет сокрытия данных. Причем если в этих языках ввести сокрытие данных, то архитектура программ не изменится, а вот если разъединить данные и методы, то придется переписать практически весь код. Примерно такая же картина и с языками в которых есть сокрытие данных. Если его убрать, то мало что поменяется, кроме того, что разработчикам придется быть чуть аккуратнее при работе с объектами.

Подводя итог: инкапсуляция это и объединение, и сокрытие там, где оно есть. Там где его нет, это просто объединение. В этом курсе мы будем разделять инкапсуляцию (понимая под ней только объединение данных и функций) и сокрытие данных, чтобы иметь возможность обсуждать эти особенности независимо. Иначе бы возникла путаница с тем, что имеется в виду, когда упоминается термин инкапсуляция.

Зачем нужно сокрытие данных, разбирается в уроке про [инварианты](https://ru.hexlet.io/courses/js-data-abstraction/lessons/invariants/theory_unit)

**Конец Сложно :)**

```javascript
// Вызов метода
user.getName();

// Вызов функции
getName(user);
```

О том, как работают методы внутри, мы поговорим в следующем уроке. А сейчас рассмотрим внешние особенности методов.

Работа с методами вместо функций приводит к одному неожиданному эффекту – появляется возможность реализовать автодополнение методов в редакторах. Это снижает ментальную нагрузку и очень радует программистов. Существует теория, что именно эта особенность методов стала причиной такой популярности ООП (не подтвержденная, но вполне вероятная).

_В языках с развитой системой модулей автодополнение есть и при работе с обычными функциями. Но там в любом случае надо сначала написать правильное имя модуля. Пример из эликсира: User.getName(user). С другой стороны, существуют языки с Unified Function Call (например Nim), там обычные функции можно вызывать как методы и получать автодополнение._

Другая особенность достаточно противоречивая. Для многих разработчиков код с методами выглядит "естественнее". С их точки зрения, абстракции с помощью данных можно строить только на базе методов. Если не объединять данные и функции в одном месте, то абстракция невозможна. Такое восприятие возникает из-за ограниченного опыта. Как правило такой разработчик никогда не работал за пределами популярных ООП-языков и в его языке абстракции на функциях противоестественны и даже невозможны.

Это, конечно, не так. Достаточно пройти курс [JS: Абстракции с помощью данных](https://ru.hexlet.io/courses/js-data-abstraction), чтобы убедиться в этом. Абстракции и моделирование реального мира существуют не только в ООП. Они существовали до и будут существовать после.

_Попробуйте представить себе добавление в друзья в ООП-стиле. Кто кого должен добавить (первый друг второго или второй первого) и как не допустить рекурсии при взаимном добавлении?_

Третья особенность методов уже интереснее. Она действительно помогает сделать работу с кодом проще, а сам код короче. При работе с объектами нам не надо ничего дополнительно импортировать, как в случае с функциями. Любая функция, в которую был передан объект, может вызывать его методы так, как она хочет. Если бы мы работали с функциями, то нам бы пришлось дополнительно импортировать нужные функции. Эта особенность не дается бесплатно, она ограничивает расширение объектов (об этом в следующих уроках).

```javascript
// send просто функция, поэтому ее надо импортировать перед использованием
import send from "mail";

const sendEmail = (user) => {
  send("Subject", user.getEmail()); // Не надо импортировать getEmail потому что это метод
};
```

А что делать в том случае, когда объекта нет, как в примере выше? Разработчики языков и библиотек поступают по-разному. В JavaScript обычные функции и методы спокойно уживаются вместе. Примерно то же самое происходит в Python. В Ruby и PHP (в современных фреймворках) обычные функции выглядят уже не так естественно, хотя их по-прежнему можно создавать. В Java вообще нет возможности создавать обычные функции. Любая функция будет методом. Поэтому в Java объекты создают практически на каждый чих. Это значительно раздувает программу и усложняет реализацию простых вещей. Но есть и другие языки. В Elixir и Clojure методов в текущем понимании просто нет и самое главное, они там просто не нужны, а код при этом лаконичный, простой и расширяемый.

_Для имитации обычных функций в Java используют статические методы. Они позволяют работать без создания объектов._

Четвертая особенность – цепочки. Вспомните такой вызов:

```javascript
const brand = "bmw";
// Этот метод не изменяет строку, а возвращает новую!
brand.toUpperCase(); // BMW
```

Этот метод возвращает новую строку, у которой тоже есть методы, а значит их можно вызвать. Например:

```javascript
// Переменная, так как перезаписываем
let brand = "bmw";
brand = brand.toUpperCase(); // BMW
brand = brand.concat(" & Kia"); // BMW & Kia
brand = brand.replace("BMW", "Opel"); // Opel & Kia
console.log(brand); // => Opel & Kia
```

А теперь немного магии. Что если не создавать промежуточные переменные, а делать вызовы сразу? Пробуем:

```javascript
const brand = "bmw";
// Теперь лучше сделать новую константу, вместо переменной
const newBrand = brand.toUpperCase().concat(" & Kia").replace("BMW", "Opel");
console.log(newBrand); // => Opel & Kia
```

Код получился компактнее и в некоторых случаях он будет понятнее. Но не увлекайтесь, очень легко [перейти границу](https://ru.hexlet.io/blog/posts/sovershennyy-kod-zlye-odnostrochniki). Этот код всегда можно разбить на несколько строк:

```javascript
const brand = "bmw";
const newBrand = brand.toUpperCase().concat(" & Kia").replace("BMW", "Opel");
console.log(newBrand); // => Opel & Kia
```

Подобные цепочки можно строить, даже если возвращается значение другого типа. В таком случае можно применять методы соответствующего типа:

```javascript
const brand = "bmw";
const newBrand = brand
  .toUpperCase()
  .split("") // ['B', 'M', 'W']
  .reverse() // ['W', 'M', 'B']
  .join(""); // WMB
console.log(newBrand); // => WMB
```

У таких цепочек есть специальное имя: [fluent interface](https://en.wikipedia.org/wiki/Fluent_interface)

Как и практически все остальное в современном понимании ООП, цепочки не являются чем-то эксклюзивным. Более того, они повторяют такую вещь, как пайплайн (pipeline). Если вы знакомы с командной строкой, то скорее всего не раз видели такой код:

```javascript
# | называется пайпом (pipe - труба)
# Пайплайн часто сравнивают с бусинками (функции), через которые пропускают веревку (данные).
cat sample | grep -v a | sort -r
```

Эта цепочка команд последовательно передает данные слева направо, пропуская их сквозь разные обработчики. Сама концепция пришла из математики и появилась задолго до программирования. Во многих языках пайплайн реализован как языковая конструкция (либо макрос в Lisp). Это настолько удачная концепция, что сейчас её стараются интегрировать во многие языки. Например, она есть в F#, OCaml, Elixir, Elm, Julia, Hack. Прямо сейчас пайплайн находится в [стадии рассмотрения](https://github.com/tc39/proposal-pipeline-operator) в JavaScript. Посмотрите пример:

```javascript
// Так с функциями работать неудобно
const result = exclaim(capitalize(doubleSay("hello")));
console.log(result); // => "Hello, hello!"

// А вот это совсем другое дело (но нужно привыкнуть)
// |> – это пайп, он "отправляет" данные пришедшие слева в функцию справа
const result = "hello" |> doubleSay |> capitalize |> exclaim;

console.log(result); // => "Hello, hello!"
```

# Контекст (This)—JS: Введение в ООП

Что же такое методы? В JavaScript методами называют функции, записанные в свойства объектов. Фактически метод – это роль, которую выполняет функция будучи привязанной к объекту.

_В других языках другие определения и принципы работы_

В JavaScript функции это объекты первого рода, то есть они ведут себя как данные: их можно записывать в переменные или константы. Свойства объектов подобны переменным, а значит в них можно сохранить функции:

```javascript
const company = { name: "Hexlet" };
// Создание функции, которая сразу же присваивается свойству getName и становится методом
company.getName = () => "Hexlet"; // Функция возвращает строку "Hexlet"

// Вызов метода
company.getName(); // "Hexlet"
```

Это всего лишь один из множества возможных вариантов добавления функции в объект. Ниже еще несколько примеров:

```javascript
// При создании объекта
const obj = {
  getName: () => "Hexlet",
};

// Через присваивание константы
const company = { name: "Hexlet" };
// Имя константы не принципиально
const getHexlet = () => "Hexlet";
company.getName = getHexlet;

// Кстати никто не мешает вызывать функцию напрямую без объекта
getHexlet();
// Или даже так
const getName = company.getName;
getName(); // "Hexlet"
```

Все варианты выше эквивалентны. Они приводят к одному и тому же результату. Однако, смысла в таком результате мало. Метод возвращает строку и никак не использует данные объекта.

```javascript
const company = { name: "Hexlet" };
company.getName = () => "Hexlet";

company.getName(); // "Hexlet"
company.name = "Hexlet Plus";
// Имя поменяли, но возврат остался прежний
company.getName(); // "Hexlet"
```

Для доступа к данным объекта внутри метода используется новое ключевое слово `this`. Внутри методов оно ссылается на текущий объект, к которому привязан метод. Правда так `this` работает только для обычных функций. У стрелочных другой принцип. Это главное различие между стрелочными и обычными функциями, которое мы рассмотрим подробнее в одном из следующих уроков. А здесь, все дальнейшие примеры будут приводиться с использованием обычных именованных функций. Ранее мы их частично рассматривали в уроке [Способы записи функций](https://ru.hexlet.io/courses/introduction_to_programming/lessons/functions/theory_unit)

_this – одна из самых сложных и запутанных тем в JavaScript для новичков. Мало того, что он работает совсем не так как this в других языках, так еще и внутри самого JavaScript у него множество неочевидных вариантов поведения._

```javascript
const company = { name: "Hexlet", employees: [] };
// Методы, извлекающие данные из объекта называются геттерами
// Поэкспериментируйте со стрелочной функцией, убедитесь, что она работает по-другому
company.getName = function getName() {
  return this.name;
};

// Обязательно потренируйтесь на repl.it
company.getName(); // Hexlet

company.name = "Hexlet Plus";
company.getName(); // Hexlet Plus
```

`this` дает возможность не только читать данные, но и менять их:

```javascript
// Методы меняющие данные объекта называют сеттерами
company.setName = function setName(name) {
  this.name = name;
};

// Добавление нового сотрудника
company.addEmployee = function addEmployee(user) {
  // Важно, что на момент вызова, employees уже добавлен в company
  this.employees.push(user);
};

// Обязательно потренируйтесь на repl.it
company.getName(); // Hexlet

company.setName("Hexlet Plus");
company.getName(); // Hexlet Plus

const user = { name: "Petya" };
company.addEmployee(user);
company.employees; // [{ name: 'Petya' }]
```

Как видно из кода выше, свойства можно менять как напрямую так и из методов. Какой способ предпочесть – зависит от ситуации. Если в коде строится абстракция, то, вероятно, хорошим решением станут отдельные сеттеры, это, в том числе, важно для соблюдения инвариантов.

## Контекст

Выше, когда давалось определение `this`, говорилось, что `this` ссылается на текущий объект, к которому привязан метод. И здесь кроется ключевое отличие `this` в JavaScript от `this` в других языках. В JavaScript `this` у метода может измениться:

```javascript
const company1 = {
  name: "Hexlet",
  getName: function getName() {
    return this.name;
  },
};
const company2 = { name: "Hexlet Plus" };

company1.getName(); // "Hexlet"

// Копируется ссылка на функцию, а не сама функция
// Сама функция существует независимо от этих объектов
company2.getName = company1.getName;
company2.getName(); // "Hexlet Plus"
```

Что здесь произошло? Вызов функции из другого объекта привел к смене объекта, на который ссылается `this`. Эта особенность называется поздним связыванием. Значение `this` вычисляется не во время определения кода, а во время обращения к этому идентификатору.

Лучше всего можно понять эту особенность, познакомившись с тем, как вызываются функции внутри самого JavaScript и откуда там берется `this`. Так как в JavaScript функции это тоже объекты (сюрприз!), то у них есть свои методы. Среди них есть метод `call()`, который и используется для вызова:

```javascript
const sayHi = () => "Hi!";
sayHi.call(); // "Hi!"
```

Зачем так сделано? Дело в том, что первым параметром эта функция принимает контекст - объект, на который и будет ссылаться `this` внутри функции (и для этого ей не обязательно быть методом):

```javascript
const getName = function getName() {
  return this.name;
};

const company1 = { name: "Hexlet" };
getName.call(company1); // "Hexlet"

const company2 = { name: "Hexlet Plus" };
getName.call(company2); // "Hexlet Plus"
```

В этом и заключается весь секрет `this`. Это контекст, который JavaScript прокидывает автоматически в функцию, если она вызывается как метод. В этом случае можно точно сказать, к какому объекту она принадлежит.

Теперь, когда вы знаете как работает `this`, попробуйте ответить на вопрос, что будет выведено на экран?

```javascript
const company = {
  name: "Hexlet",
  country: {
    name: "Finland",
    getName: function getName() {
      return this.name;
    },
  },
};

console.log(company.country.getName()); // => ?
```

Правильный ответ: `"Finland"`. Почему? Потому что контекстом для метода `getName()` является объект `country`, а не `company`. Если немного модифицировать код, то понять эту идею станет проще:

```javascript
const { country } = company;
console.log(country.getName()); // "Finland"
```

## Сокращенное определение методов

Из-за необходимости использовать обычные функции при создании объектов в JavaScript был введен специальный сокращенный синтаксис создания методов при определении объектов:

```javascript
const company = {
  name: "Hexlet",
  getName() {
    return this.name;
  },
};
```

Такой способ – всего лишь "синтаксический сахар". Он позволяет сделать запись чуть короче, но не более того. Главное запомните – это обычная функция, а не стрелочная. В дальнейшем мы будем использовать именно такое определение.

---

#### Дополнительные материалы

1. [YDKJS: This](https://github.com/azat-io/you-dont-know-js-ru/blob/master/this %26 object prototypes/ch1.md)

# Связывание (bind)—JS: Введение в ООП

JavaScript — асинхронный язык программирования. Из-за этого функции часто вызываются как колбеки других функций. Особенно много этого в браузере, где колбек на колбеке и колбеком погоняет. Пока мы работали с простыми функциями, это не вызывало никаких затруднений, но все меняется при использовании методов.

_На этом этапе мы еще не работали с асинхронностью, но это не должно помешать понять идею. В двух словах: функция setTimeout принимает на вход функцию и время, после которого ее надо вызвать. Когда приходит время, она это делает. В общем-то и всё._

Попробуйте запустить такой код:

```javascript
const printer = {
  name: "Hexlet",
  print(greeting = "hello") {
    console.log(`${greeting}, ${this.name}`);
  },
};

// Прямой запуск
printer.print();

// Хотим запустить метод print через секунду
// Обязательно запустите этот код на своем компьютере
// чтобы почувствовать то как работает setTimeout
setTimeout(printer.print, 1000);
```

Этот код выдаст `hello, undefined`. Почему? Потому что внутрь `setTimeout()` мы передали не объект `printer`, а функцию `print()` без объекта. А значит эта функция потеряла связь с самим объектом и ее `this` больше не указывает на объект. Вот так можно проиллюстрировать то, что происходит:

```javascript
const print = printer.print;
// Где-то внутри setTimeout
print(); // hello, undefined
```

Если контекста нет, то `this` оказывается равным пустому объекту, если мы говорим про обычные функции.

Такое поведение часто нежелательно. Практически всегда, когда передается метод, подразумевается, что он будет вызван в контексте того объекта, которому он принадлежит. Существует несколько способов добиться такого поведения. Самый простой — обернуть функцию в функцию, пока мы вызываем функцию.

```javascript
setTimeout(() => printer.print(), 1000);
// hello, Hexlet

// Или без setTimeout
const fn = () => printer.print();
// Все работает потому что print() вызывается из printer
fn();
```

Это распространенное решение, которое заодно помогает захватить внешние переменные, когда они нужны для вызова:

```javascript
const value = "hi";
setTimeout(() => printer.print(value), 1000);
// hi, Hexlet
```

Другой способ — использование метода `bind()` (переводится как связать). Метод `bind()` доступен у функций, и в его задачу входит связывание функции с каким-то контекстом. Результатом выполнения `bind()` будет **новая функция**, работающая как и исходная функция, но с привязанным к ней контекстом.

```javascript
// Контекстом является тот же объект printer, в котором определен метод
// Это довольно странно выглядит, но жизнь — сложная штука
// bind вызывается на функции и возвращает функцию
const boundPrint = printer.print.bind(printer);

// Теперь можно так
boundPrint(); // hello, Hexlet
setTimeout(boundPrint, 1000);

// Можно вызывать bind прямо по месту
setTimeout(printer.print.bind(printer), 1000);
// hello, Hexlet
```

Связанная функция сливается со своим контекстом "намертво". Больше `this` не поменяется.

Кроме контекста, `bind()` принимает на вход параметры, которые нужны функции. Причем не сразу все, а любую их часть. `bind()` подставит их в новую функцию (ту, что вернется из метода `bind()`) "частично". Эта техника называется "частичное применение функции". Так можно сразу применить нужные аргументы:

```javascript
setTimeout(printer.print.bind(printer, "hi"), 1000);
// hi, Hexlet
```

Подход с `bind()` был популярен до появления стрелочных функций, сейчас его используют нечасто, и по возможности стоит его избегать. Стрелочные функции проще для понимания и используются повсеместно.

## Apply & Call

`bind()` полезен там, где привязка контекста и вызов функции происходят в разных местах и, как правило, в разное время. Однако нередко вызов происходит сразу вместе с привязкой. Это можно сделать напрямую, сразу же вызвав функцию, возвращаемую `bind`: `...bind(/* контекст */)()`, а можно использовать специально созданные для этого функции `apply()` и `call()`:

```javascript
// func.apply(thisArg, [ argsArray])
const print = printer.print;
print.apply(printer, ["hi"]); // hi, Hexlet

// func.call([thisArg[, arg1, arg2, ...argN]])
print.call(printer, "hi"); // hi, Hexlet
```

Эти функции внутри себя делают две вещи: меняют контекст и сразу же производят вызов функции. Разница лишь в том, как они работают с аргументами этих функций: `apply()` – принимает аргументы в виде массива вторым параметром, а `call()` ждёт на вход позиционные аргументы.

Эти функции позволяют делать довольно необычные вещи, например так:

```javascript
// Если контекста нет, то передают null
const numbers = [1, 10, 33, 9, 15];
const max = Math.max.apply(null, numbers); // 33
```

Вызов выше просто демонстрация, с практической точки зрения он мало полезен. Реальное использование `call()` и `apply()` проявляется в связке контекста с функциями из прототипов. Об этом поговорим в следующих уроках.

---

#### Дополнительные материалы

1. [Частичное применение](https://ru.hexlet.io/courses/js-functions-hard-way/lessons/partial-application/theory_unit)

# Особенности работы this со стрелочными функциями—JS: Введение в ООП

Стрелочные функции отличаются от обычных не только способом записи. Главное их отличие проявляется в том, как они работают с контекстом. Вкратце: контекст обычных функций зависит от места вызова, а контекст стрелочных функций — от того места, где они были определены.

Рассмотрим несколько примеров. Самый простой случай – определение функции на уровне модуля. В таком варианте, контекстом вызова будет сам модуль.

_Примечание: примеры ниже приведены для Node.js. В браузере `this` по умолчанию будет содержать глобальный объект `Window`._

```javascript
const f1 = () => {
  // стрелочная функция
  console.log(this);
};

f1(); // undefined

function f2() {
  // обычная функция
  console.log(this);
}

f2(); // undefined
```

Здесь поведение функций не отличается, так как контекстом вызова у обеих функций является сам модуль, а в es6 `this` у модулей не определен. Теперь попробуем добавить эти функции в объект:

```javascript
const obj = {
  f1,
  f2,
};

obj.f1(); // undefined
obj.f2(); // { f1: [Function: f1], f2: [Function: f2] }
```

Обычная функция ожидаемо связалась с контекстом того объекта, на котором она вызвана. А вот в случае стрелочной функции такого не произошло. Почему? Стрелочная функция не имеет своего контекста, она связывается с лексическим окружением, то есть функцией, внутри которой определена стрелочная функция. Это очень важный момент. Именно функция верхнего уровня задаёт контекст стрелочной функции, а не что-то другое. И это поведение нельзя изменить с помощью функций `call` или `bind`.

```javascript
f1.call({ name: "hexlet" }); // undefined
f1.bind({ name: "hexlet" })(); // undefined
```

Теперь определим стрелочную функцию внутри какого-нибудь объекта и попробуем вызвать:

```javascript
const company = {
  f1: () => {
    // стрелочная функция
    console.log(this);
  },
  f2() {
    // обычная функция
    console.log(this);
  },
};

company.f1(); // undefined
company.f2(); // { f1: [Function: f1], f2: [Function: f2] }
```

Здесь мы видим точно такую же картину. Несмотря на то, что стрелочная функция описывается внутри объекта и вызывается из этого же объекта, контекст все равно связан с местом определения функции (лексическим окружением) – а это сам модуль.

Теперь попробуем определить стрелочную функцию внутри другой функции:

```javascript
const printer = {
  items: [1],
  print() {
    // важно что внешняя функция имеет контекст
    // Стрелочная функция определяется внутри функции print,
    // но вызывается внутри метода forEach
    this.items.forEach(() => console.log(this.items));
  },
};

printer.print(); // [1]
```

Кажется, что у стрелочной функции появился `this`, но этот контекст не принадлежит функции, она заимствовала его у внешней функции `print`. Чтобы лучше это понять, представьте как вызывается стрелочная функция внутри `forEach`. Она вызывается напрямую, а не из объекта. Обычные функции в такой ситуации теряют контекст, а стрелочная сохранила его, потому что это не ее контекст, а контекст места определения, то есть функции `print`.

Точно такой же код с обычной функцией уже не заработает:

```javascript
const printer = {
  items: [1],
  print() {
    this.items.forEach(function () {
      console.log(this.items);
    });
  },
};

printer.print(); // undefined
```

Это происходит именно потому, что функция вызывается как обычная функция, а не метод. В таком случае ее контекст равен пустому объекту, а значит `this.items` вернет `undefined`.

Где все это может понадобиться? В подавляющем большинстве ситуаций нам вообще не нужен `this` внутри стрелочной функции. Всегда лучше работать с данными, переданными явно. Однако есть несколько примеров, где эта особенность стрелочных функций помогает упростить код. К таким примерам относятся ситуации, где внутри метода объекта вызывается функция высшего порядка, куда передается стрелочная функция, работающая с `this`. Эта ситуация аналогичная коду выше.

# Конструктор—JS: Введение в ООП

Приложения на JavaScript во время своей работы создают и удаляют множество объектов. Иногда эти объекты совсем разные, а иногда они относятся к одному понятию, но отличаются данными. Когда речь идет про понятия предметной области (или, как говорят, сущности), то важно иметь абстракцию, которая скроет от нас структуру этого объекта.

Возьмем понятие "компания" и построим абстракцию вокруг него без использования инкапсуляции:

```javascript
// Реальное устройство будет значительно сложнее
// файл: company.js

// Конструктор (в общем смысле этого слова)
const make = (name, website) => {
  return { name, website };
};

// Селекторы
const getName = (company) => company.name;
const getWebsite = (company) => company.website;
```

Теперь использование:

```javascript
import { make, getName } from "./company.js";

const company = make("Hexlet", "https://hexlet.io");
console.log(getName(company)); // Hexlet
```

Такая абстракция упрощает работу с компаниями (особенно при изменениях структуры), прячет детали реализации и делает код более "человечным". Попробуем сделать то же самое, используя инкапсуляцию:

```javascript
// Реальное устройство будет значительно сложнее
// файл: company.js

const make = (name, website) => {
  return {
    name,
    website,
    getName() {
      return this.name;
    },
    getWebsite() {
      return this.website;
    },
  };
};
```

И использование:

```javascript
import { make } from "./company.js";

const company = make("Hexlet", "https://hexlet.io");
console.log(company.getName()); // Hexlet
```

Здесь мы видим несколько удобных моментов по сравнению с вариантом на функциях:

- Нам больше не надо импортировать `getName`, он уже содержится внутри компании.
- Можно пользоваться автодополнением кода.

Но вместе с плюсами пришли и минусы. Посмотрите еще раз внимательно на код конструктора. Каждый его вызов возвращает новый объект и это ожидаемое поведение, но чего мы точно не хотим, так это создания методов на каждый вызов конструктора (а они будут создаваться при каждом создании объекта). Методы, в отличие от обычных данных, не меняются. Нет никакого смысла создавать их на каждый вызов заново, расходуя память и процессорное время.

Перепишем наш пример, избежав постоянного создания методов:

```javascript
// Не забываем что нам нужны обычные, а не стрелочные функции!

function getName() {
  return this.name;
}

function getWebsite() {
  return this.website;
}

// С точки зрения использования ничего не поменялось, но зато перестали копироваться функции.
const make = (name, website) => {
  return {
    name,
    website,
    getName,
    getWebsite,
  };
};
```

## Оператор new

Все описанные выше способы создания объектов имеют право на существование и используются в реальной жизни, но в JavaScript есть встроенная поддержка генерации объектов. Перепишем наш пример с помощью функции-конструктора.

```javascript
// Такую функцию принято называть конструктором (хотя технически это обычная функция с контекстом)
// Конструкторы пишутся с заглавной буквы
function Company(name, website) {
  this.name = name;
  this.website = website;
  // Методы по прежнему определены снаружи как обычные функции
  this.getName = getName;
  this.getWebsite = getWebsite;
}
```

Теперь использование:

```javascript
const company = new Company("Hexlet", "https://hexlet.io");
console.log(company.getName()); // Hexlet
```

Самое интересное в этом примере – оператор `new` (как и многое в js, он работает не так как `new` в других языках). Фактически он создает объект, устанавливает его как контекст во время вызова конструктора (в данном случае `Company`) и возвращает созданный объект. Именно поэтому сам конструктор ничего не возвращает (хотя может, но это другой разговор), а внутри константы `company` оказывается нужный нам объект.

```javascript
// Упрощенная иллюстрация работы new внутри интерпретатора при таком вызове:
// new Company();

const obj = {};
Company.bind(obj)(name, website); // этот вызов просто наполнил this (равный obj) нужными данными
return obj;
```

Визуально этот способ выглядит не лучше чем предыдущее ручное создание, но он задействует еще один важный механизм в JavaScript – прототипы (Подробнее о них в следующем уроке).

Все типы данных в JavaScript, которые могут быть представлены объектами (или являются объектами внутри себя, например, функции), имеют встроенные конструкторы. Иногда они заменяют специальный синтаксис создания данных (как в случае с массивами), а иногда это единственный способ создать данные этого типа (как в случае с датами):

```javascript
// Специальный синтаксис создания массивов
// Массивы это объекты, вспомните свойство length
const numbers = [10, 3, -3, 0]; // литерал

// Объектный способ создания через конструктор
// Результат ниже эквивалентен тому что происходит выше
const numbers = new Array(10, 3, -3, 0);

// У дат нет литералов, они создаются как объекты
const date = new Date("December 17, 1995 03:24:00");
// У дат очень много методов
date.getMonth(); // 11, в JS месяцы нумеруются с нуля

// Так можно создавать даже функции
// Последний аргумент это тело, все предыдущие – аргументы
const sum = new Function("a", "b", "return a + b");
sum(2, 6); // 8
```

Но не все функции могут быть конструкторами. Отсутствие своего контекста делает невозможным использование оператора `new` вместе со стрелочными функциями:

```javascript
const f = () => {};
// TypeError: function is not a constructor
const obj = new f();
```

---

#### Дополнительные материалы

1. [Natives](https://github.com/getify/You-Dont-Know-JS/blob/9959fc904d584bbf0b02cf41c192f74ff4238581/types-grammar/ch3.md#you-dont-know-js-yet-types--grammar---2nd-edition)

# Прототипы—JS: Введение в ООП

_В этом уроке дается небольшое введение в тему прототипов. Полностью раскрыть её одним уроком невозможно. Не хватит даже целого курса. Прототипы познаются только через практику, перемешанную с теоретической подготовкой. Поэтому не переживайте, если не всё поймёте с первого раза, это нормально._

Прототипы — это механизм, который оказывает основное влияние на то, как работают объекты в JavaScript. Сами они напрямую в коде используются редко (и обычно только в библиотеках), но их знание важно для понимания поведения кода и отладки. Особенно при работе с классами, которые мы изучим дальше по курсу. В этом уроке мы затронем только самые основы. Глубоко разобраться с прототипами поможет наш курс, указанный в дополнительных материалах.

В JavaScript с каждым объектом связан прототип. Прототип – это обычный объект, хранящийся в специальном служебном поле `[[prototype]]` (к этому полю невозможно обратиться напрямую). Его можно извлечь так:

```javascript
const date = new Date();
// Эта функция извлекает прототип объекта из самого объекта
Object.getPrototypeOf(date); // Date {}

// В прототипе хранится не конструктор
// Что там хранится – узнаем дальше
Object.getPrototypeOf(date) === Date; // false

const numbers = [1, 2];
Object.getPrototypeOf(numbers); // [] – отображение отличается, но это массив

// Прототипы есть и у конструкторов, которые мы определяем сами
function Company(name) {
  this.name = name;
}

const company = new Company();
Object.getPrototypeOf(company); // Company {}
```

Зачем он нужен? Чтобы ответить на этот вопрос, нужно разобраться с тем, как в JavaScript работает вызов свойств. До этого момента все было просто: если в объекте есть свойство, то его можно вызывать и получить значение, если свойства нет, то при обращении к нему мы получим `undefined`. Это правда, но не вся. JavaScript устроен хитрее и ищет свойство не только в самом объекте. Если свойство для объекта не определено, то JavaScript смотрит в прототип и пытается выяснить есть ли это свойство у него. Если есть, то возвращается его значение.

_В реальности процесс ещё сложнее. Если свойство не найдено в прототипе, то JavaScript смотрит прототип прототипа и так далее до конца цепочки, а у неё есть конец: последний прототип в цепочке прототипов всегда null. На базе этого механизма реализуется наследование. Эта тема выходит за рамки текущего урока._

Прототип есть даже у обычных JavaScript-объектов:

```javascript
Object.getPrototypeOf({}); // {} – это и есть Object
```

Именно по этой причине даже пустые объекты "содержат" (помним, что их содержит прототип) свойства и методы:

```javascript
const obj = {}; // То же самое можно сделать так: const obj = new Object();
// Это функция-конструктор из которой был получен текущий объект, в данном случае Object
obj.constructor; // [Function: Object]
// У obj нет своего собственного свойства constructor, оно пришло из прототипа
Object.hasOwn(obj, "constructor"); // false
Object.hasOwn(obj, "name"); // false
obj.name = "hexlet";
// Имя есть в самом объекте, потому что мы его только что добавили
Object.hasOwn(obj, "name"); // true
```

Доступ к прототипу можно получить не только из объектов, но и из свойства `prototype` конструктора, который эти объекты создаёт:

```javascript
function Company(name) {
  this.name = name;
}

// Одно и то же, полученное разными способами
// Company.prototype === Object.getPrototypeOf(new Company())
```

Теперь мы можем ответить на вопрос "откуда берется прототип?". Прототип – это объект, находящийся в свойстве `prototype` функции-конструктора, а не сам конструктор. Проверить работу прототипов достаточно легко, изменив их.

```javascript
// Добавляем свойство getName (делаем его методом)
Company.prototype.getName = function getName() {
  // this по-прежнему зависит от контекста, в котором вызывается
  return this.name;
};

const company = new Company("Hexlet");
// Свойство доступно!
console.log(company.getName()); // => Hexlet
```

При этом никто не мешает заменить значение свойства `getName` в конкретном объекте. Это никаким образом не отразится на других объектах, так как они извлекают `getName` из прототипа:

```javascript
const company1 = new Company("Hexlet");
const company2 = new Company("Google");
company2.getName = function getName() {
  return "Alphabet";
};

// Этот вызов возьмет свойство из самого объекта
company2.getName(); // Alphabet
// Этот вызов возьмет значение свойства из прототипа
company1.getName(); // Hexlet
```

Создание свойств через прототип – и есть правильный способ создания своих абстракций в JavaScript. Любая новая абстракция, которая нам нужна в коде, должна выглядеть как конструктор и прототип, наполненный нужными свойствами.

Что даёт этот механизм?

Самое простое – расширение ядра языка и библиотек без прямого доступа к исходному коду. Прототипы – невероятно гибкий механизм, который позволяет менять всё что угодно из любого места программы (в рантайме, то есть во время работы). Например, мы можем добавить или заменить любые методы в любых объектах самого языка.

```javascript
const numbers1 = [1, 3];

// Как только выполнится этот код, все массивы,
// включая уже созданные, обзаведутся методом last
Array.prototype.last = function last() {
  // Такое обращение законно, ведь this это ссылка на сам объект,
  // который в нашем случае массив
  return this[this.length - 1];
};

numbers1.last(); // 3

const numbers2 = [10, 0, -2];
numbers2.last(); // -2

// Пример замены
// запрещенный прием, никогда так не делайте в реальном коде
Array.prototype.map = function map() {
  return "Ehu!";
};

numbers1.map(); // "Ehu!"
```

Как и любой другой мощный механизм, прототипы невероятно опасны. Можно наменять такого, что программирование превратится в ад.

```javascript
// Очень злой код, который ломает работу метода push
Array.prototype.push = function push(value) {
  return this.unshift(value);
};

const numbers = [1, 2];
numbers.push(3);
console.log(numbers); // => [3, 1, 2] !!!
```

Но если использовать этот механизм с умом, то можно получить очень много хорошего. Например, прототипы активно используются в [тестировании](https://github.com/nock/nock), они помогают подменить вызовы нежелательных методов, которые выполняют HTTP-запросы. Другой популярный вариант – [полифилы](https://ru.hexlet.io/courses/js-dom/lessons/polyfills/theory_unit). Это код, который добавляет в старые версии JavaScript возможности из новых версий, но не все, конечно — только те, что появляются в виде свойств и методов.

P.S. Теперь вы знаете, почему в документации все имена функций описаны так: `Number.prototype.toLocaleString()`.

---

#### Дополнительные материалы

1. [JS: Прототипы](https://ru.hexlet.io/courses/js_prototypes)

# Упаковка и Распаковка (Boxing)—JS: Введение в ООП

Методы – это свойства объектов, в которые записаны функции. Если это так, тогда почему работает такой код:

```javascript
"hexlet".toUpperCase(); // "HEXLET"
```

Из этого кода можно сделать ошибочный вывод что строка это тоже объект, но это не так. В JavaScript строки, логические значения, null и числа реализованы как примитивные значения, у них нет методов. С другой стороны, для каждого такого типа существует собственный конструктор, "упаковывающий" примитивный тип в объект:

```javascript
typeof "hexlet"; // "string"
const name = new String("hexlet");
typeof name; // "object"
console.log(name); // "hexlet"
```

JavaScript автоматически упаковывает примитивные типы в соответствующие объекты, когда встречает вызовы методов на них (и затем автоматически распаковывает). То есть в действительности, все методы которые мы вызываем на строках, хранятся в прототипе конструктора `String`. То же самое касается и всех остальных типов:

```javascript
// Ручная упаковка примитивных значений
const number = new Number(1);
number.toString(); // "1"
const bool = new Boolean(true);
bool.toString(); // "true"

// Автоматическая упаковка
const one = 1;
// Во время вызова происходит упаковка
one.toString(); // "1"
// Обратите внимание что, такой код завершится с ошибкой:
// 1.toString();
// js ожидает, что после точки будет продолжение числа
// А вот так заработает (1).toString();

const yes = true;
// Во время вызова происходит упаковка
yes.toString(); // "true"
```

Интересно то, как происходит распаковка. Для этого JavaScript автоматически вызывает метод `valueOf()` у объекта:

```javascript
const number = new Number(100);
// Его можно вызвать самостоятельно
number.valueOf(); // 100

// А еще он вызывается в результате разных операций над объектом
const newName = `${number} is a big number`; // "100 is a big number!"
```

В отличие от упаковки, распаковка выполняется абсолютно для всех объектов. Это позволяет определять `valueOf()` самостоятельно:

```javascript
const words = ["Hello"];
const helloBuilder = (string) => words.push(string);
const build = () => words.join(" ");

helloBuilder.valueOf = () => build();

helloBuilder("from");
helloBuilder("valueOf");

console.log(helloBuilder == "Hello from valueOf"); // true
```

Подобным пользуются разные библиотеки, например [moment.js](https://momentjs.com/) для конвертации даты (как объекта) в значение (timestamp):

```javascript
const date = moment(); // возвращает объект описывающий текущую дату
// с этой датой можно делать всякое
date.startOf("day").fromNow(); // "a day ago"

// Хитрость в том, что оператор `+` приводит к распаковке
// valueOf возвращает текущий timestamp
+date; // 1578624487377
```

Хотя это работает, такой подход не приветствуется многими разработчиками. Это больше похоже на хак, чем на хороший код.

---

#### Дополнительные материалы

1. [Документация по valueOf на MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)
2. [Boxing Wrappers](https://github.com/getify/You-Dont-Know-JS/blob/9959fc904d584bbf0b02cf41c192f74ff4238581/types-grammar/ch3.md#boxing-wrappers)

# toString()—JS: Введение в ООП

В прототипе объектов JavaScript есть один "магический метод" `Object.prototype.toString()`. Магический он потому, что он вызывается автоматически в тех местах, где объект используется как строка. Такое регулярно происходит во время разработки, мы все видели надписи наподобие этой: `'[object Object]'`.

_Подобный механизм есть практически в любом языке программирования. Часто даже с такой же реализацией._

```javascript
const company = { name: "Hexlet" };
company.toString(); // "[object Object]"
console.log(`I love ${company}!`); // "I love [object Object]!"
```

Такой вывод скорее раздражает, чем приносит пользу. Для чего же он нужен? Сам по себе `toString()` не является чем-то особенным, это обычный метод в прототипе. А раз так, то мы можем переопределить его:

```javascript
const company = {
  name: "Hexlet",
  toString() {
    return this.name;
  },
};

company.toString(); // "Hexlet"
console.log(`I love ${company}!`); // "I love Hexlet!"
```

То же самое можно сделать и в прототипе любого конструктора:

```javascript
function Company(name) {
  this.name = name;
}

Company.prototype.toString = function toString() {
  return this.name;
};

const company = new Company("Hexlet");
console.log(`I love ${company}!`); // "I love Hexlet!"
```

Этот метод крайне популярен и полезен в шаблонах, формирующих, например, HTML. Он позволяет сократить повторяющийся код и сделать его чище.

Но что делать, если нужно вывести объект "как есть"? Такое бывает нужно для анализа внутренней структуры. Если у этого объекта не определен `toString()`, то мы получим максимально неинформативный вывод `[object Object]`. В таком случае можно конвертировать объект в JSON:

```javascript
const company = new Company("Hexlet");
// JSON – это строка!
console.log(JSON.stringify(company)); // => '{"name":"Hexlet"}'
```

# Класс—JS: Введение в ООП

Прототипы, с одной стороны, мощный механизм, с другой — он низкоуровневый. Другими словами, при использовании прототипов придется писать довольно много однообразного кода, особенно для реализации цепочек. По этой причине разработчики JavaScript внедрили в язык понятие Класс, как более привычное и понятное для большинства разработчиков. С появлением классов программировать на JavaScript стало действительно проще, но классы в JavaScript имеют очень серьезные отличия от классов многих других языков. Начнем с примера. Ниже код обычной абстракции на JavaScript:

```javascript
function Company(name, email) {
  this.name = name;
  this.email = email;
}

Company.prototype.getName = function getName() {
  return this.name;
};

Company.prototype.getEmail = function getEmail() {
  return this.email;
};

Company.prototype.setEmail = function setEmail(email) {
  this.email = email;
};

const company = new Company("Hexlet");
console.log(company.getName()); // => "Hexlet"
```

Этот код можно представить классом:

```javascript
// Каждый класс должен лежать в своем собственном файле
// Идеально если имя класса совпадает с именем файла с учетом регистра
class Company {
  // имя класса - это имя функции конструктора
  // Метод с именем constructor соответствует функции-конструктору
  // Он вызывается, когда мы делаем new Company(name, email)
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // Это свойство getName с записанной в него обычной (function) функцией
  getName() {
    return this.name;
  }

  getEmail() {
    return this.email;
  }

  setEmail(email) {
    this.email = email;
  }
}

// С точки зрения использования не меняется ничего
const company = new Company("Hexlet", "support@hexlet.io"); // вызывается метод constructor
console.log(company.getName()); // => "Hexlet"
```

Метод, соответствующий функции-конструктору внутри класса, называется `constructor`. Интерпретатор вызывает его автоматически при создании нового объекта через `new`. Если конструктор отсутствует – то ничего страшного не произойдет. Это равносильно созданию и вызову пустой функции-конструктора:

```javascript
function Company() {}

const company = new Company();
```

Классы повышают уровень абстракции и дают разработчикам инструмент, к которому они привыкли в других языках. Они действительно позволяют не задумываться о прототипах, лежащих в их основе. По крайней мере, пока речь идет о написании прикладного кода. А вот во время отладки без знания прототипов не обойтись. Кроме того, они иногда напрямую используются в библиотеках, потому что позволяют сделать вещи, которые нельзя сделать с помощью классов.

## Свойства

В объектах встречаются свойства, имеющие значения по умолчанию. Например, у компании могут быть сотрудники. Если в компанию не был добавлен ни один сотрудник, то метод, возвращающий список сотрудников, должен вернуть пустой массив. Если он этого не сделает, то это сильно усложнит разработку, так как везде придется делать проверки на существование:

```javascript
const company = new Company();
company.getEmployees(); // []
```

Как этого добиться? Без классов это делается прямо внутри функции-конструктора:

```javascript
function Company() {
  this.employees = [];
}
```

Так же поступают и в классах:

```javascript
class Company {
  constructor() {
    this.employees = [];
  }
  // остальные методы
}
```

Однако есть другой способ. Он популярен в других языках, но в JavaScript его только начинают использовать. Этот способ основан на новом синтаксисе (находится в процессе включения в стандарт и пока работает только через специальный плагин Babel) определения свойств внутри класса:

```javascript
class Company {
  employees = [];
}
```

Такое определение инициализирует свойство для каждого объекта индивидуально, как и в примерах выше. Сейчас все чаще и чаще можно увидеть подобный код.

## Подводные камни

Классы в JavaScript не статичны, как это сделано во многих языках, где один раз определив класс, вы больше не можете его менять. Мы по-прежнему работаем с прототипами и функциями, выполняющими роль конструкторов. Мы можем написать такой код после того, как класс был определен:

```javascript
// В любом месте программы после определения класса
Company.prototype.greeting = function greeting() {
  return `Hello, ${this.name}!`;
};

const company = new Company("Hexlet");
console.log(company.greeting()); // => "Hello, Hexlet!"
```

## Как правильно использовать классы?

Стоит начать с того, что классы в JavaScript нужны далеко не всегда. JavaScript — мощный язык программирования, который не заставляет использовать одну парадигму программирования (в отличие от Java, например). С его помощью просто делать простые вещи и при необходимости применять сложные концепции для сложных вещей.

ООП в принципе и классы в частности – сложные концепции, которые невозможно выучить заранее по курсам, видео и статьям. Единственный способ разобраться – писать продакшен код, совершать ошибки и исправлять их (за счет советов более опытных разработчиков).

Существует миф о том, что классы нужны для моделирования реального мира. С их помощью такое действительно делают (даже в коде выше у нас есть компания), но это очень узкое понимание назначения классов. В жизни их используют для совершенно разных целей. В коде сложных приложений могут быть сотни и тысячи классов, большая часть из которых не имеет никакой связи с реальным миром (адаптеры к базе данных, разные стратегии кеширования). В следующих курсах, посвященных ООП, мы погрузимся глубже в то, как проектировать классы и в каких ситуациях их вводить.

---

#### Дополнительные материалы

1. [@babel/plugin-proposal-class-properties](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties)

# Статические свойства и методы—JS: Введение в ООП

В одном из предыдущих уроков мы реализовывали конструктор денег (Money). Вспомним его интерфейс:

```javascript
const money1 = new Money(100);
money1.getValue(); // 100
money1.format(); // "$100"
// Не меняет сам money1
money1.exchangeTo("eur").getValue(); // 70

const money2 = new Money(200, "eur");
const money3 = money2.add(money1); // 270
```

Количество денег и их валюта являются частью конкретного объекта, но что насчет ставок? Ниже пример возможной реализации конструктора:

```javascript
class Money {
  constructor() {
    this.rates = {
      usd: {
        eur: 0.7,
      },
      eur: {
        usd: 1.2,
      },
    };
  }
}
```

При таком определении класса каждый вновь созданный объект получит свою собственную копию информации о ставках конвертирования. Технически этот код работает, но логически он неверен. Ставки не имеют отношения к конкретному объекту Money, они определяют поведение всех денег. Представьте, что нам понадобилось бы расширить количество валют или поменять ставки во время работы программы. Такое возможно, если ставки вычисляются динамически, как это и происходит в реальной жизни. Это значит, что всё должно поменяться без остановки программы. Из-за привязки этих параметров к каждому объекту индивидуально, пришлось бы пересоздавать все объекты или перезапускать программу.

Для решения этой задачи используют функции-конструкторы. Любая функция в JavaScript является объектом, а любое свойство, добавленное в функцию-конструктор, доступно во всех его объектах:

```javascript
// Не важно как определен сам Money. Это может быть обычная функция-конструктор или класс.
// Так или иначе любой класс внутри JS — это функция конструктор + прототип, наполненный функциями

Money.rates = {
  usd: {
    eur: 0.7,
  },
  eur: {
    usd: 1.2,
  },
};
```

Обращение к свойству конструктора отличается от вызова обычных свойств самого объекта. Есть два основных способа. Первый – напрямую через функцию-конструктор `Money.rates`. Так проще всего, но тогда приходится дублировать имя функции-конструктора. Второй – через свойство `constructor`. Это специальное свойство, которое дает прямой доступ к конструктору из объектов. Именно этот способ является предпочтительным, когда мы находимся внутри объекта:

```javascript
class Money {
  constructor(value, currency = "usd") {
    this.value = value;
    this.currency = currency;
  }

  exchangeTo(newCurrency) {
    if (this.currency === newCurrency) {
      return new Money(this.value, this.currency);
    }
    // this.constructor.rates находится в функции-конструкторе
    const newValue =
      this.value * this.constructor.rates[this.currency][newCurrency];
    return new Money(newValue, newCurrency);
  }

  // Другие методы
}
```

Таким подходом мы разделили ответственности. Сам объект Money отвечает только за свои данные. За общие вещи отвечает конструктор. Это позволяет изменять параметры Money сразу для всех объектов:

```javascript
Money.rates.usd.eur = 0.71;
```

Можно пойти еще дальше и обновлять данные не напрямую, а через методы:

```javascript
Money.setRate = function setRate(from, to, value) {
  // Здесь уже обращаемся напрямую, потому что мы находимся в контексте объекта Money (она же функция-конструктор)
  this.rates[from][to] = value;
};

Money.setRate("gbp", "usd", 0.6);
```

Но будьте осторожны. Всё, что лежит в функции-конструкторе, фактически стало глобальным состоянием. Любое изменение отражается на всех объектах сразу. Иногда это может быть хорошо, как в нашем случае, но в других случаях это может приводить к рассинхронизации данных. Особенно в тех ситуациях, когда процессы разделены во времени (асинхронный код).

## Статика

Подобная функциональность реализуется с помощью статических свойств и методов. Вот как это выглядит:

```javascript
class Money {
  // Определение статического свойства
  static rates = {
    usd: {
      eur: 0.7,
    },
    eur: {
      usd: 1.2,
    },
  };

  // Определение статического метода
  static setRate(from, to, value) {
    this.rates[from][to] = value;
  }
}

// Использование ровно такое же как и в примерах выше
Money.rates.usd.eur; // 0.7
Money.setRate("usd", "eur", 0.8);
Money.rates.usd.eur; // 0.8

// Изнутри объектов обращаться можно через this.constructor;
```

Статика, как и классы – всего лишь сахар над функциями. Но они становятся популярны, так как позволяют сделать код чище.

---

#### Дополнительные материалы

1. [Статические свойства / MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/Class_fields#Публичные_поля)
2. [Статические методы / MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static)

# Исключения—JS: Введение в ООП

Отдельная большая тема в программировании – обработка ошибок. До сих пор нам удавалось избегать её, но в реальном мире, где приложения содержат тысячи, десятки и сотни тысяч (а то и все миллионы) строк кода, обработка ошибок влияет на многое: простоту модификации и расширения, адекватное поведение программы для пользователя в разных ситуациях.

В этом уроке мы рассмотрим механизм исключений. Но перед тем, как изучать новые конструкции, поговорим про ошибки вообще.

В JavaScript у строк есть метод, который называется `text.indexOf(str)`. Он ищет подстроку `str` внутри текста `text` и возвращает индекс начала этой подстроки в тексте. Что произойдёт, если подстрока не была найдена? Является ли это поведение ошибкой? Нет. Это штатное поведение функции. От того, что подстрока не была найдена, ничего страшного не случилось. Представьте себе любой редактор текста и механизм поиска внутри него. Ситуация, когда ничего не было найдено, возникает постоянно, и это не ломает работу программы.

_Кстати, посмотрите в документацию этой функции, каким образом она говорит о том, что подстрока не была найдена?_

Другая ситуация. В тех же редакторах есть функция "открыть файл". Представьте, что во время открытия файла что-то пошло не так, например, его удалили. А это ошибка или нет? Да, в этой ситуации произошла ошибка, но это не ошибка программирования. Подобная ошибка может возникнуть всегда, независимо от желания программиста. Он не может избежать её появления. Единственное, что он может — правильно реализовать её обработку.

Ещё один интересный вопрос, насколько это критичная ошибка? Должна ли она приводить к остановке всего приложения или нет? В плохо написанных приложениях, там где неправильно реализована обработка ошибок, такая ситуация приведёт к краху всего приложения, и оно завершится. В хорошо написанном приложении не произойдёт ничего страшного. Пользователь увидит предупреждение о том, что файл не читается, и сможет выбрать дальнейшие действия, например, попытаться прочитать его снова или выполнить другое действие.

Сказанное выше имеет очень серьёзные следствия. Одна и та же ситуация на разных уровнях может как являться ошибкой, так и быть вполне штатной ситуацией. Например, если задача функции читать файл, а она не смогла этого сделать, то с точки зрения этой функции произошла ошибка. Должна ли она приводить к остановке всего приложения? Как мы выяснили выше – не должна. Принимать решение о том, насколько критична данная ситуация, может приложение, которое использует эту функцию, но не сама функция.

## Коды возврата

В языках, появившихся до 1990 года (примерно), обработка ошибок выполнялась через механизм возврата функцией специального значения. Например, в Си, если функция не может выполнить свою задачу, то она должна вернуть специальное значение, либо `NULL`, либо отрицательное число. Значение этого числа говорит о том, какая ошибка произошла. Например:

```javascript
int write_log()
{
    int ret = 0; // return value 0 if success
    FILE *f = fopen("logfile.txt", "w+");

    // Проверяем, получилось ли открыть файл
    if (!f)
        return -1;

    // Проверяем, что не достигли конца файла
    if (fputs("hello logfile!", f) != EOF) {
        // continue using the file resource
    } else {
        // Файл закончился
        ret = -2;
    }

    // Не получилось закрыть файл
    if (fclose(f) == EOF)
        ret = -3;

    return ret;
}
```

Обратите внимание на условные конструкции и постоянное присваивание переменной `ret`. Фактически каждая потенциально опасная операция должна проверяться на успешность выполнения. Если что-то пошло не так, то функция возвращает специальный код.

И вот тут начинаются проблемы. Как показывает жизнь, в большинстве ситуаций ошибка обрабатывается не там, где она возникла, и даже не уровнем выше. Предположим, что есть функция _A_, которая вызывает код, потенциально приводящий к ошибке, и она его должна уметь правильно обработать и сообщить пользователю о проблеме. При этом сама ошибка происходит внутри функции _E_, которая вызывается внутри _A_ не напрямую, а через цепочку функций: _A => B => C => D => E_. Подумайте, к чему приводит такая схема? Все функции в этой цепочке, даже несмотря на то, что они не обрабатывают ошибку, обязаны знать про неё, отлавливать её и так же возвращать наружу код этой ошибки. В итоге, кода, который занимается ошибками, становится так много, что за ним теряется код, выполняющий исходную задачу.

_Стоит сказать, что существуют схемы обработки ошибок, которые не обладают такими недостатками, но работают по принципу возврата. Например, монада Either._

## Исключения

Именно на этом фоне и возник механизм исключений. Его главная цель — передать ошибку из того места, где она возникла, в то место, где её можно обработать, минуя все промежуточные уровни. Другими словами, механизм исключений раскручивает стек вызовов самостоятельно.

С исключениями нужно запомнить две вещи: код, в котором произошла ошибка, выбрасывает исключение, а код, в котором ошибка обрабатывается – его ловит.

```javascript
// Функция, которая может выбросить исключение
const readFile = (filepath) => {
  if (!isFileReadable(filepath)) {
    // throw – способ выбросить исключение
    throw new Error(`'${filepath}' is not readable`);
  }
  // ...
};

// Где-то в другом месте программы

const run = (filepath) => {
  try {
    // Функция, которая вызывает readFile. Возможно не напрямую, а через другие функции.
    // Для механизма исключений это не важно.
    readFile(filepath);
  } catch (e) {
    // Этот блок выполняется только в одном случае, если в блоке try было выброшено исключение
    showErrorToUser(e);
  }
  // Если тут будет код, он продолжит выполняться
};
```

Сами исключения – это объекты `Error`. Эти объекты содержат внутри себя сообщение, переданное в конструктор, трассировку стека и другие полезные данные.

Самостоятельно исключение выбрасывается с помощью ключевого слова `throw`:

```javascript
const e = new Error("Тут любой текст");
throw e; // Исключение можно создать отдельно, а можно сразу же там, где используется throw
```

`throw` прерывает дальнейшее выполнение кода. В этом смысле оно подобно `return`, но в отличие от него, прерывает выполнение не только текущей функции, но и всего кода, вплоть до ближайшего в стеке вызовов блока `catch`.

Блок _try/catch_ обычно ставится на самом верхнем уровне программы, но это не обязательно. Вполне вероятно, что есть несколько промежуточных блоков, которые могут отлавливать ошибки и снова их возбуждать. Эта тема достаточно сложная и требует некоторого опыта работы.

---

#### Дополнительные материалы

1. [Обработка ошибок](https://ru.hexlet.io/courses/js_errors)

# Дополнительные материалы

## [JS: Введение в ООП](https://ru.hexlet.io/courses/js-introduction-to-oop)

1. [О курсе](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/about/theory_unit)

   - Без материалов

2. [Что понимается под ООП](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/definition/theory_unit)

   - [Алан Кэй, создатель ООП, про разработку, Лисп и ООП](https://habr.com/ru/company/hexlet/blog/303754/)

3. [Инкапсуляция](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/encapsulation/theory_unit)

   - Без материалов

4. [Контекст (This)](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/this/theory_unit)

   - [YDKJS: This](https://github.com/azat-io/you-dont-know-js-ru/blob/master/this %26 object prototypes/ch1.md)

5. [Связывание (bind)](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/bind/theory_unit)

   - [Частичное применение](https://ru.hexlet.io/courses/js-functions-hard-way/lessons/partial-application/theory_unit)

6. [Особенности работы this со стрелочными функциями](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/arrow-functions/theory_unit)

   - Без материалов

7. [Конструктор](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/constructor/theory_unit)

   - [Natives](https://github.com/getify/You-Dont-Know-JS/blob/9959fc904d584bbf0b02cf41c192f74ff4238581/types-grammar/ch3.md#you-dont-know-js-yet-types--grammar---2nd-edition)

8. [Прототипы](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/prototype/theory_unit)

   - [JS: Прототипы](https://ru.hexlet.io/courses/js_prototypes)

9. [Упаковка и Распаковка (Boxing)](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/boxing/theory_unit)

   - [Документация по valueOf на MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)
   - [Boxing Wrappers](https://github.com/getify/You-Dont-Know-JS/blob/9959fc904d584bbf0b02cf41c192f74ff4238581/types-grammar/ch3.md#boxing-wrappers)

10. [toString()](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/to-string/theory_unit)

    - Без материалов

11. [Класс](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/class/theory_unit)

    - [@babel/plugin-proposal-class-properties](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties)

12. [Статические свойства и методы](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/static/theory_unit)

    - [Статические свойства / MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/Class_fields#Публичные_поля)
    - [Статические методы / MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static)

13. [Исключения](https://ru.hexlet.io/courses/js-introduction-to-oop/lessons/exceptions/theory_unit)

    - [Обработка ошибок](https://ru.hexlet.io/courses/js_errors)
