## Представление символов. Метасимвол.—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/128928902" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Регулярные выражения — это формальный язык, который используется для поиска символов и осуществления манипуляций с подстроками. Это мощный инструмент, который позволит вам эффективно работать с текстом.

Регулярные выражения представляют собой специальную текстовую строку, которая задает шаблон поиска (от английского `pattern`) с использованием тех символов, которые нужно найти, и специальных символов.

Для наглядности шаблонные строки с регулярными выражениями в примерах этого курса мы будем располагать сверху, а строки, в которых мы производим поиск — снизу. Рекомендуем самостоятельно "прогонять" все примеры в онлайн-редакторах регулярных выражений: [regex101](https://regex101.com/), [regexr](https://regexr.com/) или иных. Выбирайте "движок" JavaScript или PCRE для примеров, которые JS не поддерживает.

Давайте зададим шаблон с символами, которые мы хотим найти в строке:

---

/`java`/

`java` \ python ruby1.9 `java`script c#

---

Мы видим, что с текстом `java` сопоставилось два варианта из строки. Такое совпадение называется точным: мы не использовали специальных символов и нашли в тексте комбинации символов, совпадающие с заданной комбинацией на 100%.

Если же мы добавим еще один символ, то уже соответствия не будет, потому что такой подстроки в нашей строке нет.

---

/`javab`/

java \ python ruby1.9 javascript c#

---

Чтобы понять разницу между символами, которые мы ищем в тексте, и специальными символами, давайте попробуем найти в тексте любой символ. Для этого мы используем метасимвол — точку "`.`" :

---

/`.`/

```
java \ python ruby1.9 javascript c#
```

---

В результате подсветилась вся строка.

Теперь будем комбинировать символы в шаблонной строке. Попробуем найти совпадения комбинаций любого символа с символом `y`. Получается два совпадения:

---

/`.y`/

java \ `py`thon ru`by`1.9 javascript c#

---

При комбинировании специальных и обычных символов нужно учитывать особое поведение первых. Обратите внимание на пример ниже, где мы задаем в шаблоне символы `1.9`. Важно понимать, что они соответствуют не самой комбинации символов `1.9`, а всем подстрокам состоящих из трёх символов, в которых первый символ — `1`, а последний — `9`. Таким образом, между этими символами в строке может находиться любой:

---

/`1.9`/

java \ python ruby`1.9` javascript c#

java \ python ruby`189` javascript c#

java \ python ruby`1k9` javascript c#

---

Если мы хотим использовать точку как обычный знак препинания, а не как специальный символ в языке регулярных выражений, то необходимо экранирование символов с помощью одного из так называемых "escape-символов".

Для этого поставим обратный слэш `\` и укажем после него тот символ, который мы хотим экранировать, чтобы он перестал иметь специальное значение. Как видим, все работает. Если вместо точки мы поставим другой символ, наша подстрока не будет совпадать с шаблонной.

---

/`1\.9`/

java \ python ruby`1.9` javascript c#

java \ python ruby1d9 javascript c#

---

Точно так же мы можем экранировать и сам обратный слэш, если нам нужно использовать его в качестве обыкновенного символа. В результате, мы увидим следующее совпадение:

---

/`\\`/

java `\` python ruby1d9 javascript c#

---

---

##### Дополнительные материалы

1. [Регулярные выражения](https://ru.wikipedia.org/wiki/Регулярные_выражения)
2. [Cheatsheet — таблица синтаксиса регулярных выражений](https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/)
3. [Онлайн редактор регулярных выражений](https://regex101.com/)

## Символьные классы—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/128930268" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

В этом уроке мы познакомимся с символьными классами.

Символьный класс — это специальное обозначение, задающее поиск любого символа из определенного набора.

Рассмотрим принцип работы символьных классов на простом примере. Предположим, что нам нужно найти только буквы алфавита. Для этого можно использовать символьные классы, которые описываются в квадратных скобках, и в нашем случае все буквы английского алфавита в нижнем регистре будут выглядеть так: `[a-z]`. Мы видим, что символы алфавита в строке подсветились:

---

/ `[a-z]`/

```
java` 11_34-1938 `tab
new line
```

---

Таким же образом можно задать поиск цифр от нуля до девяти:

---

/ `[0-9]`/

java `11`\_`34`-`1938` tab

new line

---

А в этом примере мы укажем только 2 символа, каждый из которых будет найден:

---

/ `[aj]`/

`ja`v`a` 11_34-1938 t`a`b

new line

---

В символьных классах можно использовать механизм, который называется "отрицание". Если мы ставим символ `^` перед первым символом в квадратных скобках, то осуществляется инвертированный поиск и находятся все символы, кроме перечисленных после `^`:

---

/ `[^aj]`/

ja`v`a `11_34-1938 t`a`b`

```
new line
```

---

Если наряду с буквами алфавита необходимо найти дефис, то нужно лишь указать его в начале или конце группы символов, и тогда он не будет восприниматься как специальный символ:

---

/ `[aj-]`/

`ja`v`a` 11_34`-`1938 t`a`b

new line

---

В регулярных выражениях часто используют специальные предопределенные символьные классы. Они записываются с помощью символа `\` и имеют свои обозначения в языке регулярных выражений. В прошлом уроке мы использовали `\` как один из escape-символов для экранирования. Здесь же он используется, как часть обозначения. Давайте найдем в тексте все цифры с помощью обозначения класса цифр `\d`:

---

/ `\d`/

java `11`\_`34`-`1938` tab

new line

---

Если мы укажем большую `D`, то в результате поиска получим все остальные символы, в том числе, пробельные и табуляцию.

---

/ `\D`/

```
java`11`_`34`-`1938`tab
new line
```

---

Для поиска пробельных символов существует класс `\s`, а класс `\S`, в свою очередь, обозначает все непробельные символы. Как мы видим, принцип обозначения символьных классов прост: маленькая буква обозначает класс, а большая — все, что к нему не относится.

Есть ещё один популярный класс `\w`, который включает в себя все буквы алфавита, все цифры и подчеркивания. В коде ниже не видно, однако пробельные символы не соответствуют этому классу, равно как и `-`.

---

/ `\w`/

```
java` `11_34`-`1938` `tab
new` `line
```

---

Использование класса `\w` равносильно такой записи: `[0-9a-zA-Z_]`. Обратите внимание: при поиске в диапазоне символов важен регистр, поэтому в этой записи после `a-z` следует `A-Z`.

Соответственно, `\W` находит инвертированный вариант своей маленькой копии. Здесь уже вместе с дефисом будут найдены и пробельные символы:

---

/ `\W`/

java 11_34`-`1938 tab

new line

## Позиция внутри строки—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129155123" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

В этом уроке мы познакомимся со специальными символами, которые используются для уточнения позиций символов в строке и подстроках.

Рассмотрим следующий пример:

---

/`java`/

```
java
```

---

Здесь слово `java` совпадает со строкой `java` — это простое условие. Важно помнить, что регулярные выражения ищут совпадения не в строках, а в подстроках. При поиске в строке, которая кроме искомых будет содержать другие символы, проверка может показать, что строки сопоставились, хотя на самом деле вы этого не хотели:

---

/`java`/

asdf`java` asdf

---

Для управления поиском символов в строке существуют специальные символы.

#### Символ начала строки

Если поставить `^` в строке поиска перед искомыми символами, будут сопоставлены только символы, которые находятся в начале строки:

---

/`^java`/

`java` ruby clojurescript javascript

---

Если мы уберем `^`, то у нас будут найдены два сопоставления, в том числе в последней подстроке:

---

/`java`/

`java` ruby clojurescript `java`script

---

#### Символ для поиска в конце строки

Это символ — `$`. Вот пример без использования этого символа, с двумя сопоставлениями:

/`script`/

java ruby clojure`script` java`script`

---

А вот с ним, где всего одно — в конце строки:

---

/`script$`/

java ruby clojurescript java`script`

---

#### Поиск других символов относительно границ слова

Предположим, что нам нужно найти только те символы `a`, которые находятся в конце слова. Для этого наберём в шаблонной строке `a\b`:

---

/`a\b`/

jav`a` ruby clojurescript javascript

---

Используя тот же символ в верхнем регистре `\B`, мы можем инвертировать поиск, и найти все символы `a`, не находящиеся в конце слова:

---

/`a\B`/

j`a`va ruby clojurescript j`a`v`a`script

---

Если же поставить символ `\b` перед искомым, то будут найдены символы, находящиеся в начале слова:

---

/`\bj`/

`j`ava ruby clojurescript `j`avascript

---

Снова используем инвертирование:

---

/`\Bj`/

java ruby clo`j`urescript`j` javascript

---

Для наглядности в сравнении с предыдущим примером мы добавили в нашу строку еще один символ `j` после `clojurescript`. Теперь найдем только символ `j`, не находящийся ни в начале слова, ни в его конце:

---

/`\Bj\B`/

java ruby clo`j`urescriptj javascript

## Альтернатива—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129237213" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Рассмотрим, как с помощью регулярных выражений мы можем находить похожие сочетания символов.

Чтобы найти в строке любую из двух подстрок: `gray` или `grow`, воспользуемся механизмом, который называется "альтернатива": укажем первый возможный вариант и через вертикальную черточку — второй. Видим следующее сопоставление:

---

/`gray|grow`/

`gray` `grow` grey

---

Это же условие можно записать немного короче. Поскольку у этих подстрок есть общая часть, укажем символы `gr` и дальше, используя группировку, добавим альтернативу:

---

/`gr(ay|ow)`/

`gray` `grow` grey

---

Здесь очень важна группировка. Если мы ее уберем, альтернативой `gray` станет `ow`:

---

/`gray|ow`/

`gray` gr`ow` grey

---

Ниже ещё один интересный пример использования альтернативы. В английском языке есть слово `gray`/`grey`, которое в обоих случаях звучит одинаково, однако в британском и американском вариантах имеет разное написание. Чтобы не упустить в тексте ни один из вариантов, мы можем использовать лаконичную альтернативу:

---

/`gr(a|e)y`/

```
gray` grow `grey
```

---

А можем упростить получившееся выражение, поскольку в альтернативе используются одиночные символы. Укажем символьный класс, который состоит из символов `a` и `e`:

---

/`gr[ae]y`/

```
gray` grow `grey
```

---

В этом случае механизм регулярных выражений, который занимается сопоставлением, намного эффективнее работает с символьными классами, тем более — одиночными.

## Квантификация—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129155127" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Познакомимся с понятием квантификации, и как с её помощью можно находить повторяющиеся символы.

Квантификация — это поиск последовательностей. Квантификатор — это специальный ограничитель, который указывает количество возможных повторений символа, группы символов или класса символов, находящихся в регулярном выражении перед ним.

Давайте разберёмся, что это всё значит, и посмотрим на пример с простейшим квантификатором — символом `?`, который обозначает "поиск совпадений с повторением от нуля до одного раза":

---

/`colou?`/

colr, `colo`r, `colou`r, `colou`ur, `colou`uur

---

Поскольку в этом выражении отсутствует группировка или символьный класс, квантификатор `?` задаёт повторение для символа `u` и обозначает, что предшествующий ему символ `u` либо не будет участвовать в совпадении (то есть "повторится ноль раз"), либо будет участвовать без повторений (то есть "повторится один раз"). Итого — четыре совпадения.

А в этом примере дополним шаблонную строку символом `r`. И у нас будет лишь два совпадения:

---

/`colou?r`/

colr, `color`, `colour`, colouur, colouuur

---

Используем группировку и символьный класс — и у нас уже иные сопоставления. В случае с группировкой - проверка вхождения всей группы 0 или 1 раз. В случае с символьным классом - проверка вхождения одного из символов (но не всех одновременно) 0 или 1 раз.

---

/`col(ou)?r`/

`colr`, color, `colour`, colouur, colouuur

---

/`col[ou]?r`/

`colr`, `color`, colour, colouur, colouuur

---

Еще один квантификатор — символ `+`. Он означает, что предшествующий ему символ, группа или класс символов, должны повторяться как минимум один раз. Так и происходит. Здесь слово `color` уже не сопоставляется:

---

/`colou+r`/

colr, color, `colour`, `colouur`, `colouuur`

---

Символ `*` говорит об отсутствии повторений или о повторении несколько раз, что дает нам совпадение во всех подстроках кроме `colr`:

---

/`colou*r`/

colr, `color`, `colour`, `colouur`, `colouuur`

---

Есть более точные квантификаторы, которые записываются в фигурных скобках `{}`. Достаточно указать в них необходимое число повторений:

---

/`colou{2}r`/

colr, color, colour, `colouur`, colouuur

---

Кроме того, в фигурных скобках `{}` можно указать диапазон повторений. Например, от двух до трёх:

---

/`colou{2,3}r`/

colr, color, colour, `colouur`, `colouuur`

---

Если мы не укажем конец диапазона, то максимальное количество повторений не будет ограничено:

---

/`colou{1,}r`/

colr, color, `colour`, `colouur`, `colouuur`, `colouuuur`, `colouuuuur`

## Жадность—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129237214" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Познакомимся с понятиями жадной и ленивой квантификации.

Давайте напишем регулярное выражение, которое подсветит все теги в нашей строке. Для этого укажем открывающие и закрывающие знаки тега: `<` и `>`, а внутри пусть будет любой символ:

---

/`<.*>`/

<a href="https://www.yandex.ru">google</a>

---

Несмотря на то, что в строке есть два тега — открывающий и закрывающий — в результате сопоставилась вся строка. Такое поведение называется жадным. Это значит, что квантификатор повторяется столько раз, сколько это возможно. По умолчанию в регулярных выражениях квантификация жадная, поэтому у нас захватывается максимальная подстрока. Вся строка соответствует нашему регулярному выражению: всё внутри `<` и `>` считается содержимым тега.

Чтобы избежать жадного поведения, вместо любого символа внутри тега мы можем задать любой символ, за исключением закрывающего. И тогда сопоставляются два тега отдельно:

---

/`<[^>]*>`/

<a href="https://www.yandex.ru">google</a>

---

Несмотря на эффективность такого решения, это лишь уход от проблемы. Так можно избежать последствий жадного поведения, но не его самого.

Чтобы из жадной квантификации сделать ленивую, необходимо использовать специальный символ `?`:

---

/`<.*?>`/

<a href="https://www.yandex.ru">google</a>

---

Не забывайте, что в регулярных выражениях многие специальные символы ведут себя по-разному, в зависимости от того, где они стоят. Если бы `?` располагался после точки, то он рассматривался бы просто как квантификатор "ни одного символа, либо один символ":

---

/`<.?>`/

<p><a href=" https://yandex.ru ">google</a></p>

---

Но когда `?` идёт сразу после квантификатора, он рассматривается регулярным выражением как специальный символ, который из жадных квантификаторов делает ленивые.

## Группировка. Обратная связь—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129988782" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Рассмотрим дополнительные возможности и различные виды группировки.

#### Группировка с обратной связью

У нас есть группа символов, из которой мы выбираем либо `ta`, либо `tu`:

---

/`(ta|tu)`/

```
ta`-`tu` `ta`-`ta` `tu`-`tu
```

---

Предположим, что мы хотим найти только те подстроки, в которых левая и правая части совпадают: `ta - ta` и `tu - tu`. Попробуем дополнить наше выражение ещё одним условием "или" и увидим, что реализовать задуманное нам не удалось:

---

/`(ta|tu)-(ta|tu)`/

```
ta-tu` `ta-ta` `tu-tu
```

---

Здесь нам поможет группировка с обратной связью. Она работает следующим образом. Мы используем специальное обозначение `\1`, которое говорит, что символы из первой группы — а у нас одна-единственная группа — нужно подставить вместо `\1`. Таким образом, совпадают подстроки с одинаковыми левыми и правыми частями:

---

/`(ta|tu)-\1`/

ta-tu `ta-ta` `tu-tu`

---

По умолчанию все группы символов, которые мы создаем, записываются в специальную область памяти и маркируются символами от `\1` до `\9`. Если бы мы использовали квантификацию, то это не повлияло бы на результат, потому что она не участвует в обратной связи и берётся только первое вхождение в область памяти:

---

/`(ta|tu)+-\1`/

ta-tu `ta-ta` `tu-tu`

---

#### Именованные группы

Если вы используете несколько групп, то не очень удобно запоминать их по номерам. Гораздо проще пользоваться именами. Для этого нужно добавить `?<имя>` после открытия скобки.

---

/`(?<group1>ta|tu)-\k<group1>`/

ta-tu `ta-ta` `tu-tu`

---

Теперь для осуществления операций с группой в своём коде вы можете ссылаться на группу по имени `group1`.

#### Группировка без обратной связи

Мы можем отключить обратную связь, поставив `?:` внутри нашей группы:

---

/`(?:ta|tu)-\1`/

ta-tu ta-ta tu-tu

---

После этого группа перестанет сохраняться в специальную область памяти, и при её вызове возникнет ошибка, потому что такой группы в памяти не существует. При использовании этого подхода регулярное выражение становится очень сложно читать, однако оно работает быстрее. Это вполне рабочий метод, если у вас много групп, и часть из них вам уже не нужна, или вы не хотите их использовать, чтобы они не занимали много места и не мешали заниматься дальнейшей группировкой.

#### Атомарная группировка

Еще одна интересная разновидность группировки без обратной связи, которая называется атомарной. **NB!** Атомарная группировка не поддерживается некоторыми популярными языками программирования, в том числе JavaScript и Python. Но можно в гугле найти решения для их эмуляции на имеющихся конструкциях.

Для атомарной группировки вместо `:` используется символ `>`:

---

/`a(?>bc|b|x)cc`/

abcc`axcc`

---

Давайте разберёмся, как она работает. Если мы уберём символы `?>`, то регулярное выражение находит две подстроки: `abcc` и `axcc`:

---

/`a(bc|b|x)cc`/

```
abccaxcc
```

---

Когда мы добавляем символы атомарной группировки `?>`, происходит следующее: сначала находится символ `a`, затем — `bc`, после чего идет поиск `cc`. В обычном случае в примере выше поиск откатился бы до `a` и продолжил бы проверку с `b`, поскольку стоит символ альтернативы `|`. После этого мы бы дошли до `cc` и проверка бы сработала.

Но при атомарной группировке возврат по строке до символа `a` отключается, и происходит дальнейшее движение по альтернативам `bc` -> `b` -> `x`, а после `x` — сопоставление `cc`.

Когда найдено первое совпадение из атомарной группы (?>bc|b|x), другие варианты из этой группы не рассматриваются. Дальше идет поиск со следующего символа из анализируемой строки с первого символа регулярного выражения.

Мы могли бы найти совпадение всей строки с атомарной группировкой, только если добавили бы в строку еще один символ `c`:

---

/`a(?>bc|b|x)cc`/

```
abcccaxcc
```

## Модификаторы—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129989107" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

В этом уроке мы разберем, что такое модификаторы в регулярных выражениях, как и для чего они могут использоваться. Модификаторы в JavaScript применяются по другому, не так как показано в примерах, поэтому для экспериментов с ними используйте PCRE.

В примере ниже регулярное выражение соответствует одной подстроке:

---

/`(?:t.)-(?:t.)`/

`ta-tu` ta-t

Tu-tu tu-T

---

Здесь сопоставляются две группы символов через дефис `ta-tu`, каждая из которых соответствует условию "`t` и любой символ". Группировка без обратной связи находит только выражение целиком, а не две отдельных группы. Остальные символы из строки не проходят сопоставление. Среди них `T` в верхнем регистре и перевод строки. Первый не находится, поскольку в выражении символ `t` указан в нижнем регистре, а второй — поскольку точка по умолчанию не включает перевод строки.

Мы можем минимально изменить выражение таким образом, чтобы оно включало другие подстроки из примера. Для этого воспользуемся модификатором.

Модификаторы — это символы, которые указываются после знака `?` в группе символов регулярного выражения и меняют их поведение. Если после `?` мы поставим `i`, то включим режим игнорирования регистра и получим сопоставление ещё одной подстроки, но уже не с `t` в нижнем регистре, а с `T` в верхнем:

---

/`(?i:t.)-(?:t.)`/

`ta-tu` ta-t

`Tu-tu` tu-T

---

Если мы сделаем так, что вторая часть подстроки после дефиса `Tu-tu` будет также с большой буквы, то сопоставления по ней не будет, потому что модификатор действует только в рамках группы, где он определен.

---

/`(?i:t.)-(?:t.)`/

`ta-tu` ta-t

Tu-Tu tu-T

---

Поэтому давайте продублируем модификатор `i` во второй группе и получим сопоставление строки `Tu-Tu`:

---

/`(?i:t.)-(?i:t.)`/

`ta-tu` ta-t

`Tu-Tu` tu-T

---

Такая запись получается более коротким вариантом его аналога: `(?:[tT].)-(?:[tT].)`.

Модификаторы можно выносить и в отдельные группы:

---

/`(?i)(t.)-(?i)(t.)`

`ta-tu` ta-t

`Tu-Tu` tu-T

---

Но в этом случае будет выделена память под 4 группы совпадений.

---

Рассмотрим еще один интересный модификатор `s`. Он делает так, что точка начинает включать в себя перевод строки и [возврат каретки](https://ru.wikipedia.org/wiki/Возврат_каретки). Нам уже известно, что точка по умолчанию их не включает, и мы могли убедиться в этом в самом начале урока. После `ta-t` и `tu-T` следует перевод строки, поэтому эти подстроки не сопоставляются. Укажем модификатор `s` во второй группе, и теперь у нас совпадут все подстроки:

---

/`(?i:t.)-(?si:t.)`/

```
ta-tu ta-t
Tu-Tu tu-T
```

---

Модификаторы могут быть отключены. Для этого достаточно указать перед ними `-`. Давайте добавим `-` в первую группу и посмотрим на наш пример:

---

/`(?-i:t.)-(?si:t.)`/

```
ta-tu ta-t
```

Tu-Tu `tu-T`

---

Активные и отключенные модификаторы можно комбинировать. Мы можем добавить модификатор `s` и отменить `i` и `m`:

---

/`(?s-im:t.)-(?si:t.)`/

```
ta-tu ta-t
```

Tu-Tu `tu-T`

---

---

##### Дополнительные материалы

1. [Modifiers](https://www.regular-expressions.info/modifiers.html)

## Просмотр вперед/назад—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129978105" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Большинство реализаций регулярных выражений поддерживают функцию просмотра вперёд и назад или опережающий и ретроспективный поиск (англ. — lookahead, lookbehind). Давайте посмотрим, зачем они нужны.

У нас есть следующее регулярное выражение, которое находит две подстроки:

---

/`LudovicXVI`/

LudovicXV, `LudovicXVI`, `LudovicXVI`II, LudovicLXVII, LudovicXXL

---

Предположим, что нам не нужно включать в результаты поиска часть подстроки с римскими цифрами `XVI`. Для этого "обернём" её вот в такую конструкцию:

---

/`Ludovic(?=XVI)`/

LudovicXV, `Ludovic`XVI, `Ludovic`XVIII, LudovicLXVII, LudovicXXL

---

Как мы видим, условия сопоставления, заданные первоначальным выражением, не изменились. Сопоставились те же подстроки, что и в предыдущем примере. Однако символы `XVI` в совпавших подстроках не были включены в окончательный результат поиска. Такое поведение называется позитивным просмотром вперёд или позитивным опережающим поиском.

Логику позитивного просмотра вперёд можно описать следующим образом. Регулярное выражение `a(?=b)` находит совпадения таких `a`, за которыми следует `b`, не делая `b` частью сопоставления.

Просмотр вперёд также может быть негативным - тогда он будет искать совпадения в тех подстроках, где указанная в скобках часть подстроки отсутствует. В нашем случае - это по-прежнему `XVI`. Чтобы из позитивного просмотра сделать негативный, заменим символ `=` на `!`. Теперь у нас сопоставились три другие подстроки:

---

/`Ludovic(?!XVI)`/

`Ludovic`XV, LudovicXVI, LudovicXVIII, `Ludovic`LXVII, `Ludovic`XXL

---

Кроме просмотра вперёд, существует просмотр назад или ретроспективный поиск. Он работает похожим образом, но ищет совпадения символов, расположенных после сгруппированной в скобках части регулярного выражения, которая не будет включена в сопоставление.

Иными словами, при позитивном просмотре назад регулярное выражение `(?<=b)a` находит совпадения таких `a`, перед которыми находится `b`, не делая `b` частью сопоставления.

Для позитивного просмотра назад используется дополнительный знак `<`. В этом примере мы находим совпадения подстрок `Two`, перед которыми следует `One`:

---

/`(?<=One )Two`/

One `Two`, Three Two

---

Чтобы изменить позитивный просмотр назад на негативный, точно так же, как и в просмотре вперёд, меняем `=` на `!`:

---

/`(?<!One )Two`/

One Two, Three `Two`

## Поиск по условию—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129978103" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Регулярные выражения поддерживают поиск по условию. Пожалуй, это одна из самых сложных конструкций, которая существует в регулярных выражениях и не поддерживается в JavaScript, и многих других языках программирования. В некоторых языках нужно учитывать особенности его реализации: Python поддерживает условный поиск с использованием группировки с обратной связью или именованных групп.

Она напоминает тернарный оператор из языков программирования и выглядит следующим образом: `(?ifthen|else)`.

Рассмотрим её работу на таком примере:

---

/`(?(?<=a)m|p)`/

ma`m`,`p`ap

---

Мы видим внешние скобки с `?`, а внутри - два отдельных выражения:

- Первое — это условие `(?<=a)`, которое проверяет, соответствует ли символ слева `a`.
- Дальше идет альтернатива, и мы выбираем между `m` и `p` в зависимости от того, сработало условие или нет.

Можно описать эту конструкцию так: «Найти все `m` перед которыми идёт `a` или `p`, перед которыми `a` нет».

Давайте разберем поиск в нашей строке посимвольно:

- выполняется проверка условия - является ли текущий символ `m` и стоит ли перед ним `a`. Поскольку условие не выполнилось, происходит попытка извлечь `p`, что также не является текущим символом;
- второй символ `a` не подходит под условия, пропущенная подстрока `ma`, далее проверяется `m,pap`;
- третий символ `m` соответствует `m`, ранее была `a` — найдено первое _сопоставление_;
- четвертый символ `,` не подходит под условия, пропущенная подстрока `mam,`, далее проверяется `pap`;
- пятый символ `p` не соответствует `am`, но соответствует `p` — найдено второе _сопоставление_;
- шестой символ `a` снова запускает проверку следующего символа на соответствие `m`;
- седьмой символ `p` проваливает проверку на соответствие `m`.

Вот так в результате условного поиска у нас было найдено два совпадения в строке.

---

##### Дополнительные материалы

1. [Conditional lookaround](https://www.regular-expressions.info/conditional.html)

## Флаги—Регулярные выражения (Regexp)

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/129978362" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

### Конспект урока

Познакомимся с так называемыми "флагами", которые позволяют изменить поведение регулярных выражений и правила поиска совпадений в строке.

Обратите внимание на этот пример:

---

/`aa`/

`aa` aa aa

---

Регулярному выражению `aa` почему-то соответствует только одна подстрока в этой строке, хотя на самом деле мы видим, что их должно быть три. Это происходит, потому что по умолчанию регулярные выражения ищут только первое соответствие. Для того, чтобы изменить их поведение, используются флаги.

Если в течение этого курса вы уже пользовались редактором регулярных выражений или просто смотрели видео курса, то обратили внимание на поле, расположенное справа от шаблонной строки. Чаще всего в нём стоит флаг `/g`, который называется "глобальный" или `global`. Он включает поиск всех сопоставлений в строке и не останавливает поиск после первого совпадения. Давайте поставим флаг `g`. Теперь сопоставились все подстроки:

---

/`aa`      /`g`

```
aa aa aa
```

---

В этом курсе мы по умолчанию используем флаг `g` в наших примерах и не указываем его дополнительно, однако вы можете встретить его в составе регулярных выражений в тестах и практических заданиях, поэтому если увидите в конце регулярки `/g`, знайте — это флаг глобального поиска.

**NB!** Глобальный флаг часто используется в тех случаях, когда нужно не просто найти сопоставление регулярному выражению в строке, но и извлечь или иным образом использовать результаты поиска.

В зависимости от языка программирования флаги могут включаться непосредственно в сами регулярные выражения, или задаваться иными способами. Как именно это реализовано в конкретном языке, нужно смотреть в соответствующей документации.

Напоследок рассмотрим еще несколько флагов.

- флаг `/i` включает режим игнорирования регистра:

---

/`aa`      /`gi`

```
aa Aa AA
```

---

- флаг `/s` включает соответствие метасимвола `.` переводу строки, то есть делает так, что строка, в которой ищутся совпадения, может быть представлена как одна строчка. Иногда это может пригодиться.

Не напоминают ли вам флаги что-то, пройденное нами ранее? Верно, по сути — это более могущественные версии модификаторов, которые мы рассмотрели в восьмом уроке. Последние позволяют делать более точечные изменения правил сопоставления, в то время как флаги делают это на глобальном уровне.

Cуществует еще несколько флагов. Изучение остальных — ваше задание после этого урока. Зайдите в любой редактор регулярных выражений, прочитайте документацию по флагам, покрутите примеры из неё и обязательно попробуйте использовать каждый флаг.

## Дополнительные материалы

### [Регулярные выражения (Regexp)](https://ru.hexlet.io/courses/regexp)

1. [Представление символов. Метасимвол.](https://ru.hexlet.io/courses/regexp/lessons/symbols/theory_unit)
   - [Регулярные выражения](https://ru.wikipedia.org/wiki/Регулярные_выражения)
   - [Cheatsheet — таблица синтаксиса регулярных выражений](https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/)
   - [Онлайн редактор регулярных выражений](https://regex101.com/)
2. [Символьные классы](https://ru.hexlet.io/courses/regexp/lessons/character_classes/theory_unit)
   - Без материалов
3. [Позиция внутри строки](https://ru.hexlet.io/courses/regexp/lessons/anchors/theory_unit)
   - Без материалов
4. [Альтернатива](https://ru.hexlet.io/courses/regexp/lessons/alternation/theory_unit)
   - Без материалов
5. [Квантификация](https://ru.hexlet.io/courses/regexp/lessons/quantifiers/theory_unit)
   - Без материалов
6. [Жадность](https://ru.hexlet.io/courses/regexp/lessons/greedy/theory_unit)
   - Без материалов
7. [Группировка. Обратная связь](https://ru.hexlet.io/courses/regexp/lessons/backreferences/theory_unit)
   - Без материалов
8. [Модификаторы](https://ru.hexlet.io/courses/regexp/lessons/modifiers/theory_unit)
   - [Modifiers](https://www.regular-expressions.info/modifiers.html)
9. [Просмотр вперед/назад](https://ru.hexlet.io/courses/regexp/lessons/lookaround/theory_unit)
   - Без материалов
10. [Поиск по условию](https://ru.hexlet.io/courses/regexp/lessons/regexp_conditionals/theory_unit)
    - [Conditional lookaround](https://www.regular-expressions.info/conditional.html)
11. [Флаги](https://ru.hexlet.io/courses/regexp/lessons/flags/theory_unit)
    - Без материалов
