## Введение—JS: Автоматическое тестирование

Код профессиональных разработчиков содержит меньше ошибок, чем код начинающих. Это происходит не потому, что они умнее, внимательнее к деталям или видят код насквозь. Настоящая причина кроется в том, что они пишут тесты.

Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их количество на приемлемом уровне. Тесты дают уверенность, что изменения в одной части системы не сломали другие части.

Однако, тесты нужны не только для проверки работоспособности кода. Существуют и другие виды автоматизированных тестов, например, тесты производительности или тесты на уязвимости.

Среди разных видов автоматизированных тестов программисты, в первую очередь, отвечают за функциональные тесты. Эти тесты проверяют, что код выполняет свою прямую задачу с точки зрения пользователей программы. Например, регистрация пользователя должна, как это ни странно, регистрировать пользователя. И тесты это подтверждают.

По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

- Модульные
- Интеграционные
- Системные

Самые простые и наименее эффективные тесты — модульные. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе. За это уже отвечают интеграционные тесты. У программистов на такие тесты должно быть направлено основное внимание. Их всё ещё достаточно просто писать (если экосистема проекта подготовлена к этому), и они охватывают гораздо большую часть системы.

Наиболее сложные и максимально эффективные — системные тесты. В случае сайтов — это тестирование через браузер. Эти тесты эмулируют поведение настоящего пользователя, ходят по сайту, кликают на ссылки, заполняют и отправляют формы. Сложность этих тестов в том, что им приходится опираться на вёрстку сайта, которая часто и непредсказуемо меняется. Кроме того, в браузере невозможно точно определить, когда закончилось одно действие и началось другое (с точки зрения программы). Именно поэтому такие тесты часто ломаются, их сложно писать и поддерживать.

Несмотря на различия, в основе всех автоматических тестов лежат одни и те же принципы. Часто используются одни и те же инструменты. Этот курс знакомит с общими принципами тестирования и шаг за шагом проводит через все возникающие во время тестирования задачи. Основные темы этого курса:

- Утверждения (Asserts)
- Фреймворки для тестирования (Jest)
- Модульное тестирование (Unit)
- Матчеры
- Покрытие кода тестами
- Разработка через тестирование (TDD)

### Домашнее задание

В этом курсе в некоторых уроках будут содержаться команды для скачивания домашних заданий. Работа над домашними заданиями выполняется на компьютере студента. Домашние задания выполняются студентами, обучающимися на интенсиве [Тестирование фронтенда](https://ru.hexlet.io/programs/frontend-testing-react). Скачивание производится при помощи утилиты [Hexlet CLI](https://github.com/Hexlet/cli/blob/main/src/templates/program/README.md).

Загрузите домашнее задание с помощью команды:

```
hexlet program download frontend-testing-react start
```

---

##### Дополнительные материалы

1. [Как мы тестируем тесты. О проверке тестов в практических упражнениях этого курса.](https://help.hexlet.io/ru/articles/111145-kak-my-testiruem-testy-utilita-suppressor)

## Зачем и как писать тесты?—JS: Автоматическое тестирование

Какую главную задачу должны решать тесты? Этот вопрос невероятно важен. Ответ на него даёт понимание того, как правильно писать тесты и как писать их не нужно.

Представьте, что вы написали функцию `capitalize(text)`, которая делает заглавной первую букву переданной строки:

```javascript
capitalize("hello"); // 'Hello'
```

Вот один из вариантов её реализации:

```javascript
const capitalize = (text) => {
  const firstChar = text[0].toUpperCase();
  const restSubstring = text.slice(1);
  return `${firstChar}${restSubstring}`;
};
```

Что мы делаем после создания функции? Проверяем, как она работает. Например, открываем REPL и вызываем функцию с разными аргументами:

```bash
node
Welcome to Node.js v12.4.0.
> capitalize('hello')
'Hello'
> capitalize('how are you')
> 'How are you'
```

Таким нехитрым способом убеждаемся, что функция работает. По крайней мере для тех аргументов, которые мы передали в неё. Если во время проверки заметили ошибки, то исправляем функцию и повторяем всё заново.

Фактически, весь этот процесс и есть тестирование. Но не автоматическое, а _ручное_. Задача такого тестирования — убедиться, что код работает как надо. И нам совершенно без разницы, как конкретно реализована эта функция. Это и есть главный ответ на вопрос, заданный в начале урока.

> Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.

### Автоматические тесты

Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, делая ручное тестирование. Для этого достаточно старого доброго `if` и исключений.

Даже если вы не знакомы с исключениями, ничего страшного. В этом курсе достаточно знать две вещи: для чего они нам нужны и какой у них синтаксис. До сих пор в курсах Хекслета вы встречались с ошибками, которые возникают непроизвольно: вызов несуществующей функции, обращение к несуществующей константе и так далее. Но ошибки можно порождать самостоятельно с помощью исключений, что необходимо для нашей ситуации. Исключения создаются такой конструкцией:

```javascript
// Дословно: выбросить новую ошибку
// Исключения бросают
throw new Error("описание исключения");
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log("nothing");
```

Пример теста:

```javascript
if (capitalize("hello") !== "Hello") {
  // Если результат функции не равен ожидаемому значению
  // Выбрасываем исключение и завершаем выполнение теста
  throw new Error("Функция работает неверно!");
}
```

Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он работает в том же окружении и подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой. Обнаруженные ошибки в тестах исправляются, и жизнь продолжается дальше ;)

В коде тесты, как правило, складывают в специальную директорию в корне проекта. Обычно она называется _tests_, хотя встречаются и другие варианты:

```
src/
├── bin
│   └── hexlet.js
├── half.js
└── index.js
tests/
└── half.test.js
```

Структура этой директории зависит от того, на базе чего пишутся тесты, например, на базе какого фреймворка. В простых случаях, она отражает структуру исходного кода. Если предположить, что наша функция `capitalize(text)` определена в файле _src/capitalize.js_, то её тест лучше поместить в файл _tests/capitalize.test.js_. Слово _test_ в имени модуля с тестами, используется только для более явного обозначения цели файла.

Теперь при любых изменениях, затрагивающих эту функцию, важно не забывать запускать тесты:

```javascript
node tests/capitalize.test.js
### Если все хорошо, код молча выполнится.
### Если есть ошибка, то будет выведено сообщение об ошибке.
```

### Как пишутся тесты

Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые функции, вызывать их с необходимыми аргументами и проверять, что функции возвращают ожидаемые значения.

Если поменялась сигнатура функции (входные или выходные параметры, её имя), то придётся переписывать тесты. Если сигнатура осталась той же, но поменялись внутренности функции:

```javascript
const capitalize = (text) => {
  const [firstChar, ...restChars] = text;
  return `${firstChar.toUpperCase()}${restChars.join("")}`;
};
```

Тогда тесты должны продолжать работать без изменений.

Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

#### Сколько и какие нужно писать проверки?

Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически неосуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

При написании тестов нужно ориентироваться на разнообразие входных данных. У любой функции есть один или несколько основных сценариев использования. Например, в случае `capitalize()` — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

- Работа с пустой строкой
- Обработка `null`
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

Для `capitalize()` пограничным случаем будет пустая строка:

```javascript
if (capitalize("") !== "") {
  throw new Error("Функция работает неверно!");
}
```

Добавив тест на пустую строку, мы увидим, что вызов показанной в начале урока функции `capitalize()` завершается с ошибкой. Внутри неё идёт обращение к первому индексу строки без проверки его существования. Исправленная версия кода:

```javascript
const capitalize = (text) => {
  if (text === "") {
    return "";
  }
  const firstChar = text[0].toUpperCase();
  const restSubstring = text.slice(1);
  return `${firstChar}${restSubstring}`;
};
```

В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария:

- Функция выполнилась так, что не был выполнен ни один условный блок
- Функция выполнилась так, что был выполнен только первый условный блок
- Функция выполнилась так, что был выполнен только второй условный блок
- Функция выполнилась так, что были выполнены оба условных блока

Комбинация всех возможных вариантов поведения функции называется _цикломатической сложностью_. Это число показывает все возможные пути кода внутри функции. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

Иногда пограничные случаи не связаны с условными конструкциями. Особенно часто такие ситуации встречаются там, где есть вычисления границ слов или массивов. Такой код может работать в большинстве ситуаций, но только в некоторых может давать сбой:

```javascript
// В этой функции забыли отнять единицу от длины
// Этот код сработает в некоторых ситуациях, когда последний элемент undefined или в массиве нет элементов
// Но в остальных случаях вернёт неверное значение
const last = (elements) => elements[elements.length];
```

#### Проверка входных данных

Особняком стоят ошибки типов входных данных. Например, в функцию `capitalize()` можно передать число вместо строки. Как она должна себя вести в таком случае? Нужно ли писать такой тест?

_Ещё один интересный вопрос. Нужно ли внутри capitalize() обрабатывать такие ситуации? Ответ — не нужно. Иначе код превратится в мусорку, а пользы от этого мало. Всё равно должны быть тесты, которые проверяют, что система работает в целом, а они обычно выявляют проблемы кода на более нижних уровнях_.

Ответственность за передачу правильных данных в функцию `capitalize()` лежит не на ней, а на коде, который вызывает эту функцию. И если он хорошо протестирован, то подобная ошибка либо обнаружится, либо вообще не возникнет.

Но даже если ошибка обрабатывается внутри функции, не надо пытаться написать тесты, покрывающие каждую ошибку. Это выливается в огромное число тестов, которые требуют поддержки и времени на написание. Нужно уметь вовремя остановиться и двигаться дальше, к покрытию другого кода.

### Собирая всё вместе

В конечном итоге мы получили такую структуру директорий:

```javascript
src/
└── capitalize.js
tests/
└── capitalize.test.js
```

Содержимое теста:

```javascript
if (capitalize("hello") !== "Hello") {
  throw new Error("Функция работает неверно!");
}

if (capitalize("") !== "") {
  throw new Error("Функция работает неверно!");
}

console.log("Все тесты пройдены!");
```

Запуск:

```bash
node tests/capitalize.test.js
```

https://repl.it/@hexlet/js-testing-goal-capitalize#tests/capitalize.test.js

Если всё написано правильно, то запуск тестов завершится с выводом строки _Все тесты пройдены!_ Если в тестах или в коде есть ошибка, то сработает исключение и мы увидим сообщение, указывающее на это.

---

##### Самостоятельная работа

1. Воспроизведите структуру получившуюся в конце урока
2. Запустите тесты, убедитесь что они работают. Попробуйте их сломать
3. Добавьте код на гитхаб

## Утверждения (Asserts)—JS: Автоматическое тестирование

Каждую проверку, которую мы написали для функции `capitalize()`, в тестировании принято называть _утверждением_ (assert). Утверждения — ключевая часть тестов. Именно они проверяют функциональность кода:

```javascript
import capitalize from "../src/capitalize.js";

// Первое утверждение (проверка на пустую строку)
if (capitalize("") !== "") {
  throw new Error("Функция работает неверно!");
}

// Второе утверждение (проверка на слово)
if (capitalize("hello") !== "Hello") {
  throw new Error("Функция работает неверно!");
}
```

Можно заметить, что все проверки строятся одинаковым способом: условие => исключение. Node.js поставляется с модулем _assert_, в котором есть несколько функций, упрощающих написание утверждений:

```javascript
// Такой необычный импорт связан с тем,
// что assert, экспортируемый по умолчанию, считается устаревшим
// Правильно использовать strict
import { strict as assert } from "assert";
import capitalize from "../src/capitalize.js";

// Проверка сменилась с отрицательной на положительную
assert(capitalize("") === "");
assert(capitalize("hello") === "Hello");
```

В самом простом случае _assert_ используется как функция, которая проверяет истинность переданного значения. Другими словами, `assert(true)` означает, что всё хорошо, а `assert(false)` говорит об ошибке. Последний вариант выбрасывает исключение с таким сообщением:

```javascript
AssertionError [ERR_ASSERTION]: false == true
```

Расшифровка сообщения: "Ожидалось, что значением выражения будет истина, но оказалось, что это ложь". Кроме сообщения, выводится бектрейс, по которому можно найти сработавшее утверждение:

```javascript
// В данном случае assert сработал на 15 строчке файла capitalize.js
at first (file:///src/capitalize.js:15:19)
at default (file:///src/capitalize.js:11:3)
at file:///test.js:5:13
```

Функция `assert()` сделала наш код короче и проще для восприятия. Положительная проверка смотрится естественнее, так как это то, что мы ожидаем.

С другой стороны, вывод сообщения об ошибке крайне неинформативный. Единственный способ понять, что произошло — открывать код с упавшим утверждением (ещё есть вариант передать сообщение об ошибке последним параметром, но так не делают, потому что это слишком "ручной" способ, требующий больших усилий). Это пытаются исправить с помощью специализированных утверждений, заточенных под конкретные ситуации. Например, при сравнении двух значений подходит функция `assert.strictEqual(actual, expected)`. Перепишем код выше:

```javascript
import { strict as assert } from "assert";
// при использовании strict-режима
// проверка equal равносильна strictEqual

import capitalize from "../src/capitalize.js";

// Проверка сменилась с отрицательной на положительную
assert.equal(capitalize(""), "");
// Первый параметр actual – то, что пришло
// Второй параметр expected – то, что ожидает тест
// Правильный порядок аргументов имеет большое значение при анализе ошибки
assert.equal(capitalize("hello"), "Hello");
```

Вывод таких утверждений значительно понятнее:

```javascript
Thrown:
AssertionError [ERR_ASSERTION]: 'hello' == 'Hello'
  generatedMessage: true,
  code: 'ERR_ASSERTION',
  actual: 'hello',
  expected: 'Hello',
  operator: '=='
```

https://repl.it/@hexlet/js-testing-asserts-capitalize#tests/capitalize.test.js

В этом выводе есть не только информация об ошибке, но и данные, которые передавались в утверждение. Такой формат упрощает анализ проблемы и ускоряет отладку.

Однако, будьте осторожны. Функция `strictEqual(actual, expected)` проверяет равенство по ссылке. То есть два разных объекта, имеющих одинаковое содержание, рассматриваются как не эквивалентные:

```javascript
AssertionError [ERR_ASSERTION]: Values have same structure but are not reference-equal:

{
  key: 'value'
}

    at repl:1:8
    at Script.runInThisContext (vm.js:131:20)
    at REPLServer.defaultEval (repl.js:436:29)
    at bound (domain.js:429:14)
    at REPLServer.runBound [as eval] (domain.js:442:12)
    at REPLServer.onLine (repl.js:763:10)
    at REPLServer.emit (events.js:327:22)
    at REPLServer.EventEmitter.emit (domain.js:485:12)
    at REPLServer.Interface._onLine (readline.js:337:10)
    at REPLServer.Interface._line (readline.js:666:8) {
  generatedMessage: true,
  code: 'ERR_ASSERTION',
  actual: [Object],
  expected: [Object],
  operator: 'strictEqual'
}
```

Для сравнения по значению используется ещё одно утверждение: `assert.deepEqual(actual, expected)`. Оно опирается только на содержимое:

```javascript
assert.deepEqual({}, {}); // всё ок
assert.deepEqual({ key: "value" }, { key: "value" }); // всё ок
assert.deepEqual({ key: "value" }, { key: "another value" }); // Boom!
```

На самом деле правила проверки этой функции достаточно сложны. Подробнее об этом можно прочитать в [документации](https://nodejs.org/api/assert.html#assert_assert_deepstrictequal_actual_expected_message)

Для тестирования негативных сценариев предназначены функции `assert.notStrictEqual(actual, expected)` и `assert.notDeepStrictEqual(actual, expected)`. Они тестируют то, что значения не равны. Эти утверждения используются крайне редко, но знать о них всё равно полезно:

```javascript
assert.notDeepEqual({ a: 1 }, { a: "1" }); // OK!
```

https://repl.it/@hexlet/js-testing-asserts-methods#index.test.js

---

##### Самостоятельная работа

1. Посмотрите в конце урока ссылки на документацию на библиотеки утверждений
2. Замените в вашем репозитории ручные утверждения на использование модуля _assert_
3. Запустите тесты, убедитесь что они работают. Попробуйте их сломать
4. Добавьте код на гитхаб

---

##### Дополнительные материалы

1. [Asserts](https://nodejs.org/api/assert.html)
2. [Chai](https://chaijs.github.io/)

## power-assert—JS: Автоматическое тестирование

У обычных утверждений есть мощная альтернатива: [power-assert](https://github.com/power-assert-js/power-assert). Эта библиотека добавляет магию в привычный инструмент.

Вот пример проверки с использованием стандартного модуля _assert_:

```javascript
const user = {
  name: "Madonna",
  friends: ["Kate", "Michel"],
  email: "madonna@example.com",
};

assert(user.name === "Michel");

// AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:
//  assert(user.name === 'Michel')
```

В выводе видно само утверждение и результат проверки. Но непонятно, что за объект `user` и какая у него структура. Для получения этой информации придётся включаться в отладку. Но вместо этого можно воспользоваться библиотекой _power-assert_:

```javascript
import assert from "power-assert";

// Весь код остаётся тем же самым
const user = {
  name: "Madonna",
  friends: ["Kate", "Michel"],
  email: "madonna@example.com",
};

// Интерфейс библиотеки power-assert на 100% совместим со встроенным модулем assert.
assert(user.name === "Michel");
```

И посмотреть вывод:

```javascript
AssertionError [ERR_ASSERTION]:   ### test.js:10

  assert(user.name === 'Michel')
         |    |    |
         |    |    false
         |    "Madonna"
         Object{name:"Madonna",friends:#Array#,email:"madonna@example.com"}

  --- [string] 'Michel'
  +++ [string] user.name
  @@ -1,6 +1,7 @@
   M
  -ichel
  +adonna
```

Попробуйте остановиться и внимательно изучить этот вывод. Что здесь показано? _power-assert_ облегчает отладку настолько, насколько это вообще физически возможно. Он показывает значение каждого объекта и результат каждой операции, входящей в выражение, переданное в функцию _assert_. Кроме того, в конце он сравнивает строки и говорит, в чём конкретно было различие между ними.

Вот ещё один интересный пример из документации:

```javascript
import assert from "power-assert";

const array = [1, 2, 3];
const zero = 0;
const two = 2;

assert(array.indexOf(zero) === two);

// AssertionError [ERR_ASSERTION]:   ### test.js:7
//
//   assert(array.indexOf(zero) === two)
//          |     |       |     |   |
//          |     |       |     |   2
//          |     -1      0     false
//          [1,2,3]
//
//   [number] two
//   => 2
//   [number] array.indexOf(zero)
//   => -1
```

Впечатляет? Большинство современных фреймворков не выдаёт настолько удобный вывод, насколько это делает _power-assert_. Его можно интегрировать с чем угодно, но потребуются дополнительные инструменты, чтобы получить такое отображение - это Babel / Webpack или другие библиотеки, указанные [в документации](https://github.com/power-assert-js/power-assert#be-sure-to-transform-test-code). Пример использования _power-assert_ с Babel:

https://repl.it/@hexlet/js-testing-power-asserts-methods#index.test.js

Загрузите домашнее задание с помощью команды:

```bash
hexlet program download frontend-testing-react test-power-assert
```

## Jest—JS: Автоматическое тестирование

Когда тестов и файлов с тестами становится много, возникают новые вопросы. Как группировать тесты? Как запустить на выполнение все тесты из одной директории? Если их очень много и они долгие, можно ли запустить их параллельно?

Для решения этих вопросов используют специальные тестовые фреймворки. Они помогают организовать структуру тестов и дают много полезного, например, удобный вывод. С большинством из этих возможностей мы познакомимся далее по курсу. В JavaScript-мире наиболее популярен фреймворк _Jest_, разрабатываемый компанией Facebook. К слову, с помощью него мы тестируем все практики на Хекслете.

Ниже находится инструкция, в которой мы создадим с нуля npm-проект и добавим в него тесты.

### Настройка и запуск

Создайте где-нибудь на вашем компьютере директорию с названием _hexlet-jest_. Зайдите в неё и выполните команду:

```bash
npm init
```

Ответьте на все вопросы запущенного скрипта инициализации проекта. Убедитесь, что в корне проекта появился файл _package.json_.

Теперь добавим немного исходного кода. Создайте файл _src/index.js_ с таким содержимым:

```javascript
// Эта функция переворачивает переданную строку
export default (str) => str.split("").reverse().join("");
```

Jest — обычный npm-пакет, который локально подключается в разрабатываемый проект. Jest нужен только во время разработки, поэтому лучше установить его в секцию _devDependencies_:

```bash
### В директории с проектом
npm i --save-dev jest
```

Чтобы Jest корректно работал с системой модулей, добавьте в _package.json_ следующую опцию:

```json
  "type": "module"
```

Jest ожидает, что тесты находятся в директории \***\*tests\*\***, которую обычно располагают в корне проекта. Внутри этого каталога, можно создавать любую структуру, Jest найдёт все тесты, которые там лежат. Именование файлов с тестами должно быть таким: `<name>.test.js`. Где `<name>`, как правило, соответствует имени модуля, который тестируется.

Напишем наш первый тест. Создайте файл \***\*tests**/index.test.js\*\* со следующим содержимым:

```javascript
import reverse from "../src/index.js";

test("reverse", () => {
  expect(reverse("hello")).toEqual("olleh");
  expect(reverse("")).toEqual("");
});
```

Далее мы разберём структуру этого файла, а пока попробуем запустить тест на выполнение:

```bash
npx jest ### или NODE_OPTIONS=--experimental-vm-modules npx jest
 PASS  __tests__/index.test.js
  ✓ reverse (11ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        1.166s
Ran all test suites.
```

https://repl.it/@hexlet/js-testing-jest-babel#__tests__/index.test.js

Ура! Тесты прошли успешно.

### Структура

Давайте ещё раз посмотрим на файл с тестом:

```javascript
import reverse from "../src/index.js";

test("reverse", () => {
  const str = "hello";
  expect(reverse(str)).toEqual("olleh");
  expect(reverse("")).toEqual("");
});
```

Для тестов Jest предоставляет две глобальные функции: `test` и `expect`. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.

Функция `test` нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.

```bash
npx jest
 PASS  __tests__/index.test.js
  ✓ reverse (11ms) ### название теста
```

Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция `test` добавляет его внутрь Jest, который уже решает, как и когда запускать тесты. Это позволяет проводить различные оптимизации, например, выполнять тесты параллельно.

Самое необычное в этом коде — проверки. Jest использует "матчеры" (matchers). Это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы матчеров такой:

- Вызывается функция `expect()`, куда передаётся актуальное (фактическое) значение.
- На результате, возвращаемом функцией `expect()`, вызывается подходящий матчер, например, `toEqual`.

Код с матчерами похож на обычные предложения на английском языке. Это сделано специально, чтобы их могли читать даже не программисты:

```javascript
// Ожидается, что результат выражения reverse('hello') равен 'olleh'
expect(reverse("hello")).toEqual("olleh");
```

Подробнее о матчерах в следующем уроке.

Одна из приятнейших особенностей Jest — то, как он выводит сообщения о проваленных проверках. Попробуйте внести ошибку в исходную функцию и запустите тесты заново:

```bash
 npx jest
 FAIL  __tests__/index.test.js
  ✕ reverse (9ms)

  ● reverse

    expect(received).toEqual(expected) // Object.is equality

    Expected: "olleh"
    Received: "o|l|l|e|h"

      3 | test('reverse', () => {
      4 |   const str = 'hello';
    > 5 |   expect(reverse(str)).toEqual('olleh');
        |                        ^
      6 | })
      7 |

      at Object.toEqual (__tests__/index.test.js:5:24)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.683s
Ran all test suites.
```

В этом выводе показаны не только ожидаемое и фактическое значение, но и исходный код файла с тестами с указанием на конкретную проверку. Это невероятно полезная фишка, которая значительно ускоряет анализ результатов тестирования и помогает в отладке.

---

##### Самостоятельная работа

1. Выполните все шаги из этого урока
2. Залейте код на Гитхаб
   Пример полностью настроенного пакета: https://github.com/hexlet-boilerplates/nodejs-package

---

##### Дополнительные материалы

1. [Jest](https://jestjs.io/)
2. [Блоки тестов (Describe)](https://jestjs.io/docs/ru/api#describename-fn)
3. [Курс "JS: Настройка окружения"](https://ru.hexlet.io/courses/js-setup-environment)

## Матчеры (Expectations)—JS: Автоматическое тестирование

Существует несколько популярных способов описывать утверждения. Кроме вызова обычных функций, популярностью пользуются "матчеры", которые внешне выглядят как мини-язык для описания проверок.

Матчеры стали популярны в тестовых фреймворках после появления подхода [BDD](<https://ru.wikipedia.org/wiki/BDD_(программирование)>) (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. Это даёт возможность использовать их как документацию людям, которые не умеют программировать (В идеале, на практике всё сложнее). Матчеры заменили собой обычные утверждения на функциях во многих языках:

```javascript
// Проверка равенства по ссылке
// assert.equal([1, 2], [1, 2])
expect([1, 2]).toBe([1, 2]); // false

// Проверка равенства по значению
// assert.deepEqual([1, 2], [1, 2])
expect([1, 2]).toEqual([1, 2]); // true
```

Любой матчер в Jest начинается с функции `expect(data)`, в которую передаются данные на проверку. Затем `expect` возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. В Jest десятки матчеров для самых разнообразных ситуаций. Такое количество объясняется желанием выдавать максимально точный отчёт о том, что произошло.

Предположим, что функция возвращает массив и мы хотим проверить его размер. Для этого можно воспользоваться матчером `toBe`:

```javascript
const data = [1, 2, 3];
// take берет первые n элементов
// assert.equal(take(data, 2).length, 2)
expect(take(data, 1).length).toBe(2);
```

Этот матчер прекрасно справится с задачей. Но в случае ошибки его вывод не слишком информативен:

```javascript
expect(received).toBe(expected); // Object.is equality

Expected: 2;
Received: 1;
```

Поэтому лучше взять специализированный матчер для проверки размера массива:

```javascript
expect(take(data, 1)).toHaveLength(2);
```

Тогда вывод расскажет гораздо больше:

```javascript
expect(received).toHaveLength(expected)

Expected length: 2
Received length: 1
Received array:  [1]
```

Благодаря тому, что в `expect` передаётся сам массив, а не его длина, у Jest появляется возможность выводить содержимое массива в случае ошибки. Это, опять же, упрощает отладку.

Ниже пример некоторых популярных матчеров, полезных в ежедневном тестировании:

```javascript
expect(null).toBeNull();

// Проверяет значение на truthy (любое значение, которое приводится к true)
expect(true).toBeTruthy();
// Точное сравнение с true
expect(true).toBe(true);

expect(undefined).toBeUndefined();

// Проверка, что массив содержит элемент
expect([1, 2, 3]).toContain(2);

// Проверка, что строка содержит подстроку
expect("hello, world").toMatch("hello");

// Проверяет, что в объекте есть свойство с определённым значением
expect({ key: "value" }).toHaveProperty("key", "value");
```

Кроме того, к любому матчеру можно применить модификатор `not`, который инвертирует поведение матчера:

```
expect(null).not.toBeNull(); // not null
expect(undefined).not.toBeUndefined(); // not undefined
expect([1, 2, 3]).not.toContain(2); // not contain 2
expect('hello, world').not.toMatch('hello'); // not match hello
```

https://repl.it/@hexlet/js-testing-matchers-expect#index.test.js

Особняком стоит матчер `toMatchObject`. Он используется, когда нас в тестах интересует не весь объект, а только какая-то его часть:

```javascript
const user = {
  firstName: "tolya",
  lastName: "petrov",
  age: "33",
};

// Тест пройдёт успешно, так как проверяется только firstName
expect(user).toMatchObject({ firstName: "tolya" });
```

Это далеко не все матчеры, которые есть в Jest. Более того, Jest достаточно гибкий и может расширяться собственными матчерами. На Гитхабе можно найти библиотеки с матчерами для разных ситуаций.

В целом, вам придётся постоянно заглядывать в документацию, чтобы вспомнить, что там есть. Иначе всё может свестись к использованию `toEqual`. Пожалуй, это основной недостаток использования матчеров — необходимость помнить про них и правильно применять.

---

##### Дополнительные материалы

1. [Матчеры Jest](https://jestjs.io/docs/ru/expect)

## Модульные тесты—JS: Автоматическое тестирование

Изученной информации уже достаточно для тестирования в повседневной практике разработки. Перед тем, как погружаться в более сложные темы и возможности Jest, пройдём полный путь тестирования библиотеки, поговорим об организации тестов, хороших и плохих практиках. Это поможет сформировать правильное отношение к тестированию в целом.

В этом уроке мы разберём основы модульного тестирования. Это тестирование направлено на проверку модулей программы в изоляции от всех остальных частей. Эти тесты обычно тестируют базовые конструкции языка: функции, модули, классы. Такие тесты не дают никаких гарантий работы всего приложения в целом, но хорошо помогают тогда, когда какой-то модуль программы имеет сложную логику.

Попробуем протестировать [стек](https://ru.wikipedia.org/wiki/Стек). Напомню, что стек представляет собой список элементов организованных по принципу LIFO. Данные кладутся в стек в одном порядке, а извлекаются в обратном. Сам стек, как правило, используется для реализации алгоритмов. Он часто используется в низкоуровневом коде: например, внутри языков программирования или в операционных системах.

```javascript
import makeStack from "../src/stack.js";

const stack = makeStack();
stack.isEmpty(); // true
stack.push(1); // (1)
stack.push(2); // (1, 2)
stack.push(3); // (1, 2, 3)
stack.isEmpty(); // false
stack.pop(); // 3. В стеке (1, 2)
stack.pop(); // 2. В стеке (1)
stack.pop(); // 1. В стеке пусто
stack.isEmpty(); // true
```

Сначала решим организационные вопросы. Если предположить, что реализация стека лежит в файле _src/stack.js_, то его тест мы положим в файл _**tests**/stack.test.js_.

### Тестируем основную функциональность

Теперь напишем первый тест. Первый тест всегда должен проверять позитивный сценарий — тот, в котором задействована основная функциональность тестируемого компонента:

```javascript
import makeStack from "../src/stack.js";

test("stack's main flow", () => {
  const stack = makeStack();
  // Добавляем два элемента в стек и затем извлекаем их
  stack.push("one");
  stack.push("two");
  expect(stack.pop()).toEqual("two");
  expect(stack.pop()).toEqual("one");
});
```

Этот тест проверяет, что правильно работают два основных метода без учёта пограничных случаев. Для этого внутри теста выполняются два матчера, которые по очереди проверяют извлекаемые значения из стека.

В интернете можно встретить мнение, что несколько проверок в рамках одного теста это неправильно. Что тесты нужно детализировать максимально подробно и создавать новый тест на каждую проверку.

```javascript
test("stack's main flow", () => {
  const stack = makeStack();
  stack.push("one");
  stack.push("two");
  expect(stack.pop()).toEqual("two");
});

test("stack's main flow", () => {
  const stack = makeStack();
  stack.push("one");
  stack.push("two");
  stack.pop();
  expect(stack.pop()).toEqual("one");
});
```

Такой подход нередко приводит к серьёзному раздуванию кода и дублированию. А выгода не очевидна. Что по-настоящему надо выделять в отдельный тест, так это другой сценарий, которому нужны другие данные и который выполняет другую последовательность действий.

### Тестируем дополнительную функциональность

Следующим тестом будет тест на дополнительные функции стека. К таким у нас относится функция `isEmpty()`, которая проверяет, пустой ли стек:

```javascript
test("isEmpty", () => {
  const stack = makeStack();
  expect(stack.isEmpty()).toBe(true);
  stack.push("two");
  expect(stack.isEmpty()).toBe(false);
  stack.pop();
  expect(stack.isEmpty()).toBe(true);
});
```

В этом тесте проверяются сразу три ситуации:

- начальное состояние стека
- состояние стека после добавления элементов
- состояние стека после извлечения всех элементов

В принципе, этого достаточно. Хотя в теории возможны ситуации, при которых `isEmpty()` всё равно сломается. Нужно ли пытаться найти все варианты? Не нужно. Тесты не даются бесплатно, каждая написанная строчка кода в проекте — потенциальное место для изменения в случае правок. Если есть сомнения, нужно ли писать проверку или нет, то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после которого тесты писать не эффективно. Редкие ситуации требуют покрытия тестами только тогда, когда они критичны для работоспособности.

#### Пограничные случаи

Ну, и последнее, что можно протестировать — поведение функции `pop()`, когда в стеке нет ни одного элемента. По задумке, стек выбрасывает исключение, если из него попытались взять элемент, когда тот был пустой. То есть эта ситуация рассматривается как ошибочная, программист всегда должен убеждаться в том что стек не пустой.

```javascript
test("pop in empty stack", () => {
  const stack = makeStack();
  // Вызов метода pop обёрнут в функцию
  // иначе матчер не сможет перехватить исключение
  expect(() => stack.pop()).toThrow();
});
```

[https://repl.it/@hexlet/js-testing-unit-tests-stack#**tests**/stack.test.js](https://repl.it/@hexlet/js-testing-unit-tests-stack#__tests__/stack.test.js)

Но не всегда пограничные случаи так легко увидеть. Маловероятно, что любой программист сможет сразу написать все нужные тесты. Если в коде возникла ошибка, для которой не было теста, то сначала напишите тест, который воспроизводит эту ошибку, и затем уже чините её. Только так можно поддерживать достаточный уровень надёжности, не превращая разработку в непрерывную починку багов.

### Домашнее задание

Загрузите домашнее задание с помощью команды:

```bash
hexlet program download frontend-testing-react unit-testing
```

---

##### Дополнительные материалы

1. [Чек-лист хороших инженерных практик в компаниях](https://guides.hexlet.io/check-list-of-engineering-practices/)

## Подготовка данных—JS: Автоматическое тестирование

Большинство тестов на одну и ту же функциональность сильно похожи друг на друга. Особенно в части начальной подготовки данных. В прошлом уроке каждый тест начинался со строчки: `makeStack()`. Это ещё не дублирование, но уже шаг в эту сторону. Как правило, реальные тесты сложнее и включают в себя большую подготовительную работу.

Допустим, мы разрабатываем библиотеку [Lodash](https://lodash.com/docs/) и хотим протестировать её функции для обработки коллекций:

- find
- filter
- includes
- и другие (всего их около 20 штук)

Для работы этих функций нужна заранее подготовленная коллекция. Проще всего придумать одну, которая подойдёт для тестирования большинства или даже всех функций:

```javascript
import _ from "lodash";
test("includes", () => {
  // Подготовили коллекцию coll
  const coll = ["One", true, 3, 10, "cat", {}, "", 10, false];

  // Используем coll для тестирования
  expect(_.includes(coll, 3)).toBe(true);
  expect(_.includes(coll, 11)).toBe(false);
});
```

Теперь представьте, что таких тестов несколько десятков (в реальности их сотни). Код начнёт кочевать из одного места в другое, порождая всё больше и больше копипасты.

Самый простой способ избежать этого — вынести определение коллекции на уровень модуля, вне тестовых функций:

```javascript
import _ from "lodash";

const coll = ["One", true, 3, 10, "cat", {}, "", 10, false];

test("includes", () => {
  expect(_.includes(coll, 3)).toBe(true);
  expect(_.includes(coll, 11)).toBe(false);
});
```

Это простое решение убирает ненужное дублирование. Однако учтите, оно работает только в рамках одного модуля. Подобную коллекцию всё равно придётся определять в каждом тестовом модуле. И в нашем случае это скорее плюс, а не минус.

Дело в том, что излишнее обобщение, приводящее к полному устранению дублирования, вводит неявные зависимости в код. Изменение этой коллекции почти наверняка приведёт к поломке большинства тестов, которые завязаны на её структуру, на количество элементов и их значения:

```javascript
import _ from "lodash";

const coll = [1, 2, 3, 4];

test("filter", () => {
  // Выбираем только чётные
  expect(_.filter(coll, (v) => v % 2 === 0)).toEqual([2, 4]);
});
```

Тест выше сломается, если мы добавим в нашу коллекцию еще одно чётное число. А коллекцию почти наверняка придётся расширять при добавлении новых тестов (для этой же или других функций).

Главный вывод из этого: устранять дублирование надо. Но важно не перейти границу, после которой обобщение начинает больше мешать, чем помогать.

Но далеко не всегда можно выносить константы на уровень модуля. В первую очередь это касается динамических данных. Представьте себе такой код:

```javascript
const now = Date.now(); // текущий timestamp

test("first example", () => console.log(now));
test("second example", () => console.log(now));

//  console.log __tests__/index.test.js:3
//    1583871515943
//
//  console.log __tests__/index.test.js:4
//    1583871515943
```

Подвох тут в том, что модуль загружается в память ровно один раз. Это значит, что весь код, определённый на уровне модуля (включая константы), выполняется ровно один раз. В примере константа `now` определится до запуска всех тестов, и только затем _jest_ начнёт выполнять тесты. И с каждым последующим тестом отставание значения константы `now` от текущего реального значения "сейчас" будет всё дальше и дальше.

Почему это может быть проблемой? Код, который работает с понятием "сейчас", может рассчитывать на то, что "сейчас" это почти моментальный снимок данного момента времени. Но в примере выше, сейчас начинает отставать от реального сейчас и чем больше тестов и чем они сложнее, тем большее отставание.

_Важно не забыть: функция test не запускает тест на выполнение. Она добавляет его во внутрь Jest, а вот он уже решает, когда выполнить этот тест. Поэтому между загрузкой модуля и отработкой тестов проходит неопределённое время._

Для решения этой проблемы тестовые фреймворки предоставляют **хуки** — специальные функции, которые запускаются до или после тестов. Ниже пример того, как создавать дату перед каждым тестом:

```javascript
let now;

// Запускается перед каждым тестом
beforeEach(() => {
  now = Date.now(); // текущий timestamp
});

test("first example", () => console.log(now));
test("second example", () => console.log(now));

//  console.log __tests__/index.test.js:9
//    1583871515943
//
//  console.log __tests__/index.test.js:10
//    1583871515950
```

https://repl.it/@hexlet/js-testing-setup-globals#index.test.js

`beforeEach(callback)` принимает на вход функцию, внутри которой выполняется инициализирующее действие. Оно не обязательно приводит к созданию переменных. Возможно, инициализация заключается в подготовке файловой системы, например, создании файлов.

Но если она должна создать данные и сделать их доступными в тестах, то придётся использовать переменные, определённые на уровне модуля. Так как всё, что определяется внутри функций (колбека в нашем случае), остаётся внутри этой функции.

Даже если нам нужно выполнить код один раз перед всеми тестами, его все равно нужно выполнять не на уровне модуля, а внутри хука `beforeAll(callback)`. Этот хук запускается ровно один раз перед всеми тестами, расположенными в одном модуле.

```javascript
import fs from "fs";

let fileData;

beforeAll(() => {
  fileData = fs.readFileSync("path/to/file");
});

// Такой вызов на уровне модуля (вне хуков), в общем случае, считается неправильным подходом
// fileData = fs.readFileSync('path/to/file');
```

Почему это важно? Чтобы ответить на этот вопрос, нам нужно знать немного больше про асинхронную природу JavaScript. Этот вопрос разбирается в курсах позже, а пока можно ограничиться вот чем: Jest должен контролировать происходящие процессы и побочные эффекты в тестах. Все, что вызывается на уровне модуля, отрабатывает вне Jest. Это значит, что Jest никак не может отследить, что происходит, и в какой момент можно запускать тесты.

---

##### Дополнительные материалы

1. [Jest methods](https://jestjs.io/docs/en/api#methods)

## Плохие и хорошие практики тестирования—JS: Автоматическое тестирование

Тесты, как и любой другой код, можно писать по-разному, в том числе очень плохо. Помимо каких-то общих практик и стандартов кодирования у тестов есть свои особенности, о которых надо знать. В этом уроке мы пройдёмся по некоторым из них.

### Взаимное влияние тестов

Одно из ключевых правил: тесты не должны влиять друг на друга. Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.

Нарушить это правило очень просто. Один тест может создать файл, изменить переменную или записать что-то в базу. Если остальные тесты наткнутся на эти изменения, то они могут упасть там, где не должны падать, или наоборот — успешно пройти там, где не должны проходить. Кроме этого, в такой ситуации вводится неопределённость. Такие тесты могут падать эпизодически без видимых на то причин. Например, когда тест запускают изолированно, то он работает, а когда вместе с остальными — падает:

```javascript
let user;

test("first", () => {
  user = { name: "Vasya" };
  // ...
});

test("second", () => {
  // Используется пользователь, которого создал другой тест!
  // Этот тест зависит от того, как работает предыдущий тест,
  // и не может работать без последовательного запуска обоих тестов.
  user.name = "Petya";
});
```

Особенно часто такая ситуация возникает в тестах, активно взаимодействующих с внешней средой: базой данных или файловой системой. Тестирование побочных эффектов имеет свои хитрости и рассматривается в [курсе по продвинутому тестированию](https://ru.hexlet.io/courses/js-advanced-testing).

### Условные конструкции в тесте

```javascript
test('something', () => {
  if (/* что-нибудь */) {
    // Выполняем код одним способом
    // Проверка может быть тут
  } else {
    // Выполняем код другим способом
    // Проверка может быть тут
  }
  // Проверка может быть тут
});
```

Любое ветвление внутри тестов это фактически несколько тестов в рамках одного теста. От этого надо избавляться и никогда так не писать.

### Тест вне тестов

Задача `beforeEach` — готовить данные и среду для тестирования, а задача `test` — вызывать код, который тестируется, и проводить проверки. Но иногда разработчики переусердствуют:

```javascript
let result;

beforeEach(() => {
  // Вызывается тестируемый код. Это противоречит идее beforeEach.
  result = sum(5, 9);
});

test("result", () => {
  // Здесь только проверка
  expect(result).toEqual(14);
});
```

В этом примере тестируемый код вызывается в `beforeEach`. Такой подход усложняет анализ тестов, так как переворачивает всё с ног на голову.

### Слишком сильная детализация

Программисты под влиянием голосов из интернета стремятся максимально разносить код по файлам, модулям и функциям. То же самое наблюдается и в тестах. Вместо одного теста, в котором содержатся все необходимые проверки, программист создаёт 5 тестов, в каждом из которых ровно одна проверка:

```javascript
test("create user", () => {
  const user = { name: "Mark", age: 28 };

  // Тут код, добавляющий пользователя в базу данных

  expect(user.age).toEqual(28);
});
test("create user 2", () => {
  const user = { name: "Mark", age: 28 };

  // Тут код, добавляющий пользователя в базу данных

  expect(user.name).toEqual("Mark");
});
```

Чаще всего, единственным результатом такого разделения будет большее количество кода и усложнение рефакторинга в будущем, когда кода станет по-настоящему много.

### Глубокая вложенность

Jest позволяет группировать тесты в блоки `describe`:

```javascript
describe("User", () => {
  test("should be valid", () => {
    /* ... */
  });
});
```

Они помогают структурировать сложные тесты и задать для каждого блока `describe` свой собственный `beforeEach`. Хотя такая возможность бывает полезна, но очень легко начать использовать её во вред:

```javascript
describe("", () => {
  describe("...", () => {
    describe("...", () => {
      test("should be valid", () => {
        /* ... */
      });
    });
  });
});
```

Глубокая иерархия тестов очень тяжело поддаётся анализу и фиксирует структуру. Из-за этого возникают сложности при добавлении новых проверок. Становится непонятно, к чему она относится. Это проблема любых иерархий, которые рассматривают систему только с одной точки зрения.

### Код с тестами писать дольше, чем код без тестов

Это очень интересный вопрос, по которому можно понять, насколько хорошо программист умеет писать тесты. Несмотря на то, что некоторые виды тестирования действительно сложны и требуют дополнительного времени, ежедневные тесты, которые пишутся вместе с кодом, должны приводить к ускорению разработки. И на это есть пять причин:

- Тесты влияют на дизайн кода. Они помогают выявить неудачные решения намного раньше.
- Подготовка входных данных может занимать значительное время. С тестами это нужно сделать один раз.
- Проверка результата работы кода может быть сложной и разнообразной. Тесты позволяют об этом не думать, они сами проверяют, что всё хорошо, включая пограничные случаи.
- Если в проекте тесты пишутся регулярно, то проще и быстрее делать рефакторинг, так как не придётся проверять вручную другие части кода.
- Тесты снижают уровень стресса.

---

##### Дополнительные материалы

1. [Начинаем писать тесты правильно](https://www.youtube.com/watch?v=zsz8kdi62mE)

## Покрытие кода тестами (Code Coverage)—JS: Автоматическое тестирование

С ростом проекта, определить какой код протестирован, а какой нет, становится сложно, хотя подобная потребность возникает регулярно. Обычно это происходит тогда, когда в команде есть разные люди и не все из них ответственно подходят к написанию тестов. В таком случае может страдать качество проекта.

Протестированность кода можно измерить. Для этого используют метрику "покрытие кода тестами" (code coverage). Покрытие анализируется тестовыми фреймворками, которые считают отношения строчек, задействованных в тестах, ко всем строчкам исходного кода. Например, если в коде есть условная конструкция, и она не проверяется тестами, это значит, что все строки кода, входящие в неё, не будут покрыты.

В Jest покрытие измеряется крайне просто. Достаточно запустить тесты с флагом `--coverage`:

```bash
npx jest --coverage

PASS  __tests__/half.test.js
 ✓ half (3ms)

----------|----------|----------|----------|----------|-------------------|
File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
----------|----------|----------|----------|----------|-------------------|
All files |    71.43 |      100 |    66.67 |    71.43 |                   |
 half.js  |       60 |      100 |       50 |       60 |             12,13 |
 index.js |      100 |      100 |      100 |      100 |                   |
----------|----------|----------|----------|----------|-------------------|
Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        2.236s
Ran all test suites.
```

После выполнения всех тестов, Jest выводит сводную таблицу по каждому файлу. В ней показан процент покрытия кода тестами. В примере выше видно что в файле _index.js_ покрыто 100% кода, а вот в файле _half.js_ только 60%. При этом общее покрытие кода 71.43%. Обратите внимание, что покрытие сильно зависит от того, какие тесты выполнились. Если часть из них упала с ошибками, то Jest покажет намного меньшее покрытие, так как тесты просто не доберутся до всего кода. Поэтому покрытие меряют только тогда, когда все тесты зелёные.

Эта статистика помогает найти места, где тестов мало. Дальше по ситуации их можно начинать добавлять. Если в проекте тестов не было вообще, то эта статистика начинает быстро расти. А вот дальше, ближе к 90 процентам, придётся бороться за каждую строчку кода.

Однако покрытие само по себе не гарантирует, что покрытый код работает правильно во всех ситуациях. Логические ошибки в коде невозможно отследить только покрытием. Для этого нужны тесты на одну и ту же функциональность, но с разным набором данных. Как правило, это тесты на пограничные случаи. В разработке есть хорошая практика: перед тем как чинить баги, сначала нужно написать тесты, которые их воспроизводят, и только затем уже можно починить их.

Какое покрытие считается допустимым? 100% покрытия выглядит красиво, но добиться его невероятно сложно. И для большинства проектов бессмысленно. Затраченные усилия не окупятся. Большинство разработчиков сходится во мнении, что 80% — это достаточно хорошее покрытие. На этом можно и остановиться.

---

##### Самостоятельная работа

1. клонируйте себе репозиторий [nodejs-package](https://github.com/hexlet-boilerplates/nodejs-package)
2. запустите тесты, посмотрите на их вывод
3. добавьте флаг `--coverage` при запуске тестов, посмотрите как изменился вывод

## Разработка через тестирование (TDD)—JS: Автоматическое тестирование

В какой момент лучше писать тесты? Вообще, существует три подхода:

- Тесты пишутся после кода
- Тесты пишутся вместе с кодом
- Тесты пишутся до кода

В некоторых ситуациях особого выбора нет. Например, при системном тестировании, когда тест имитирует поведение пользователей и выполняет действия в браузере. Такие тесты пишутся после кода.

В тестах более низкого уровня, интеграционных и модульных тестах, обычно можно выбирать из вариантов описанных выше. И подход "писать тесты после кода" относится к наименее полезным. Почему?

Сам процесс написания кода связан с постоянным запуском кода и проверкой того, что он работает. В самых простых, например, учебных задачах, этот запуск происходит довольно быстро.

```javascript
// Легко запустить, легко проверить, что результат правильный
capitalize("hello"); // Hello
```

В реальном коде подготовка данных для проверки работы кода может занимать значительное время, минуты и десятки минут. С другой стороны, результатом работы проверяемого кода может быть что-то сложное, например, множество записей в базе данных или вывод определённой непростой структуры. Тогда каждый запуск кода на проверку превращается в целое приключение.

```javascript
// Сложно подготовить данные. Сложно проверить результат работы.
// Загрузка товаров из 1C в базу данных
loadGoodsFrom1c();
```

Именно здесь на сцену выходит вариант "писать тесты до кода". У многих начинающих разработчиков, эта фраза вызывает ступор. Как можно писать тесты до того, как был написан код? Оказывается, можно и это даже приятно.

Допустим, мы хотим написать функцию, которая может повторять переданную строчку указанное количество раз:

```javascript
repeat("$", 3); // $$$
```

Мы знаем, что она принимает на вход, мы знаем, какой у неё должен быть выход (спасибо, что ты [чистая](https://ru.wikipedia.org/wiki/Чистота_функции)). Можем ли мы уже написать тесты? Конечно!

```javascript
test("repeat", () => {
  expect(repeat("$", 3)).toBe("$$$");
});
```

Сколько займёт времени написать такой тест у опытного разработчика? Думаю секунд 15, именно столько времени мне понадобилось для кода выше. Зато теперь для проверки работы этого кода достаточно набрать `jest` в консоли.

У тестирования до написания кода есть ещё одно мощное преимущество. Оно заставляет программиста в первую очередь думать о дизайне своего решения, о том, как им будут пользоваться. А не о том, как красиво он реализует всё внутри. Грамотные интерфейсы – залог успеха.

В мире разработки подход, при котором тесты пишутся до кода, называется Test-Driven Development (TDD).

![Разработка через тестирование](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImNhOTRmNWMyYTRjMTI0NTM2ZDBiYjQ3NzJlMzE0OGJhLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=11a2a4518957adee61d9922ac839f9285804b2d5b86b80be0ef4c2cb18005ddf)

TDD по задумке изобретателя этой техники подразумевает, что вся разработка состоит из повторяющегося цикла, где на каждой итерации пишется тест, который не проходит, затем дописывается код, удовлетворяющий данному тесту. После этого всё повторяется. Так, шаг за шагом, строится приложение.

_Сейчас все по инерции продолжают говорить именно о таком способе. В нём тесты пишутся на все части кода с максимальной детализацией. Этот вид TDD хоть и говорит о важности дизайна, но фокусируется на конкретных функциях и классах приложения вместо цельной картины. Но есть и другое TDD, где тесты на внутренние части не пишутся почти никогда. Подробнее об этом в статье в дополнительных материалах._

Сам по себе Хекслет — яркий пример того, как тесты пишутся до кода. Абсолютно во всех наших практиках на всех языках тесты есть, а кода нет :)

---

##### Дополнительные материалы

1. [Начинаем писать тесты правильно](https://ru.hexlet.io/blog/posts/how-to-test-code)
2. [Начинаем писать тесты правильно (Видео)](https://www.youtube.com/watch?v=zsz8kdi62mE)

## Непрерывная интеграция (CI)—JS: Автоматическое тестирование

Локальный запуск тестов – персональная ответственность. Хорошие разработчики используют тесты непрерывно во время разработки и обязательно запускают их перед пушем (`git push`).

Но этого недостаточно. Там, где есть люди, присутствует человеческий фактор и ошибки. Поэтому, даже несмотря на локальный запуск, тесты должны запускаться автоматически на серверах непрерывной интеграции.

Непрерывная интеграция – практика разработки, которая заключается в частой автоматизированной сборке приложения для быстрого выявления проблем. Обычно интеграция выполняется на коммиты в репозиторий. За этим следит либо специальный сервер, либо сервис непрерывной интеграции. Он загружает код, собирает его (если это нужно для текущего приложения) и запускает различные проверки. Что и как запускать – определяется программистом. В первую очередь это тесты и линтер (проверка оформления кода). Кроме них могут запускаться утилиты, анализирующие безопасность, актуальность зависимостей и многое другое.

![Сервер непрерывной интеграции GitHub Actions Travis](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImIxOTYyMDZlZjFhNWU4OGFmNzUzNzM1YzVkMmUyNWQwLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=2fcb68000da71e1c362d9ca33e7947bf126e0e433a9d162fcdb7be0a290dd0e8)

Немного терминологии и описание процесса. На каждый коммит запускается сборка (build). Во время сборки собирается приложение, устанавливаются зависимости, прогоняются тесты и все остальные проверки. Сборка, завершившаяся без ошибок, считается успешной. Если сборка не проходит, то программист получает уведомление. Дальше он смотрит отчёт и исправляет ошибки.

Для внедрения непрерывной интеграции есть два пути. Первый, поставить себе на сервер Jenkins или его аналог. Этот вариант требует много ручной работы (плюс поддержка сервера). Он подходит компаниям, в которых очень сложные приложения, или они не хотят допускать утечки кода наружу, или у них настолько много проектов, что свой сервер дешевле, чем стороннее решение. Второй путь – воспользоваться сервисом непрерывной интеграции. Таких сервисов десятки, если не сотни. Есть из чего выбрать. Как правило, большинство из них бесплатны для открытых проектов.

### Github Actions

GitHub Actions — бесплатная система, которая позволяет автоматизировать какие-либо действия, важные для процесса разработки. Она обеспечивает непрерывную интеграцию (но может гораздо больше). Хекслет использует Actions во всех своих открытых и закрытых проектах ([пример](https://github.com/hexlet-boilerplates/nodejs-package)). С её помощью можно запускать определенный код каждый раз, когда происходит некое событие.

Например:

- запустить проверку кода линтером и тестами
- отправить код на сервер (деплой)
- подключить оповещения в мессенджер о событиях в репозитории (новые issue, PR)
- и многое другое

В этом уроке мы разберёмся в основных концепциях системы, а затем рассмотрим пример настройки, чтобы быстро начать работу с Actions в своём репозитории.

![Github Actions](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjM4NzkxZGQyYjMxMGI3ZjU3YTRhYTMyOTEyZTBiMDRjLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e333a1ace03ae0b2e432838fb15f65b3a8febdbba638f19cae1daf045d896b81)

Для удобства, GitHub Action предоставляет "бейджик" — картинку, которая вставляется в файл проекта _README.md_. Она показывает текущий статус проекта (успешно завершено последнее задание или нет), и по клику на неё можно попасть на страницу с результатами выполнения задания.

#### Основные понятия

Начнём с основ. На картинке ниже показаны основные концепции GitHub Actions. Разберем их по порядку.

![Основные концепции Github Actions](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjkzMTg4NmZiNTE3ZWM0NThkNDc5NTQ4YzI3ODYyNmY0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=301ec7d7be9c376f599e3b96ea1829950934d6a71a271bf55d44140cb8b7dd77)

- Воркфлоу / Workflows

  Каждый репозиторий на GitHub может содержать один или несколько воркфлоу. Каждый воркфлоу определяется в отдельном файле конфигурации в каталоге репозитория _.github/workflows_. Несколько воркфлоу могут выполняться параллельно.

- События / Events

  Воркфлоу может запускаться одним или несколькими событиями. Это могут быть внутренние события GitHub (например, пуш, релиз или пул-реквест), запланированные события (запускаются в определенное время — например, cron), или произвольными внешними событиями (запускаются вызовом Webhook API GitHub).

- Задания / Jobs

  Воркфлоу состоит из одного или нескольких заданий. Задание содержит набор команд, которые запускаются вместе с рабочим процессом. По умолчанию при запуске воркфлоу все его задания выполняются параллельно, однако между ними можно определить зависимость, чтобы они выполнялись последовательно.

- Раннеры / Runners

  Каждое задание выполняется на определённом раннере, — временном сервере на GitHub с выбранной операционной системой (Linux, macOS или Windows). Также существуют [автономные раннеры](https://docs.github.com/en/actions/hosting-your-own-runners), которые позволяют создать своё окружение для выполнения экшена.

- Шаги / Steps

  Задания состоят из последовательности шагов. Шаг — это либо команда оболочки (shell command), либо экшен (action). Все шаги задания выполняются последовательно на раннере, связанном с заданием. По умолчанию в случае сбоя шага все следующие шаги задания пропускаются.

- Экшен / Actions

  Экшен — многократно используемый блок кода, который может служить шагом задания. Каждый экшен может принимать на вход параметры и создавать любые значения, которые затем можно использовать в других экшенах. Разработчики могут создавать собственные экшены или использовать опубликованные сообществом GitHub. Общих экшенов около тысячи, все они доступны на [GitHub Marketplace](https://github.com/marketplace?type=actions).

#### Пример воркфлоу. Hello, World!

Этот воркфлоу не делает ничего особенного — он просто показывает фразу _Hello, World!_ в стандартном выводе runner всякий раз, когда происходит отправка кода в репозиторий. Вот как выглядит код этого воркфлоу:

```bash
name: hello-world
on: push
jobs:
  my-job:
    runs-on: ubuntu-latest
    steps:
      - name: my-step
        run: echo "Hello World!"
```

Разберём его в деталях:

- Имя воркфлоу `hello-world`, определяется полем [name](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#name).
- Воркфлоу запускается событием [push](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#push), которое определяет поле [on](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#on).
- Воркфлоу содержит одно задание с идентификатором my-job — в нём указано имя задания.
- В задании `my-job` используется runner `ubuntu-latest` из GitHub Marketplace — он определяется полем [runs-on](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on).
- Задание `my-job` содержит один шаг с именем `my-step`. На этом шаге выполняется [команда оболочки](<https://en.wikipedia.org/wiki/Shell_(computing)>) _echo_ — в нашем случае это _"Hello World!"_.

_Все элементы синтаксиса для определения воркфлоу можно найти на странице [справки по синтаксису воркфлоу в документации](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions) GitHub Actions._

Практическая польза от этого воркфлоу минимальна, но он нужен для тренировки: попробуем интегрировать его в репозиторий на GitHub. Сначала в репозитории нужно создать каталог с именем _.github/workflows_, а затем скопировать в него указанный выше код, сохранить и отправить изменения на GitHub.

Затем переходим во вкладку actions и в левой части экрана в списке рабочих процессов ищем «hello-world». Воркфлоу запускается при пуше — информация об этом показана в правой части экрана.

![Вкладка Actions](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjVhYTEzNDU5MTMwYmNiNTM2YWM2YTRhNDU0ZWIwMzk2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e6deb4ba6f9b908cb7a1d71e2d0b743af34e1adcd82b90ad7dd28378ed1df6ab)

Теперь каждый раз при пуше в репозиторий на GitHub этот воркфлоу будет запускаться автоматически, а информация об этом появится в правой верхней части экрана.

Если вы хотите проверить корректность запуска, откройте уведомление — на новом экране будет показаны все задания воркфлоу, а при нажатии на my-job — все детали заданий.

![Детали задачи my-job](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijc4MWY3OTA4OWQzODMwN2ZhNTg4MjM0YTgzMDE4NWU0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=749aeb94743cca69e1fcf9fd2ccc71c933221d126bd3afd94d7b7729f8933fea)

Процесс состоит из трёх шагов: set up job, my-step и complete job. Первый и последний добавляются автоматически, а my-step определяется при создании воркфлоу.

На каждый шаг можно кликнуть и получить дополнительную информацию о нем:

![Информация о шагах](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjEzM2IwNmI1NmEzMmY4NjU4YWY4ZmFkMzY4ZDE4ZTg1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=085d58df7fce1432ee9a49c3420727f84d95e047d3bca3a5486ef1df0cf7290a)

На этом всё — вы только что создали и запустили первый воркфлоу в GitHub Actions.

Не стоит останавливаться на достигнутом: этот воркфлоу можно адаптировать для вашего сценария. Например, если вы делаете проект на Хекслете, то можете сделать запуск команд из _Makefile_ на каждый пуш в Github.

#### Заключение

В этом уроке мы познакомились с понятием непрерывной интеграции, основными концепциями и терминологией Gihub Actions, и научились настраивать простой воркфлоу.

Рассмотреть все возможности Github Actions в рамках урока не представляется возможным, поэтому продолжайте работать, опираясь на документацию.

### Домашнее задание

Загрузите домашнее задание с помощью команды:

```bash
hexlet program download frontend-testing-react ci
```

---

##### Дополнительные материалы

1. [Экстремальное программирование](https://ru.hexlet.io/blog/posts/xp)
2. [Среды разработки. Мужики, выкатывай!](https://ru.hexlet.io/blog/posts/environment)
3. [Курс по Github Actions](https://ru.hexlet.io/courses/github-actions)

## Самостоятельная работа

### Курс «[JS: Автоматическое тестирование](https://ru.hexlet.io/courses/js-testing)»

Урок «[Зачем и как писать тесты?](https://ru.hexlet.io/courses/js-testing/lessons/goal/theory_unit)»

1. Воспроизведите структуру получившуюся в конце урока
2. Запустите тесты, убедитесь что они работают. Попробуйте их сломать
3. Добавьте код на гитхаб

Урок «[Утверждения (Asserts)](https://ru.hexlet.io/courses/js-testing/lessons/asserts/theory_unit)»

1. Посмотрите в конце урока ссылки на документацию на библиотеки утверждений
2. Замените в вашем репозитории ручные утверждения на использование модуля _assert_
3. Запустите тесты, убедитесь что они работают. Попробуйте их сломать
4. Добавьте код на гитхаб

Урок «[Jest](https://ru.hexlet.io/courses/js-testing/lessons/jest/theory_unit)»

1. Выполните все шаги из этого урока
2. Залейте код на Гитхаб

Пример полностью настроенного пакета: https://github.com/hexlet-boilerplates/nodejs-package

Урок «[Покрытие кода тестами (Code Coverage)](https://ru.hexlet.io/courses/js-testing/lessons/code-coverage/theory_unit)»

1. клонируйте себе репозиторий [nodejs-package](https://github.com/hexlet-boilerplates/nodejs-package)
2. запустите тесты, посмотрите на их вывод
3. добавьте флаг `--coverage` при запуске тестов, посмотрите как изменился вывод

## Дополнительные материалы

### [JS: Автоматическое тестирование](https://ru.hexlet.io/courses/js-testing)

1. [Введение](https://ru.hexlet.io/courses/js-testing/lessons/intro/theory_unit)
   - [Как мы тестируем тесты. О проверке тестов в практических упражнениях этого курса.](https://help.hexlet.io/ru/articles/111145-kak-my-testiruem-testy-utilita-suppressor)
2. [Зачем и как писать тесты?](https://ru.hexlet.io/courses/js-testing/lessons/goal/theory_unit)
   - Без материалов
3. [Утверждения (Asserts)](https://ru.hexlet.io/courses/js-testing/lessons/asserts/theory_unit)
   - [Asserts](https://nodejs.org/api/assert.html)
   - [Chai](https://chaijs.github.io/)
4. [power-assert](https://ru.hexlet.io/courses/js-testing/lessons/power-assert/theory_unit)
   - Без материалов
5. [Jest](https://ru.hexlet.io/courses/js-testing/lessons/jest/theory_unit)
   - [Jest](https://jestjs.io/)
   - [Блоки тестов (Describe)](https://jestjs.io/docs/ru/api#describename-fn)
   - [Курс "JS: Настройка окружения"](https://ru.hexlet.io/courses/js-setup-environment)
6. [Матчеры (Expectations)](https://ru.hexlet.io/courses/js-testing/lessons/matchers/theory_unit)
   - [Матчеры Jest](https://jestjs.io/docs/ru/expect)
7. [Модульные тесты](https://ru.hexlet.io/courses/js-testing/lessons/unit-tests/theory_unit)
   - [Чек-лист хороших инженерных практик в компаниях](https://guides.hexlet.io/check-list-of-engineering-practices/)
8. [Подготовка данных](https://ru.hexlet.io/courses/js-testing/lessons/setup/theory_unit)
   - [Jest methods](https://jestjs.io/docs/en/api#methods)
9. [Плохие и хорошие практики тестирования](https://ru.hexlet.io/courses/js-testing/lessons/bad-practice/theory_unit)
   - [Начинаем писать тесты правильно](https://www.youtube.com/watch?v=zsz8kdi62mE)
10. [Покрытие кода тестами (Code Coverage)](https://ru.hexlet.io/courses/js-testing/lessons/code-coverage/theory_unit)
    - Без материалов
11. [Разработка через тестирование (TDD)](https://ru.hexlet.io/courses/js-testing/lessons/tdd/theory_unit)
    - [Начинаем писать тесты правильно](https://ru.hexlet.io/blog/posts/how-to-test-code)
    - [Начинаем писать тесты правильно (Видео)](https://www.youtube.com/watch?v=zsz8kdi62mE)
12. [Непрерывная интеграция (CI)](https://ru.hexlet.io/courses/js-testing/lessons/ci/theory_unit)
    - [Экстремальное программирование](https://ru.hexlet.io/blog/posts/xp)
    - [Среды разработки. Мужики, выкатывай!](https://ru.hexlet.io/blog/posts/environment)
    - [Курс по Github Actions](https://ru.hexlet.io/courses/github-actions)
