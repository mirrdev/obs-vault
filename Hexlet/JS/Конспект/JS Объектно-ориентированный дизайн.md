## О курсе—JS: Объектно-ориентированный дизайн

Если предыдущий курс был о том, как описывать абстракции с помощью классов, то в этом упор делается на использование объектов с примерами реальных библиотек. Построение цепочек вызовов, работа со структурами данных, оперирование датами и строками в объектно-ориентированном стиле — это неполный перечень того, с чем мы столкнёмся.

В этом курсе не изучается новый синтаксис, его и так было очень много. ООП — сложная тема, и вводить новые понятия нужно достаточно осторожно, набравшись немного опыта работы с основными концепциями. Отдельной темой, проходящей красной нитью сквозь все дальнейшее обучение являются шаблоны проектирования или паттерны — подходы для решения типовых задач.

- Текучий интерфейс (Fluent Interface).
- Передача сообщений.
- Прокси-объекты (Proxy).
- Структуры данных (ООП версии).
- Работа с датами.
- Классы конфигураторы.

## Шаблоны Проектирования—JS: Объектно-ориентированный дизайн

"Шаблоны проектирования" (или "паттерны") стали неотъемлемой частью современной разработки.

> Шаблон проектирования или паттерн (англ. design pattern) в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. (Wiki)

Простым языком, определение звучит так: типовое решение для типовой задачи. Термин пришёл в программирование из архитектуры. В 1970-е годы архитектор Кристофер Александр составил набор шаблонов проектирования, типовых решений для различных архитектурных задач. Спустя полтора десятка лет эта идея была заимствована и адаптирована применительно к разработке графических оболочек языка SmallTalk. Сейчас паттерны встречаются повсеместно, постоянно изобретаются и переизобретаются. Некоторые из них описывают задачи, связанные с небольшим участком кода, другие определяют, например, способы работы в распределённых системах. Причём последние отвязаны от языка программирования. Интересный факт: некоторые шаблоны в языках появились вследствие ограничений самих языков и пытаются обойти их.

Как минимум один паттерн проектирования мы уже знаем по уроку "статические свойства и методы". Его называют [Money](https://martinfowler.com/eaaCatalog/money.html) – объект-значение описывающий собой деньги.

```javascript
class Money {
  constructor(amount, currency = "usd") {
    this.amount = amount;
    this.currency = currency;
  }
}
```

Возможно, вы удивитесь, что для такой примитивной задачи придуман целый паттерн, и будете правы. Паттерн — не обязательно что-то сложное и доступное только избранным. Паттерном называют любую задачу, которая повторяется безотносительно оценки сложности решения. Поэтому, хотите вы того или нет, в вашем коде уже встречаются шаблоны проектирования, даже если вы об этом не знаете. Правда, до некоторых типовых решений самостоятельно дойти крайне сложно.

Насколько важно изучать шаблоны проектирования? Большинство описаний шаблонов в интернете завязано на [конкретную книгу](https://ru.wikipedia.org/wiki/Design_Patterns). Далеко не все паттерны, описанные в ней, полезны и встречаются в обычной жизни. Многие из них специфицированы под конкретные языки и не применимы в том же виде в других языках. Ещё больше паттернов (на порядки) в этой книге не описано.

Как только появились паттерны, то не могли не появиться и антипаттерны. Антипаттерн — такое же типовое решение (потому что им часто пользуются), но создающее больше проблем, чем приносящее пользы. Обычно такие решения возникают из-за непонимания причинно-следственных связей в коде.

С паттернами и антипаттернами мы будем знакомиться на протяжении всех дальнейших курсов.

---

##### Дополнительные материалы

1. [Паттерны без привязки к языку](https://github.com/Hexlet/patterns/tree/master/content)
2. [Антипаттерны](https://ru.wikipedia.org/wiki/Антипаттерн)

## Конфигурация—JS: Объектно-ориентированный дизайн

Markdown — упрощённый язык разметки, который удобен при работе с текстом (в отличие от HTML). Браузеры не умеют отображать Markdown напрямую, поэтому он транслируется в HTML и уже затем показывается. Трансляция Markdown в HTML описывается чистой функцией. Она не зависит от внешнего окружения, детерминирована и не порождает побочных эффектов.

```javascript
html = markdownToHtml(markdown);
```

На входе текст (в формате Markdown), на выходе — тоже текст (в формате HTML). Если нужно изменить поведение трансляции, то достаточно передать вторым параметром массив опций.

```javascript
const html = markdownToHtml(markdown, { sanitize: false });
```

Теперь давайте вообразим объектно-ориентированную версию этого кода. Перед тем, как двигаться дальше, попробуйте отвлечься от чтения и подумайте над следующими вопросами:

- Что мы вообще хотим получить такого от ООП, чего не даёт нам чистая функция?
- Как будет выглядеть получившийся интерфейс?

Как вы помните, классы позволяют реализовать абстракцию. Можно ли сказать, что в процессе преобразования Markdown в HTML есть абстракция? Нет. Абстракция подразумевает наличие некоторого понятия (типа), значения которого обладают _временем жизни_. Это значит, что она создается и затем многократно и по-разному используется. Например, невозможно представить работу с пользователем в виде одной функции. Если говорить о Markdown, то конкретный текст этого формата не интересует нас сам по себе, мы не определяем над ним некоторый набор операций и не собираемся им активно пользоваться. Все, что мы хотим, прямо здесь и сейчас (в том коде) - получить HTML и забыть про Markdown.

Если бы мы хотели построить вокруг текста абстракцию, то код выглядел бы так:

```javascript
// Объект md описывает собой переданный текст markdown и позволяет им манипулировать
const md = new Markdown(markdown);
const html = md.render();
```

В примере выше тип Markdown представляет собой абстракцию над текстом в формате Markdown. Смысла в таком коде мало, а вот проблем он доставит. Эти две строчки начнут неразрывно встречаться в каждом месте, в котором требуется получить HTML. Объект `md` становится сразу не нужен, как только получен HTML, у него нет времени жизни. Такой антипаттерн особенно часто встречается у новичков. Загвоздка здесь именно в том, чтобы разобраться, где у нас абстракция данных, а где нет.

```javascript
// Типичный избыточный код в том месте, где абстракцию сделали, но она не нужна
const md1 = new Markdown(markdown1);
const html1 = md1.render();

// Еще раз для закрепления
const md2 = new Markdown(markdown2);
const html2 = md2.render();
```

Существует формальное правило, позволяющее это определить. Если создание объекта и вызов метода можно заменить на обычную функцию, то ни о какой абстракции речи не идёт, и правильный подход, в данной ситуации, сводится к переносу данных из конструктора в сам метод.

```javascript
const md = new Markdown();
// очень важно, чтобы render оставался чистой функцией и не сохранял markdown внутри объекта
const html1 = md.render(markdown1);
const html2 = md.render(markdown2);
```

В этом коде класс Markdown — тип, относящийся к транслятору, а не к тексту. У такого объекта жизненный цикл шире, чем ожидание однократного вызова функции `render()` (как в предыдущем случае). Он может (и должен) переиспользоваться столько раз, сколько потребуется. Для этого важно оставить функцию `render()` чистой и не менять состояние объекта между вызовами.

Тогда становится непонятно, зачем здесь вообще объект. И на это есть 2 причины.

1. Полиморфизм подтипов. Разберём в последующих курсах.
2. Вторая и главная причина (для данного случая) — Конфигурация.

Разберём последний пункт подробнее. Представьте что Markdown на проекте используется повсеместно (на Хекслете очень часто) и код генерации HTML выглядит так:

```javascript
// В одном месте
const html1 = markdownToHtml(markdown1, { sanitize: true });

// Где-то в другом месте
const html2 = markdownToHtml(markdown2, { sanitize: true });
```

Чем больше возникает таких мест, тем больше дублируется передача опций. Изменение поведения потребует переписывания всех мест вызова этой функции. Логичным шагом было бы задать опции в одном месте и затем их переиспользовать.

```javascript
// В одном месте
const html1 = markdownToHtml(markdown1, options);

// Где-то в другом месте
const html2 = markdownToHtml(markdown2, options);
```

Использование объекта позволяет убрать явную передачу (про которую легко забыть). Суть этого паттерна заключается в конфигурировании. То есть объект в данном случае выступает в роли контейнера, содержащего опции для Markdown, которые применяются при рендеринге, что позволяет их не передавать каждый раз.

```javascript
const md = new Markdown({ sanitize: true });
const html1 = md.render(markdown1);
const html2 = md.render(markdown2);
```

Под конфигурированием всегда понимается передача опций (различных настроек, необходимых данной библиотеке) в конструктор во время создания объекта. Особенно полезной такая конфигурация становится тогда, когда объект создаётся в одном месте программы (на этапе инициализации приложения), а используется в других местах. Возможность конфигурации не навязывает саму конфигурацию. Как правило, подобные объекты можно создавать и без указания чего-либо, тогда поведение остаётся "дефолтным", но смысл от этого не меняется.

```javascript
const md = new Markdown();
const html = md.render(markdown);
```

Популярная библиотека для HTTP-запросов axios построена по такому же принципу. Она позволяет создать объект, который сохранит базовую конфигурацию.

_Попробуйте проверить себя. Выполнение HTTP-запроса это абстракция данных или нет?_

```javascript
import axios from "axios";

const client = new axios.Axios({ timeout: 1000 });
const response = await client.get("https://ru.hexlet.io/lessons.rss");
console.log(response.status);
```

_Данный приём не является прерогативой классов и объектов. В функциональных языках (и в JS) он крайне просто реализуется через замыкание_

---

##### Дополнительные материалы

1. [Библиотека MarkdownIt](https://github.com/markdown-it/markdown-it)

## Изменяемая конфигурация—JS: Объектно-ориентированный дизайн

Многие объекты в ООП не являются абстракцией данных, а используются как способ сохранить конфигурацию для выполнения повторяющихся действий, таких как генерация HTML из Markdown или определение города по IP. Конфигурация осуществляется через передачу опций в конструктор объекта, а сами опции хранятся внутри и используются для всех последующих вызовов.

```javascript
// timeout устанавливает ограничение в одну секунду на длительность запроса
const ipgeo = new IpGeo({ timeout: 1000 });
ipgeo.resolve("123.4.3.2");
```

Но что если для конкретного запроса, нужно временно установить опции, отличные от тех что были переданы в конструктор? Для выхода из этой ситуации есть три возможных решения.

### Создание нового объекта

Самое простое решение сводится к созданию нового объекта в том месте, где нам нужно. Это решение хоть и простое, но обладает рядом недостатков. Главный недостаток связан с невозможностью подмены реализации (тот самый полиморфизм, о котором мы будем говорить в будущем), так как объект создаётся не на этапе конфигурирования системы, а в том месте, где происходит вызов. Это, в свою очередь, ведёт к тому, что придётся дублировать общие опции, а тестирование станет затруднительным (если не невозможным).

```javascript
const ipgeo = new IpGeo({ timeout: 10 });
ipgeo.resolve("123.4.3.2");
```

### Сеттеры

Самый страшный вариант связан с использованием сеттеров.

```javascript
const ipgeo = new IpGeo({ timeout: 1000 });

// В одной части программы
ipgeo.resolve("123.4.3.2");

// В другой части программы
ipgeo.setOption("timeout", 10);
ipgeo.resolve("123.4.3.2");
```

Изменяемое состояние, самое сложное что есть в программировании. Его наличие приводит практически ко всем проблемам, с которыми мы встречаемся, и создаёт трудноотловимые и опасные баги. Догадайтесь, что пойдёт не так после выполнения последних двух строк? Наш объект `ipgeo` используется совместно всеми частями системы, из этого следует, что его изменение в одном месте, повлияет на все последующие вызовы. В случае работы с Markdown всё может быть ещё опаснее, так как неправильный вывод порождает дыры в безопасности, а конкретно возможность провести [XSS](https://ru.wikipedia.org/wiki/Межсайтовый_скриптинг):

```javascript
const md = new Markdown({ sanitize: true });

// В одной части программы
md.render(markdown);

// В другой части программы отключаем санитайз
md.setOption("sanitize", false);
md.render(markdown2);
```

`sanitize` — флаг, отвечающий за включение безопасного рендеринга. Если его выключить, то теги `<script>` вставленные в Markdown отобразятся как есть. Такое иногда нужно и допустимо для своего собственного текста (например на Хекслете это уроки), но недопустимо для текста который вводят пользователи. Изменение объекта `md` создаёт дыру в безопасности. Избежать её можно не забыв вернуть опцию обратно:

```javascript
const md = new Markdown({ sanitize: true });

// В одной части программы
md.render(markdown);

// В другой части программы отключаем санитайз
md.setOption("sanitize", false);
md.render(markdown2);
md.setOption("sanitize", true);
```

В силу человеческого фактора, программист обязательно забудет это сделать. Такой код, в котором сначала что-то меняется в одну сторону, а потом восстанавливается обратно, почти всегда говорит о проблемах архитектуры и его можно переписать на безопасный вариант.

### Новые опции на время запроса

Правильный способ решает все проблемы указанные выше. Его использование основано на передаче дополнительного параметра в метод. Этот параметр содержит временные опции, которые применяются только для данного запроса.

```javascript
const md = new Markdown({ sanitize: true });

// В одной части программы
md.render(markdown);

// В другой части программы отключаем санитайз на время выполнения запроса
md.render(markdown2, { sanitize: false });
md.render(markdown3); // sanitize по прежнему равен true
```

Теперь все в порядке. Sanitize включён глобально, но в конкретном запросе он был переопределён `md.render(markdown, { sanitize: false })` и это никак не отражается на последующих вызовах метода `render()`.

## Объекты-Сущности, Объекты-Значения и внедренные объекты—JS: Объектно-ориентированный дизайн

### Объекты-Сущности (entities objects)

Чаще всего когда говорят про ООП, то рассуждают про сущности предметной области, например пользователи, заказы, товары и тому подобное. У такого использования объектов есть определенные условия, которые должны соблюдаться для обеспечения нормального функционирования.

_Стоит сказать, что подобное использование ООП, хоть и описывается во всех учебниках как пример нужности ООП, имеет слабое отношение к реальному коду. На практике, большинство существующих классов и объектов в коде приложений, библиотек и фреймворков не имеют никакой связи с предметной областью. Их появление и использование крутится вокруг такой темы как полиморфизм, которая изучается в соответствующем [курсе](https://ru.hexlet.io/courses/js-polymorphism)._

**Время жизни**. Подобные объекты создаются не ради одноразового использования, а живут какое-то время во время запуска программы или, что чаще, между запусками в каком-то хранилище. Например пользователи на Хекслете представлены объектами класса User. Они создаются во время регистрации и потом существуют в системе бесконечное время. Изредка они удаляются по инициативе самих пользователей.

**Идентификация**. Каким образом один пользователь отличается от другого? На первый взгляд, кажется, что можно использовать имя и фамилию. Но если разобраться, то никакой набор параметров не даст 100% надежности с одной стороны, а с другой они все могут измениться и точно изменятся со временем. Поэтому при работе с сущностями вводят искусственные идентификаторы, которые, как правило, формирует база данных. Затем сравнение происходит именно по ним.

```javascript
class User {
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }

  equals(user) {
    return this.id === user.id;
  }
}

// С точки зрения нашей системы это один и тот же пользователь
// С точки зрения js – разные объекты
const user1 = new User(3, "mike");
const user2 = new User(3, "mike");

const user3 = new User(1, "mike");

// Подобная схема проверки существует во всех ORM
user1.equals(user2); // true
user1.equals(user3); // false
```

_Это очень напоминает механизм сравнения объектов в JavaScript. Они сравниваются не по совпадению данных, а по ссылке, которая внутри представлена каким-то числовым значением. Поэтому разные объекты хранящие одинаковые данные это всегда разные объекты, что логично._

Объекты имеющие свою идентификацию и время жизни называют объектами-сущностями (entities), но кроме них существует и другая разновидность объектов, тоже, как правило, связанная с предметной областью – это объекты-значения. Что это?

### Объекты-Значения (value objects)

Когда у нас в кошельке лежит 10$, то нам не важно какая конкретно это купюра. Мы легко можем взять эту купюру, поменять ее на другую эквивалентную по номиналу. Для нас в этот момент ничего не меняется. Десять долларов остались десятью долларами. То же самое можно сказать и про многое другое, например: адреса доставки, страна проживания, путь до файла, адрес страницы сайта, точки на плоскости. Во всех этих ситуациях нас волнует само значение, сам факт его существования.

Представьте себе систему в которой идет работа с деньгами. Причем в разных валютах. В такой ситуации удобно представить деньги в виде объекта, который помимо номинала хранит информацию о валюте. Как в таком случае должно работать сравнение?

```javascript
const m1 = new Money(150, "usd");
const m2 = new Money(130, "eur");

// Предположим что 150 долларов по текущему курсу равны 130 евро
// Функция конвертирует деньги для сравнения
m1.equals(m2); // true
```

Данный код выражает озвученную ранее идею. Нам не важны объекты, нам важны значения. Объект здесь служит лишь способом организации кода, но он никак не идентифицирует хранящиеся внутри него данные. Такие объекты называют [объектами-значениями](https://martinfowler.com/bliki/ValueObject.html).

_Если говорить откровенно, то реальность чуть сложнее. Одни и те же вещи могут быть как объектами-значениями так и объектами-сущностями. Всё зависит от конкретной предметной области. Для большинства компаний деньги - это действительно просто значения, но не для тех кто их печатает. Им очень важно различать купюры между собой и поэтому на каждой из них есть уникальный номер, который и позволяет проводить идентификацию._

Объекты-значения – искусственная штука. Часто они не нужны и достаточно пользоваться простым значением, особенно если оно примитивное. С другой стороны, когда значение составное, такое как точка на плоскости, адрес или адрес страницы сайта (она состоит из многих частей), подобные объекты помогают упростить код за счет удобной абстракции. В JavaScript встроен класс URL, который как раз и служит для представления адреса в сети в виде объекта со множеством удобных методов:

```javascript
import { URL } from "url";

const url = new URL("/courses?page=2", "https://ru.hexlet.io");
url.host; // 'ru.hexlet.io'
url.pathname; // '/courses'
url.searchParams.get("page"); // '2'
```

По идее два адреса равны если это один и тот же адрес. К сожалению, JavaScript не представляет простого способа проверить равенство, поэтому в сети есть немало статей, в которых авторы пытаются решить эту проблему самостоятельно. Скорее такую ситуацию можно отнести к ошибке (недоработке) в дизайне стандартной библиотеки, так как URL — это типичный пример объекта-значения.

### Встраиваемые объекты (embedded objects)

Как правило, данные, с которыми работают веб-приложения, хранятся в реляционных базах данных. В них каждая сущность представляется строкой в таблице, где каждое поле соответствует свойству объекта. При такой организации хранения иногда возникают ситуации, когда несколько свойств сущности описывают что-то одно. Распространенный пример – почтовый адрес:

```javascript
// Поиск из базы по идентификатору
// Гипотетический код
const user = User.find(5);

user.street; // 'lenina'
user.zipcode; // 432111
user.house; // 10
```

Существует два подхода для работы с такими данными. Согласно первому, любая логика по работе с этими данными описывается внутри самой сущности. Например вывод адреса в виде текста:

```javascript
class User {
  // Где-то здесь конструктор и другие методы

  getFullAddress() {
    return `${this.street}, ${this.house}, ${this.zipcode}`;
  }
}

user.getFullAddress();
```

Главная проблема здесь ⎯ возможное дублирование если адрес встречается где-то еще кроме пользователя. Тогда придется реализовывать методы по работе с этими данными везде, где они встречаются.

Второй подход – создать отдельный класс и **внедрить** объект этого класса в основной объект. Звучит страшно, но на практике очень просто:

```javascript
class Address {
  constructor(street, house, zipcode) {
    this.street = street;
    this.house = house;
    this.zipcode = zipcode;
  }

  toString() {
    return `${this.street}, ${this.house}, ${this.zipcode}`;
  }
}

class User {
  // Где-то здесь конструктор и другие методы

  getAddress() {
    // Так как у нас объект-значение,
    // то можно не боясь создавать его любое количество раз,
    // но в случае необходимости можно этот процесс оптимизировать
    return new Address(this.street, this.house, this.zipcode);
  }
}

user.getAddress().toString();
```

## Fluent Interface—JS: Объектно-ориентированный дизайн

Domain Specific Language (Предметно-ориентированный язык) — язык, специализированный под конкретную область применения. Структура такого языка отражает специфику решаемых с его помощью задач. Яркий пример подобного языка — библиотека [jQuery](https://jquery.com/), с которой знакомо большинство программистов (или хотя бы слышали о ней). С ее помощью управляют отображением и поведением веб-страниц:

```javascript
// Вызов методов через точку в одной строчке
// Элементу с классом box выставляется цвет текста и высота
".box".css("color", "#333").height(200);
```

Здесь DSL создан с помощью [Текучего интерфейса (Fluent Interface)](https://ru.wikipedia.org/wiki/Fluent_interface). При таком способе организации кода, обработка выглядит как цепочка подряд идущих методов. На техническом уровне есть ровно два способа создать такой интерфейс.

### This

Первый способ основан на возврате `this` из методов, которые участвуют в построении цепочек. `this` — ссылка на тот объект, в контексте которого вызывается метод, а, следовательно, его можно возвращать как обычное значение.

```javascript
class Collection {
  constructor(coll) {
    this.coll = coll;
  }

  map(fn) {
    this.coll = this.coll.map((element) => fn(element));

    return this;
  }

  filter(fn) {
    this.coll = this.coll.filter((element) => fn(element));

    return this;
  }

  // Возвращает саму коллекцию, а не this.
  // Этот метод всегда последний в цепочке вызовов Collection.
  all() {
    return this.coll;
  }
}

const cars = new Collection([
  { model: "rapid", year: 2016 },
  { model: "rio", year: 2013 },
  { model: "mondeo", year: 2011 },
  { model: "octavia", year: 2014 },
]);

cars.filter((car) => car.year > 2013).map((car) => car.model);
cars.all(); // [rapid, octavia]
```

У этого способа есть один серьёзный недостаток — объект изменяется. Это значит, что нельзя взять и просто так переиспользовать объект-коллекцию для разных выборок, потому что они начнут накладываться друг на друга.

На практике часто используется другой подход, с которым мы уже познакомились в прошлом курсе. Все, что нужно сделать — добавить немного функциональности в ооп, то есть возвращать не `this`, а создавать новый объект того же типа с обновлённой коллекцией.

```javascript
class Collection {
  constructor(coll) {
    this.coll = coll;
  }

  map(fn) {
    const newColl = this.coll.map((element) => fn(element));

    return new Collection(newColl);
  }

  filter(fn) {
    const newColl = this.coll.filter((element) => fn(element));

    return new Collection(newColl);
  }

  // Возвращает саму коллекцию, а не this.
  // Этот метод всегда последний в цепочке вызовов Collection.
  all() {
    return this.coll;
  }
}

const cars = new Collection([
  { model: "rapid", year: 2016 },
  { model: "rio", year: 2013 },
  { model: "mondeo", year: 2011 },
  { model: "octavia", year: 2014 },
]);

const filteredCars = cars.filter((car) => car.year > 2013);
const mappedCars = filteredCars.map((car) => car.model);
mappedCars.all(); // [rapid, octavia]
cars.all();
// [
//   { model: 'rapid', year: 2016 },
//   { model: 'rio', year: 2013 },
//   { model: 'mondeo', year: 2011 },
//   { model: 'octavia', year: 2014 },
// ]
```

Теперь каждый вызов возвращает новый объект. Такой код значительно безопаснее в использовании и позволяет без проблем переиспользовать новые коллекции. Изменение одной не приведёт к автоматическому изменению всех остальных.

---

##### Дополнительные материалы

1. [Текучий интерфейс](https://ru.wikipedia.org/wiki/Fluent_interface)

## Сборщики (Builders)—JS: Объектно-ориентированный дизайн

Иногда создание объекта это сложный и даже многоэтапный процесс с дополнительными условиями. К таким объектам относятся валидаторы, реализованные в объектном стиле.

_Валидация — это процесс проверки данных на корректность по заданным условиям. А валидатор — это что-то, выполняющее данную проверку._

В программировании валидация встречается на каждом шагу. Мы так или иначе работаем с формами или данными, отправляемыми по API. Все эти данные присылаются пользователями или внешними системами и автоматически считаются недоверенными. Перед тем как работать с ними, сначала нужно убедиться что они "валидные", то есть соответствуют нашим требованиям. Например, если мы говорим про емейл пользователя, то для большинства форм регистрации он должен быть не пустой и должен соответствовать формату емейлов.

Самый простой способ сделать валидацию, это выполнить ручную проверку:

```javascript
if (data.email === "") {
  errors.push("емейл пустой");
}

// гипотетическая функция проверки формата
if (!hasEmailFormat(data.email)) {
  errors.push("емейл имеет неверный формат");
}
```

Нетрудно представить, как разрастется этот код для большой формы со множеством правил. У такого способа есть и другие проблемы. Он не позволяет легко переиспользовать правила для разных форм и проектов. Кроме того, многие проверки придется либо реализовывать самостоятельно, либо искать готовые библиотеки для них. Например, для проверки корректности ссылок, адресов и других вещей.

### Yup

В JavaScript для выполнения валидации очень популярна библиотека yup. Посмотрите на пример, эквивалентный проверкам выше:

```javascript
import * as yup from "yup";

const schema = yup.string().required().email();

schema.validateSync(""); // ValidationError: this is a required field
schema.validateSync("wrongemail"); // ValidationError: this must be a valid email
schema.validateSync("support@hexlet.io"); // возвращает само значение
```

Принцип работы этой библиотеки следующий. С помощью цепочки методов формируется схема валидации. В эту цепочку входят различные условия, которые должны выполняться по принципу объединения. То есть для успешной валидации должны выполниться все условия. Сами условия зависят от того, какого типа проверяемые данные, поэтому в начале вызывается метод, задающий тип, и затем вызываются методы, которые относятся к данному типу данных:

```javascript
// методы positive() и integer() есть только у number
const schema1 = yup.number().required().positive().integer();

// массив должен содержать от 5 до 10 элементов
const schema2 = yup.array().min(5).max(10);
```

Во всех этих ситуациях наша задача – сформировать правильную схему под конкретную задачу. Затем эту схему можно использовать множество раз на разных данных. Подобный способ формирования объекта-схемы называется сборкой, а сам объект – сборщиком. По большому счету это небольшая разновидность использования текучего интерфейса. Чем он удобен? С его помощью просто собирать даже сложные проверки, используя очень понятную механику объединения вызовов. Код при этом получается простым и понятным.

Из дополнительных плюсов – наличие готовых сообщений об ошибках для всех встроенных проверок. При необходимости их можно поменять для конкретной схемы, просто передав текст в методы проверок:

```javascript
// Замена идет только для данной схемы
const schema1 = yup.string().required("Пусто!");

const schema2 = yup.string().required(); // здесь будет значение по умолчанию
```

Yup поддерживает не только разные тексты, но и [разные локали](https://github.com/jquense/yup#using-a-custom-locale-dictionary), что актуально для многоязычных сайтов.

А что делать в ситуации, когда мы работаем с объектом, у которого каждое свойство имеет свои собственные проверки? Yup решает эту задачу очень элегантно, через рекурсивное определение:

```javascript
// object().shape() позволяет задать структуру объекта
const schema = yup.object().shape({
  name: yup.string().required(),
  age: yup.number().required().positive().integer(),
  email: yup.string().email(),
  website: yup.string().url(),
  createdOn: yup.date().default(() => new Date()), // значение по умолчанию
});

const data = {
  name: "jimmy",
  age: 24,
};
schema.validateSync(data);
```

https://repl.it/@hexlet/js-object-oriented-design-buider-yup-object#index.js

Но и это еще не все, yup позволяет добавлять дополнительные проверки, которые изначально в него не включены. Подробнее про эту возможность можно прочитать в документации.

---

##### Дополнительные материалы

1. [JSON schema](https://restfulapi.net/json-schema/)

## Прокси (Proxy)—JS: Объектно-ориентированный дизайн

В JavaScript встроен особый объект Proxy, с помощью которого можно управлять доступом к свойствам практически любых объектов. И хотя в прикладном коде такая задача встречается не часто, в библиотеках и фреймворках Proxy используется регулярно. Вот лишь некоторые примеры его использования: перегрузка некоторых операторов, мокинг объектов, передача сообщений, отслеживание изменений (обычно при управлении состоянием приложения), валидация, логгирование, кеширование и многое другое.

Посмотрим на простой пример, в котором Proxy возвращает значение по умолчанию, если свойства не существует:

```javascript
// Количество пользователей в разных странах
const usersCountByCountry = {};

const handlers = {
  get: (target, prop) => {
    // in проверяет наличие свойства по всей цепочке прототипов
    // В случае Proxy это правильнее чем _.has
    if (prop in target) {
      return target[prop];
    }

    return 0;
  },
};

// obj – обернул исходный объект
const obj = new Proxy(usersCountByCountry, handlers);

obj.russia; // 0
obj.russia += 1; // 1
obj.usa; // 0
```

Proxy оборачивает исходный объект и перехватывает запросы к нему. Делается это с помощью обработчиков, называемых ловушками (trap). Ловушки описываются как методы объекта, который передается вторым параметром в конструктор Proxy.

Всего в Proxy 13 ловушек, среди которых самые часто используемые это "get" и "set". С помощью них перехватываются все операции чтения (get) и записи (set).

Ловушка **get** вызывается при каждом обращении к любому свойству объекта. На вход ей передается исходный объект и имя свойства к которому идёт обращение. Внутри же, можно строить любую логику. В нашем примере мы возвращаем значение свойства из `target`, если оно существует, и `0` в случае его отсутствия.

```javascript
get: (target, prop) => {
  if (prop in target) {
    return target[prop];
  }

  return 0;
},
```

Концептуально, Proxy это такая штука, которая "не отсвечивает". Прикладной код не должен знать, что он работает не с исходным объектом, а с Proxy. Только в этом случае будет обеспечиваться прозрачная работа с Proxy, то есть не придется затачивать код под него. Частично ответственность за это лежит на программисте, а частично на Proxy. Поэтому:

- У Proxy нет своих свойств, он всегда **проксирует** вызовы
- Из Proxy невозможно извлечь исходный объект и каким-то образом поменять его в обход ловушек
- В соответствии со спецификацией, не существует способа определить, что объект это прокси (технически такая [возможность есть](https://nodejs.org/api/util.html#util_util_types_isproxy_value), но в нормальной ситуации она не должна использоваться)

---

##### Дополнительные материалы

1. [Документация Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
2. [on-change](https://github.com/sindresorhus/on-change)

## Пишем код правильно—JS: Объектно-ориентированный дизайн

Вооружившись знаниями, которые мы уже получили по ООП, давайте попробуем ответить на вопрос, как все же правильно писать и структурировать код в классовых языках.

В ООП считается, что набор принципов SOLID — это ответ на вопрос о том, как правильно писать код. Но жизнь показывает, что знание этих принципов слабо помогает хорошей организации кода.

Возьмем принцип SRP (принцип единственной ответственности, S из SOLID). Он говорит следующее:

> Должна быть ровно одна причина для изменения класса. Роберт Мартин.

Есть и другие формулировки, но это самая лаконичная. Что не так с этим принципом? Он очень общий. Звучит примерно как: нормально делай – нормально будет. Он не дает никаких формальных критериев, по которым можно понять, что в классе есть проблема. В статьях, посвященных этому принципу, всегда всё кажется логичным. Но только потому, что автор уже предложил разделение ответственностей. В реальной жизни всё было бы по-другому. Когда разных людей спрашиваешь об одних и тех же ситуациях, они дают совершенно разные, иногда противоположные ответы. По факту, всё сводится к некоторому внутреннему чутью конкретного программиста.

Возьмем для примера библиотеку выполнения HTTP запросов. С чего нужно начать ее проектирование?

Правильно начинать с вариантов использования. Представить себе как будто библиотека уже написана и мы пробуем ей воспользоваться (TDD толкает именно к этому, поэтому оно так мощно работает). Перед тем, как я покажу код, попробуйте ответить на вопрос, так ли нужны классы и ООП для реализации этой библиотеки?

HTTP-сессия — это операция, у которой есть конец и начало. Нужны ли объекты для ее выражения? Нет, конечно. Для операций достаточно функций. Поэтому наша библиотека в самом простом случае может выглядеть так:

```javascript
import { get, post } from "http-client";

let response = get("https://ru.hexlet.io/blog");
console.log(response.body);

response = post("https://ru.hexlet.io/users", {
  name: "mira",
  email: "mira@example.com",
});
console.log(response.statusCode);
```

Теперь, когда готов интерфейс библиотеки, можно приступать к её реализации. Насколько важно, как она выполнена внутри? Откровенно говоря, не важно. Внутренности останутся внутренностями, и никто про них не узнает, а их размер никогда не станет слишком большим (это всего лишь http библиотека). Это значит, что мы в любой момент можем их переписать. И делать это лучше не до, а после, когда накопится опыт поддержки и опыт использования. Только в этом случае появится настоящее понимание того, как лучше структурировать библиотеку внутри.

Генеральная идея звучит так: грамотная абстракция – ключ к успеху. Обозначьте границы, рассмотрите варианты использования и реализуйте как-нибудь.

Пример выше не взят с потолка, вы можете убедиться сами, что самая популярная http-библиотека [axios](https://github.com/axios/axios) в JavaScript — это действительно набор функций:

```javascript
import axios from "axios";

await axios.get("https://ru.hexlet.io/users");

await axios.post("https://ru.hexlet.io/users", {
  firstName: "Fred",
  lastName: "Flintstone",
});
```

Но если нужно, она позволяет создать объект, но только лишь с той целью, чтобы мы могли запомнить конфигурацию внутри для избежания дублирования:

```javascript
import axios from "axios";

const client = new axios.Axios({ timeout: 1000 });
const response = await client.get("https://ru.hexlet.io/lessons.rss");
console.log(response.statusCode);
```

Какими принципами нужно руководствоваться, чтобы понять внутреннюю архитектуру и количество классов? Для старта достаточно здравого смысла. У нас есть сам клиент, который представлен объектом (но его состояние – это конфигурация, а не запросы и ответы), и есть результат http-запроса. Результат представлен объектом, который возвращается после выполнения запроса. Внутри него хранится вся информация по взаимодействию с сервером, например, отправленные и принятые заголовки, код и тело ответа.

Дальнейшее разбиение не нужно. Возможно, это не понадобится никогда. А если и понадобится, то сначала нужно почувствовать такую необходимость, а затем уже реализовывать ее, когда появится боль. Причём главное основание для такого разделения – это не абстрактная единственная ответственность, а выделение чистого кода, который не связан с побочными эффектами.

Внутри нашей библиотеки есть код, который выполняет сетевые запросы, а есть код, который работает с данными, приводит их в нормальный вид, чистит и как-то структурирует. В первую очередь, нужно отслеживать такой код и отделять его на уровне функций или методов. Любая операция, которая может быть чисто вычислительной, потенциальный кандидат на вынесение.

Ещё один пример, где анализ побочных эффектов позволяет понять, как поступить правильно. В материалах по ООП часто говорят про класс, который отвечает за генерацию отчёта. Предположим, что он работает так:

```javascript
import Reporter from "./Reporter.js";

// Делать ли Reporter абстракцией данных (то есть объектом, описывающим конкретный отчет)
// или нет, это большой вопрос.
// По умолчанию так делать не стоит, иначе весь код превратится
// в бесполезное (new Reporter('path/to/file'))->generate()
const reporter = new Reporter();
const report = reporter.generate("/path/to/report");
```

На что стоит обратить внимание в первую очередь? На то, что этот класс одновременно выполняет грязную работу (с побочными эффектами): читает файл с диска, так и чистую: обрабатывает данные для формирования отчёта. Это не значит, что надо кидаться переписывать код, но это то, на что надо обращать внимание в первую очередь. Код выше сложнее в тестировании и отладке, чем код с разделенными операциями по побочным эффектам. Кроме того, если вынести чтение файла наружу, то репортер станет значительно более универсальным. Он сможет работать с данными, которые лежат не только на диске, но и были загружены каким-то другим способом, например, по http через форму. После несложных манипуляций получаем такой код:

```
import fs from 'fs';
import Reporter from './Reporter.js';

const reporter = new Reporter();
const data = fs.readFileSync('/path/to/report');
const report = reporter.generate(data);
```

Остальные принципы требуют знаний, которые приобретаются в следующем курсе: полиморфизм в js. Там они и рассматриваются.

---

##### Дополнительные материалы

1. [Снесите это немедленно (Андрей Аксенов). Доклад с конференции HighLoad.](https://www.youtube.com/watch?v=R-FfI4i0-uY)
2. [Архитектура и ООП](https://ru.hexlet.io/blog/posts/arhitektura-i-oop)

## Дополнительные материалы

### [JS: Объектно-ориентированный дизайн](https://ru.hexlet.io/courses/js-object-oriented-design)

1. [О курсе](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/about/theory_unit)
   - Без материалов
2. [Шаблоны Проектирования](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/patterns/theory_unit)
   - [Паттерны без привязки к языку](https://github.com/Hexlet/patterns/tree/master/content)
   - [Антипаттерны](https://ru.wikipedia.org/wiki/Антипаттерн)
3. [Конфигурация](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/configuration/theory_unit)
   - [Библиотека MarkdownIt](https://github.com/markdown-it/markdown-it)
4. [Изменяемая конфигурация](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/configuration-setters/theory_unit)
   - Без материалов
5. [Объекты-Сущности, Объекты-Значения и внедренные объекты](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/modeling/theory_unit)
   - Без материалов
6. [Fluent Interface](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/fluent-interface/theory_unit)
   - [Текучий интерфейс](https://ru.wikipedia.org/wiki/Fluent_interface)
7. [Сборщики (Builders)](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/builder/theory_unit)
   - [JSON schema](https://restfulapi.net/json-schema/)
8. [Прокси (Proxy)](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/proxy/theory_unit)
   - [Документация Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
   - [on-change](https://github.com/sindresorhus/on-change)
9. [Пишем код правильно](https://ru.hexlet.io/courses/js-object-oriented-design/lessons/right-way-to-write-code/theory_unit)
   - [Снесите это немедленно (Андрей Аксенов). Доклад с конференции HighLoad.](https://www.youtube.com/watch?v=R-FfI4i0-uY)
   - [Архитектура и ООП](https://ru.hexlet.io/blog/posts/arhitektura-i-oop)
