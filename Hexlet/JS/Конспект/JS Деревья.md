## Введение—JS: Деревья

Дерево — одна из самых распространённых структур данных в информатике и естественный способ моделирования некоторых предметных областей. С деревьями (как структурой данных) встречаются так или иначе все люди, даже те, кто далёк не только от программирования, но и от компьютеров в целом. Самым очевидным примером служит генеалогическое древо, а из более специализированного — файловое дерево. HTML (как и JSON, XML и многие другие) также имеет древовидную структуру. Комментарии и каталоги продуктов на сайтах тоже бывают древовидными. Любая иерархия является деревом по определению.

![Пример генеалогического древа](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQyNTAwYWY5Y2IyMTgxZjBkYTVjYTNhMjc3MGUyOGNhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=1f22b5c2b2eed9ab4c26d2358b004c695aa8a3add66dfd1d8aab8026e3c799a4)

С деревьями связан один очень интересный аспект. Уровень понимания темы деревьев и способность с ними работать невероятно сильно коррелирует с уровнем разработчика. Если разработчику легко работать с деревьями, то, как правило, он довольно хорошо разбирается в коде, в том числе чужом, если нет, то и, в целом, у него больше сложностей с написанием и анализом кода.

В этом курсе нет нового синтаксиса и каких-то элементов программирования, которые не изучались на Хекслете до этого курса. Однако тема деревьев сложнее остальных тем из-за рекурсивной природы самих деревьев. Нужно "повернуть" мозги в правильную сторону и это, пожалуй, самая тяжёлая часть, которую невозможно "прокачать", читая теорию. В этом поможет только практика и эксперименты.

Для упрощения процесса понимания и запоминания рекомендации такие же как и раньше:

1. Обязательно повторяйте весь код, который даётся в теории, локально на своём компьютере.
2. Используйте отладочную печать настолько, насколько можно. Выводите на экран все изменения данных во время работы кода.
3. Повторите уроки из введения в программирование про рекурсию.

В этом небольшом курсе мы слегка погрузимся в тему деревьев и научимся с ними работать. Чего не будет в этом курсе, так это алгоритмов в том виде, в котором эта тема подаётся в университете. У данного курса совсем другие цели. Он учит работать с рекурсивными структурами данных через древовидную рекурсию.

---

##### Дополнительные материалы

1. [Рекурсия, рекурсивный процесс и итеративный процесс](https://ru.hexlet.io/blog/posts/recursive)

## Определения—JS: Деревья

Файловая структура – пример дерева, с которым знакомы все, кто пользуется компьютером. Она состоит из директорий и разного вида файлов.

```
nodejs-package ## корневая директория
├── Makefile ## файл
├── README.md ## файл
├── __tests__ ## директория
│   └── half.test.js ## файл
├── babel.config.js ## файл
└── node_modules ## директория
    └── @babel ## директория
        └── cli ## директория
            └── LICENSE ## файл
```

Деревом она называется из-за своей структуры. Все элементы файловой системы выстраиваются в иерархию. В ней на верхнем уровне находится корневая директория (или диск, если речь идёт про Windows), а далее — файлы и директории, которые сами по себе могут содержать файлы и директории.

Ключевая черта древовидной структуры в том, что она **рекурсивна**. Другими словами, дерево состоит из поддеревьев, которые в свою очередь состоят из поддеревьев, которые в свою очередь... Эта особенность определяет основные способы работы с деревьями в коде, все они, так или иначе, работают рекурсивно.

Дерево состоит из **узлов** (вершин или нод, так как по-английски узел — это **node**) и **рёбер** между ними. Рёбра в реальности не существуют, они нужны лишь для того, чтобы визуализировать связь и, по необходимости, описать её. Узлы делятся на два типа: **внутренние** (те, у которых есть потомки) и **листовые** узлы (те, у которых нет потомков). В случае файловой системы листовые узлы представлены файлами, а внутренние — директориями.

![Деревья: узлы и листья](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijc0OTMzNDJiY2ExOGU0YzkzMzExMzYzY2QyMzlkMTRlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f38b5f19ee96bc8114dcc4123254f5730ce2c7b161ecbfaa9112409a4abb1b30)

У каждой вершины в дереве есть **родитель** (или предок). Единственным исключением является корневой узел — у него нет родителей, и именно с него начинается дерево. Количество потомков у любой внутренней вершины, в общем случае, может быть любым. Кроме того, в деревьях выделяют понятие глубины (depth), определяющей то, сколько шагов нужно пройти по вершинам от корневой, чтобы достичь текущей (той, на которую смотрим). Вершины, находящиеся на одной глубине и имеющие общего родителя, называют братскими или сестринскими.

### Реализация

Количество способов, которыми можно описать деревья, бесконечно. Самый примитивный вариант — это вложенные массивы:

```
[['index.html', 'main.js'], 'index.js', ['favicon.ico', 'app.css']];
//                    * корень – сам массив
//         /          |         \
//       *         index.js       *
//  /         |               |        \
// index.html main.js   favicon.ico app.css

// Ещё пара примеров деревьев с произвольными данными:
[]; // пустое дерево
[3, 2, [3, 8], [[8], 3]];
[1, null, [[3]], [5, 'string', [undefined, [3], { key: 'value' }]]];
```

В примерах выше корень — это сам массив, а все его элементы — это дети. Если ребёнок не является массивом, то он рассматривается как листовой узел, иначе — как внутренний узел. Внутренний узел, в свою очередь, состоит из детей.

Любое дерево состоит из двух больших частей:

1. Данных, которые хранятся внутри дерева
2. Структуры дерева, которая отвечает за связи между данными

```
[['index.html', 'main.js'], 'index.js', ['favicon.ico', 'app.css']];
```

Что в этом дереве структура, а что данные? Данные здесь – листовые узлы, а вот внутренние массивы – исключительно структура. Они определяют, где какие данные (в данном случае файлы) находятся, но сами не содержат никаких данных. Подобная организация дерева непригодна для хранения файловой структуры. Как минимум это дерево не позволяет задать имя для директории.

Расширим структуру так, чтобы она позволяла добавлять больше информации. Представим каждый элемент дерева массивом, в котором первый элемент — это значение, хранящееся в узле, а второй элемент — массив детей. Если второй элемент отсутствует, то считаем, что текущий узел — листовой.

```
['app', [ // Корень
  ['dist', [ // Внутренний узел
    ['index.html'], // Лист
    ['main.js'] // Лист
  ]],
  ['index.js'], // Лист
  ['assets', [ // Внутренний узел
    ['favicon.ico'], // Лист
    ['app.css'], // Лист
  ]],
]];

//                   app
//         /          |         \
//       dist      index.js   assets
//  /         |               |        \
// index.html main.js   favicon.ico app.css
```

Такой вариант многословнее, но позволяет хранить данные в любом узле, даже не листовом. Причём это не обязательно должна быть строка как в примере выше. Изменение данных на объекты позволит добавлять туда все что угодно.

И самый гибкий и удобный способ представления деревьев — это объекты. В таком дереве каждый узел это объект, а массивы используются только для хранения списка детей.

```
// Обратите внимание на разделение структуры и данных
// Здесь оно значительно более очевидное
{
  value: 5,
  children: [
    { value: 10 },
    { value: 100 },
    { value: 'nested', children: [/* ... */] }
  ]
}
```

По большому счёту, что массив, что объект сами по себе всегда могут рассматриваться как деревья. Это справедливо для любой рекурсивной структуры данных, то есть для такой структуры, элементами которой может быть сама структура. В любом массиве может содержаться массив, как и в любом объекте может содержаться объект.

---

##### Дополнительные материалы

1. [Фракталы](https://ru.wikipedia.org/wiki/Фрактал)
2. [Абстрактное-синтаксическое дерево JavaScript](https://esprima.org/demo/parse.html)

## Виртуальная файловая система—JS: Деревья

В этом курсе мы создадим виртуальную (не настоящую) файловую систему и реализуем повседневные операции для работы с ней: подсчёт свободного места, поиск файлов и директорий и т.п. Вот как выглядит создание этого дерева:

```
import { mkdir, mkfile } from '@hexlet/immutable-fs-trees';

// mkdir вторым параметром принимает список детей,
// которые могут быть либо директориями, созданными mkdir,
// либо файлами, созданными mkfile
const tree = mkdir('etc', [
  mkfile('bashrc'),
  mkdir('consul', [
    mkfile('config.json'),
  ]),
]);
```

В результате получается такая структура:

```
etc
├── bashrc
└── consul
    └── config.json
```

Вкладывая вызовы `mkdir` и `mkfile` в другие `mkdir`, можно получить любую файловую структуру. Корнем в этой структуре будет директория, а в листьях могут оказаться как файлы, так и пустые директории.

Эта структура виртуальная, то есть реального создания файлов и директорий не происходит. Вся информация о файловой системе находится в переменной `tree`. Если её распечатать на экран, то мы увидим следующее содержимое:

```
{
  name: 'etc',
  type: 'directory',
  meta: {},
  children: [
    {
      name: 'bashrc',
      type: 'file',
      meta: {},
    },
    {
      name: 'consul',
      type: 'directory',
      meta: {},
      children: [
        {
          name: 'config.json',
          type: 'file',
          meta: {},
        }
      ],
    },
  ],
};
```

Это внутренняя реализация файлового дерева. Она состоит из двух типов узлов: директорий и файлов.

Представление директории:

```
{
  name: /* ... */,
  type: 'directory',
  meta: {}, // Свойства директории
  children: [/* ... */], // Здесь хранятся дети
}
```

Представление файла:

```
{
  name: /* ... */,
  type: 'file',
  meta: {}, // Свойства файла
}
```

У файлов и директорий есть имена, это общая часть. Свойство `type` определяет тип узла и с его помощью можно понять, что перед нами во время обработки этого дерева. `meta` — объект с произвольными данными, например, размером, датой создания и так далее. Свойства задаются во время создания узлов:

```
mkfile('.bashrc', { size: 75 });
mkdir('hexlet', [/* дети */], { owner: 'nobody' });
```

Метаданные понадобятся функциям, которые анализируют дерево, например считают занятое место.

---

##### Дополнительные материалы

1. [Документация @hexlet/immutable-fs-trees](https://github.com/hexlet-components/js-immutable-fs-trees)

## Манипуляции с виртуальной файловой системой—JS: Деревья

Библиотека, которая используется для построения деревьев, рассчитана только на неизменяемые файловые структуры. То есть уже после создания её поменять нельзя. Но можно на основе старой структуры сделать новую, в которой какие-то части будут изменены.

Неизменяемая структура выбрана для этого курса неслучайно. Такую структуру легче отлаживать и меньше шансов допустить ошибки. И она позволяет максимально погрузиться в использование функций высшего порядка.

### Базовые операции с узлами

Пакет _@hexlet/immutable-fs-trees_ позволяет не только создавать, но и извлекать данные из уже созданных файлов и директорий с помощью базовых операций. Они позволяют не лезть во внутреннюю структуру самого дерева:

```javascript
import {
  mkfile,
  mkdir,
  getChildren,
  getMeta,
  getName,
} from "@hexlet/immutable-fs-trees";

const tree = mkdir("/", [mkfile("hexlet.log")], { hidden: true });
getName(tree); // '/'
getMeta(tree).hidden; // true

const [file] = getChildren(tree);
getName(file); // 'hexlet.log'

// У файла нет метаданных
getMeta(file).unknown; // undefined

// А вот так делать не надо
// У файлов нет детей
getChildren(file);
```

Дополнительно в пакете есть две функции для проверки типа. С их помощью можно выборочно работать с файлами и директориями:

```javascript
import {
  mkfile,
  mkdir,
  isFile,
  isDirectory,
  getChildren,
} from "@hexlet/immutable-fs-trees";

const tree = mkdir("/", [mkfile("hexlet.log")], { hidden: true });
isDirectory(tree); // true
isFile(tree); // false

const [file] = getChildren(tree);
isFile(file); // true
isDirectory(file); // false
```

Рассмотренных операций хватит для выполнения любых преобразований над файлами и директориями. Начнём с самых простых, которые не требуют рекурсивного обхода.

### Обработка

Любая обработка в неизменяемом стиле сводится к формированию новых данных на основе старых. Ниже мы реализуем некоторые варианты преобразования, раскрывающие эту идею.

#### Изменение имени файла

```javascript
const file = mkfile("one", { size: 35 });

// При переименовании важно сохранить метаданные
// _ – lodash
const newMeta = _.cloneDeep(getMeta(file));
const newFile = mkfile("new name", newMeta);
```

Фактически здесь создаётся новый файл с метаданными старого. Перед тем как создать новый файл, метаданные клонируются (глубоким клонированием). Почему? Объекты передаются по ссылке, и если не выполнить клонирование, то в метаданных нового файла окажутся метаданные старого. Как только мы захотим изменить что-то, то изменив новое — сломаем старое:

```javascript
const file = mkfile("one", { size: 35 });

// При переименовании важно сохранить метаданные
const newMeta = getMeta(file);
// Бум! У file тоже поменялись метаданные
newMeta.size = 15;
const newFile = mkfile("new name", newMeta);

console.log(getMeta(file)); // { size: 15 }
```

#### Сортировка содержимого директории

```javascript
// Сортировка в обратном порядке

const tree = mkdir("/", [mkfile("one"), mkfile("two"), mkdir("three")]);

const children = getChildren(tree);
const newMeta = _.cloneDeep(getMeta(tree));
// reverse изменяет массив, поэтому клонируем
const newChildren = children.slice().reverse();
const tree2 = mkdir(getName(tree), newChildren, newMeta);
console.log(tree2);
// => {
// =>   name: '/',
// =>   children: [
// =>     { name: 'three', children: [], meta: {}, type: 'directory' },
// =>     { name: 'two', meta: {}, type: 'file' },
// =>     { name: 'one', meta: {}, type: 'file' }
// =>   ],
// =>   meta: {},
// =>   type: 'directory'
// => }
```

#### Обновление содержимого директории

```javascript
// Приведение к нижнему регистру имён директорий и файлов
// внутри конкретной директории

const tree = mkdir("/", [mkfile("oNe"), mkfile("Two"), mkdir("THREE")]);

const children = getChildren(tree);
const newChildren = children.map((child) => {
  const name = getName(child);
  const newMeta = _.cloneDeep(getMeta(child));
  if (isDirectory(child)) {
    return mkdir(name.toLowerCase(), getChildren(child), newMeta);
  }
  return mkfile(name.toLowerCase(), newMeta);
});
// Обязательно копируем метаданные
const newMeta = _.cloneDeep(getMeta(tree));
const tree2 = mkdir(getName(tree), newChildren, newMeta);
console.log(tree2);
// => {
// =>   name: '/',
// =>   children: [
// =>     { name: 'one', meta: {}, type: 'file' },
// =>     { name: 'two', meta: {}, type: 'file' },
// =>     { name: 'three', children: [], meta: {}, type: 'directory' }
// =>   ],
// =>   meta: {},
// =>   type: 'directory'
// => }
```

#### Удаление файлов внутри директории

```javascript
const tree = mkdir("/", [mkfile("one"), mkfile("two"), mkdir("three")]);

const children = getChildren(tree);
const newChildren = children.filter(isDirectory);
const newMeta = _.cloneDeep(getMeta(tree));
const tree2 = mkdir(getName(tree), newChildren, newMeta);
console.log(tree2);
// => {
// =>   name: '/',
// =>   children: [ { name: 'three', children: [], meta: {}, type: 'directory' } ],
// =>   meta: {},
// =>   type: 'directory'
// => }
```

## Обход дерева—JS: Деревья

Пошаговый перебор элементов дерева по связям между узлами-предками и узлами-потомками называется **обходом дерева**. Подразумевается, что в процессе обхода каждый узел будет затронут только один раз. По большому счёту, всё так же, как и в обходе любой коллекции, используя цикл или рекурсию. Только в случае деревьев способов обхода больше, чем просто слева направо и справа налево.

В данном курсе используется один порядок обхода — **обход в глубину**, так как он естественным образом получается при рекурсивном обходе. Об остальных способах можно прочитать в Википедии либо в рекомендуемых Хекслетом книгах.

### Обход в глубину (Depth-first search)

Один из методов обхода дерева (графа в общем случае). Стратегия этого поиска состоит в том, чтобы идти вглубь одного поддерева настолько, насколько это возможно. Этот алгоритм естественным образом ложится на рекурсивное решение и получается сам собой.

![Depth-first Search](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjJhYzg5NzZmZGMwNmMzMDRkZWI5ZTA0NDkyZTlkZGYxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=4dfe120f2a6a11fc049372a5e4cbdaa53792a45a8ee290a4de81c1c28b5cf5bd)

Рассмотрим данный алгоритм на примере следующего дерева:

```
//     * A
//   / | \
// B * C * D
//  /|   |\
// E F   G J
```

Каждая нелистовая вершина обозначена звёздочкой. Обход начинается с корневого узла.

1. Проверяем, есть ли у вершины A дети. Если есть, то запускаем обход рекурсивно для каждого ребёнка независимо;
2. Внутри первого рекурсивного вызова оказывается следующее поддерево:

```
// B *
//  /|
// E F
```

Повторяем логику первого шага. Проваливаемся на уровень ниже.

1. Внутри оказывается листовой элемент `E`. Функция убеждается, что у узла нет дочерних элементов, выполняет необходимую работу и возвращает результат наверх.
2. Снова оказываемся в ситуации:

```
// B *
//  /|
// E F
```

В этом месте, как мы помним, рекурсивный вызов запускался на каждом из детей. Так как первый ребёнок уже был посещён, второй рекурсивный вызов заходит в узел `F` и выполняет там свою работу. После этого происходит возврат выше, и всё повторяется до тех пор, пока не дойдёт до корня.

```javascript
const tree = mkdir("/", [
  mkdir("etc", [mkfile("bashrc"), mkfile("consul.cfg")]),
  mkfile("hexletrc"),
  mkdir("bin", [mkfile("ls"), mkfile("cat")]),
]);

const dfs = (tree) => {
  // Распечатываем содержимое узла
  console.log(getName(tree));
  // Если это файл, то возвращаем управление
  if (isFile(tree)) {
    return;
  }

  // Получаем детей
  const children = getChildren(tree);

  // Применяем функцию dfs ко всем дочерним элементам
  // Множество рекурсивных вызовов в рамках одного вызова функции
  // называется древовидной рекурсией
  children.forEach(dfs);
};

dfs(tree);
// => /
// => etc
// => bashrc
// => consul.cfg
// => hexletrc
// => bin
// => ls
// => cat
```

https://repl.it/@hexlet/js-trees-traversal-dfs-nodejs

Печать на экран в примере выше это лишь демонстрация. В реальности же нас интересует либо изменение дерева, либо агрегация данных по нему. Агрегацию данных рассмотрим позже, а сейчас разберём изменение.

Допустим, мы хотим реализовать функцию, которая меняет владельца для всего дерева, то есть всех директорий и файлов. Для этого нам придётся соединить две вещи: рекурсию, разобранную выше, и код обновления узлов, который изучался в прошлом уроке.

```javascript
const changeOwner = (tree, owner) => {
  const name = getName(tree);
  const newMeta = _.cloneDeep(getMeta(tree));
  newMeta.owner = owner;

  if (isFile(tree)) {
    // Возвращаем обновлённый файл
    return mkfile(name, newMeta);
  }

  const children = getChildren(tree);
  // Ключевая строчка
  // Вызываем рекурсивное обновление каждого ребёнка
  const newChildren = children.map((child) => changeOwner(child, owner));
  const newTree = mkdir(name, newChildren, newMeta);

  // Возвращаем обновлённую директорию
  return newTree;
};

// Эту функцию можно обобщить до map (отображения) работающего с деревьями
```

https://repl.it/@hexlet/js-trees-traversal-changeOwner-nodejs

Ключевое отличие от первого примера – вместо печати на экран, формируются новые узлы и возвращаются наружу. В конце концов из них собирается новое дерево.

Всё, что будет дальше делаться по ходу курса, неизменно **базируется на этом алгоритме**. Попробуйте открыть редактор на своём компьютере и самостоятельно реализовать эту функцию без подглядывания. Так вы убедитесь в том, что поняли происходящее.

## Агрегация—JS: Деревья

Агрегация данных — наиболее важная операция при работе с деревьями. Подсчитать общее число файлов в директории, общий размер всех файлов, получить список всех файлов, найти все файлы по шаблону — всё это примеры агрегирования данных.

Ключевым моментом в агрегирующих операциях является накопление результата. Для данной задачи хорошо подходит обход дерева в глубину с использованием рекурсивного процесса, который подробно рассматривается в предыдущем уроке. С его помощью мы обходим все узлы дерева и собираем результат, начиная с самого нижнего уровня.

Рассмотрим агрегацию с использованием рекурсивного процесса на примере подсчёта общего количества узлов в дереве. То есть мы хотим узнать сколько всего файлов и директорий содержится в нашем файловом дереве.

```javascript
const tree = mkdir("/", [
  mkdir("etc", [mkfile("bashrc"), mkfile("consul.cfg")]),
  mkfile("hexletrc"),
  mkdir("bin", [mkfile("ls"), mkfile("cat")]),
]);

// В реализации используем рекурсивный процесс,
// чтобы добраться до самого дна дерева.
const getNodesCount = (tree) => {
  if (isFile(tree)) {
    // Возвращаем 1 для учёта текущего файла
    return 1;
  }

  // Если узел — директория, получаем его детей
  const children = getChildren(tree);
  // Самая сложная часть
  // Считаем количество потомков для каждого из детей,
  // вызывая рекурсивно нашу функцию getNodesCount
  const descendantCounts = children.map(getNodesCount);
  // Возвращаем 1 (текущая директория) + общее количество потомков
  return 1 + _.sum(descendantCounts);
};

getNodesCount(tree); // 8
```

https://repl.it/@hexlet/js-trees-aggregation-getNodesCount-nodejs

Кода здесь немного, но он довольно хитрый. Есть несколько ключевых моментов:

1. Функция проверяет тип узла. Если узел — это файл, тогда из функции возвращается единица.
2. В случае, если узел — директория, тогда получаем детей и для каждого ребёнка вновь вызываем нашу функцию. Затем повторяем алгоритм заново.
3. Вызов функции на каждом ребёнке возвращает свой собственный результат (количество его потомков). Эти результаты образуют массив с числами, которые нужно объединить.
4. В конце считается общее количество всех потомков узла + единица (текущий узел сам по себе).

Перед тем как двигаться дальше, с этим кодом нужно "поиграть". Это единственный способ разобраться с ним.

## Агрегация 2—JS: Деревья

Попрактикуемся ещё с одним вариантом агрегации данных на файловых системах. Напишем функцию, которая принимает на вход директорию и возвращает список директорий первого уровня вложенности и количество файлов внутри каждой из них, включая все поддиректории

```javascript
const tree = mkdir("/", [
  mkdir("etc", [mkdir("apache"), mkdir("nginx", [mkfile("nginx.conf")])]),
  mkdir("consul", [mkfile("config.json"), mkfile("file.tmp"), mkdir("data")]),
  mkfile("hosts"),
  mkfile("resolve"),
]);

console.log(getSubdirectoriesInfo(tree));
// => [['etc', 1], ['consul', 2]]
```

Внутри себя эта задача распадается на две:

- Реализация функции подсчёта файлов внутри директории
- Вызов данной функции для каждой из поддиректорий

Начнём с подсчёта количества файлов. Это классическая задача на агрегацию:

```javascript
const getFilesCount = (node) => {
  if (isFile(node)) {
    return 1;
  }

  const children = getChildren(node);
  const descendantCounts = children.map(getFilesCount);
  return _.sum(descendantCounts);
};
```

Следующий шаг заключается в том, чтобы извлечь всех детей из исходного узла и к каждому из них применить подсчёт:

```javascript
const getSubdirectoriesInfo = (tree) => {
  const children = getChildren(tree);
  const result = children
    // Нас интересуют только директории
    .filter(isDirectory)
    // Запускаем подсчёт для каждой директории
    .map((child) => [getName(child), getFilesCount(child)]);

  return result;
};
```

То есть мы обратились к детям напрямую сначала отфильтровав их, а затем выполнили отображение на необходимый массив, содержащий для каждой директории имя и количество файлов в нем.

## Аккумулятор—JS: Деревья

В некоторых ситуациях во время обхода дерева нужна дополнительная информация, которая зависит от расположения узла. Её невозможно получить из описания самого узла, так как узел её не содержит. Эту информацию нужно собирать прямо во время обхода.

К такой информации, например, относится полный путь до файла или глубина текущего узла. Конкретный узел не знает о том, где он находится. Расположение файла в файловой структуре определяется узлами, которые ведут к конкретному файлу.

В этом уроке мы познакомимся с понятием **аккумулятор**, специальным параметром, который собирает нужные данные во время обхода дерева. Его введение усложняет код, но без него подобные задачи выполнить невозможно.

Возьмём для примера такую задачу: найдём все пустые директории в нашей файловой системе. Сначала реализуем простую версию, затем усложним её и внедрим аккумулятор. Пример файловой системы ниже:

```javascript
const tree = mkdir("/", [
  mkdir("etc", [
    mkdir("apache"),
    mkdir("nginx", [mkfile("nginx.conf")]),
    mkdir("consul", [mkfile("config.json"), mkdir("data")]),
  ]),
  mkdir("logs"),
  mkfile("hosts"),
]);
```

В этой структуре три пустых директории: _/logs_, _/etc/apache_ и _/etc/consul/data_. Код, решающий эту задачу, выглядит так:

```javascript
const findEmptyDirPaths = (tree) => {
  const name = getName(tree);
  const children = getChildren(tree);
  // Если детей нет, то добавляем директорию
  if (children.length === 0) {
    return name;
  }

  // Фильтруем файлы, они нас не интересуют
  const emptyDirNames = children
    .filter((child) => !isFile(child))
    // Ищем пустые директории внутри текущей
    // flatMap выправляет массив, так что он остаётся плоским
    .flatMap(findEmptyDirPaths);

  return emptyDirNames;
};

findEmptyDirPaths(tree); // ['apache', 'data', 'logs']
```

https://repl.it/@hexlet/js-trees-search-findEmptyDirs-nodejs

Самое необычное в этой реализации функция `flatMap()`. Зачем она нужна? Если оставить только `map()`, то результат может удивить:

```
findEmptyDirPaths(tree);

// [ [ 'apache', [], [ 'data' ] ], 'logs' ]
```

Такое происходит из-за возврата массива на каждом уровне вложенности. На выходе получается массив массивов, напоминающий по структуре исходное файловое дерево. Чтобы этого не происходило, нужно выправлять код с помощью `flat()`, либо сразу использовать `flatMap()`.

Попробуем усложнить задачу. Найдём все пустые директории, но с максимальной глубиной поиска 2 уровня. То есть директории _/logs_ и _/etc/apache_ подходят под это условие, а вот _/etc/consul/data_ — нет.

Для начала нужно понять, откуда брать глубину. В деревьях глубина считается как количество рёбер от корня до нужного узла. Визуально её посчитать легко, а что насчёт кода? Глубину конкретного узла можно представить как глубину предыдущего узла плюс единица.

Следующий шаг – добавить переменную, которая передаётся при каждом рекурсивном вызове (проваливающемся в директорию). Эта переменная, в случае нашей задачи, содержит внутри себя текущую глубину. То есть на каждом уровне (внутри каждой директории) к ней добавляется единица. Такую переменную называют _аккумулятором_, так как она _аккумулирует_, то есть накапливает данные.

Единственная проблема заключается в том, что у исходной функции `findEmptyDirPaths()` ровно один параметр – узел. С её помощью невозможно передавать глубину всем вложенным директориям и файлам. Поэтому придётся ввести внутреннюю функцию, которая сможет "пробрасывать" аккумулятор дальше по дереву:

```javascript
const findEmptyDirPaths = (tree) => {
  // Внутренняя функция, которая может передавать аккумулятор
  // В качестве аккумулятора выступает depth, переменная, содержащая текущую глубину
  const iter = (node, depth) => {
    const name = getName(node);
    const children = getChildren(node);

    // Если директория пустая, то добавляем ее в список
    if (children.length === 0) {
      return name;
    }

    // Если это второй уровень вложенности, и директория не пустая
    // то не имеет смысла смотреть дальше
    if (depth === 2) {
      // Почему возвращается именно пустой массив?
      // Потому что снаружи выполняется flat
      // Он раскрывает пустые массивы
      return [];
    }

    // Оставляем только директории
    return (
      children
        .filter(isDirectory)
        // Не забываем увеличивать глубину
        .flatMap((child) => iter(child, depth + 1))
    );
  };

  // Начинаем с глубины 0
  return iter(tree, 0);
};

findEmptyDirPaths(tree); // ['apache', 'logs']
```

https://repl.it/@hexlet/js-trees-accumulator-findEmptyDirsWithDepth

Можно пойти ещё дальше и позволить указывать максимальную глубину снаружи:

```javascript
const findEmptyDirPaths = (tree, maxDepth = 2) => {
  // ...
};
```

Но возникает вопрос, а как сделать так, чтобы по умолчанию просматривалось всё дерево? Например, можно взять заведомо большое число и сделать его значением по умолчанию. Такой подход сработает, но это хак. Правильный способ сделать это – использовать в качестве значения по умолчанию бесконечность _Infinity_:

```javascript
const findEmptyDirPaths = (tree, maxDepth = Infinity) => {
  // ...
};
```

---

##### Дополнительные материалы

1. [Параметры для внутренних нужд](https://ru.hexlet.io/blog/posts/sovershennyy-kod-plohie-i-horoshie-praktiki-pri-proektirovanii-parametrov-funktsiy)

## Дополнительные материалы

### [JS: Деревья](https://ru.hexlet.io/courses/js-trees)

1. [Введение](https://ru.hexlet.io/courses/js-trees/lessons/intro/theory_unit)
   - [Рекурсия, рекурсивный процесс и итеративный процесс](https://ru.hexlet.io/blog/posts/recursive)
2. [Определения](https://ru.hexlet.io/courses/js-trees/lessons/definition/theory_unit)
   - [Фракталы](https://ru.wikipedia.org/wiki/Фрактал)
   - [Абстрактное-синтаксическое дерево JavaScript](https://esprima.org/demo/parse.html)
3. [Виртуальная файловая система](https://ru.hexlet.io/courses/js-trees/lessons/filetree/theory_unit)
   - [Документация @hexlet/immutable-fs-trees](https://github.com/hexlet-components/js-immutable-fs-trees)
4. [Манипуляции с виртуальной файловой системой](https://ru.hexlet.io/courses/js-trees/lessons/manipulations/theory_unit)
   - Без материалов
5. [Обход дерева](https://ru.hexlet.io/courses/js-trees/lessons/traversal/theory_unit)
   - Без материалов
6. [Агрегация](https://ru.hexlet.io/courses/js-trees/lessons/aggregation/theory_unit)
   - Без материалов
7. [Агрегация 2](https://ru.hexlet.io/courses/js-trees/lessons/calculate/theory_unit)
   - Без материалов
8. [Аккумулятор](https://ru.hexlet.io/courses/js-trees/lessons/accumulator/theory_unit)
   - [Параметры для внутренних нужд](https://ru.hexlet.io/blog/posts/sovershennyy-kod-plohie-i-horoshie-praktiki-pri-proektirovanii-parametrov-funktsiy)

- [О проекте](https://ru.hexlet.io/pages/about)
- [Карьера в Хекслете](https://www.notion.so/hexlet/c6406ed8890747e690d32b050faf42c2)
- [Отзывы студентов](https://ru.hexlet.io/testimonials)
- [Истории успеха](https://ru.hexlet.io/blog/categories/success)
- [Магазин мерча](https://hexlet.printdirect.ru/?partner_id=615497)

Hexlet Ltd.UMA Esplanadi, Pohjoisesplanadi 39, 00100 Helsinki, FinlandVAT ID: FI26641607

- [Условия использования](https://ru.hexlet.io/pages/tos)

- [Политика конфиденциальности](https://ru.hexlet.io/pages/privacy)

- [Публичная оферта](https://ru.hexlet.io/pages/offer)

- [Акции](https://ru.hexlet.io/pages/promo)

```

```
