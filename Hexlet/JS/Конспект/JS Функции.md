## О курсе—JS: Функции


Функции – мощный инструмент с широкими возможностями. Данный курс создан для того, чтобы разобраться с функциями по-настоящему. Всё, что было до этого курса, всего лишь верхушка айсберга.

В этом курсе мы научимся создавать функции так, чтобы код получался предсказуемым и удобным. Разберём обработку коллекций и увидим, как функции используются в библиотеках и современных веб-фреймворках.

Основные понятия курса:

- Чистые функции и побочные эффекты. Детерминированность.
- Область видимости и замыкание
- spread и rest операторы
- Объекты первого рода
- Функции высшего порядка
- Функциональное программирование

Не все из перечисленных тем и возможностей используются в повседневной жизни JS-разработчика (в других языках может быть совсем по-другому), но знать про них нужно. Во-первых, подходы, разбираемые в этом курсе, не являются специфичными для JavaScript. Зная их, вы гораздо легче сможете переключаться на другие языки. Во-вторых, работа с функциями сильно прокачивает общий уровень разработчика.



## Чистые функции—JS: Функции


Функции в программировании обладают рядом важных характеристик. Зная их, мы можем точнее определять, как лучше разбивать код на функции и когда вообще их стоит выделять.

### Детерминированность

Встроенная в JavaScript функция [Math.random()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/random) возвращает случайное число от *0* до *1*:

```javascript
Math.random(); // 0.9337432365797949
Math.random(); // 0.5550694016887598
```

Функция нужная и полезная, но неудобная в отладке и тестировании. Это связано с тем, что для одних и тех же входных аргументов (отсутствие аргументов также попадает под это понятие), она может возвращать разные значения. Функции с таким поведением называются недетерминированными.

Например, недетерминированными являются функции, оперирующие системным временем. Так, функция [Date.now()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/now) каждый раз возвращает новое значение:

```javascript
// Возвращает текущее время в миллисекундах
Date.now(); // 1571909874844
Date.now(); // 1571909876648
```

А вот пример с аргументами. Представьте функцию `getAge()`, которая принимает на вход год рождения и возвращает возраст:

```javascript
getAge(2000); // ?
```

Хотя прямо сейчас повторный запуск вернёт точно такое же значение, через год оно уже будет другим. То есть функция считается недетерминированной, если она ведёт себя так хотя бы единожды.

Детерминированные функции, напротив, ведут себя предсказуемо. Для одних и тех же входных данных они всегда выдают один и тот же результат. Именно такими являются функции в математике.

Интересно что, например, функция `console.log()` — детерминированная. Дело в том, что она всегда возвращает одно и то же значение для любых входных данных. Это значение `undefined`, а не то, что печатается на экран, как можно было бы подумать. Печать на экран — побочный эффект, о нём мы поговорим чуть позже.

```javascript
console.log('Hexlet – Big Bang');
```

Вызов `console.log('Hexlet - Big Bang')` выполнил два действия:

- Вывел сообщение *Hexlet - Big Bang* в терминал (или консоль браузера, в зависимости от среды выполнения)
- Вернул значение `undefined`. Какое сообщение бы мы не печатали, возвращаемое значение всегда будет одно — `undefined`.

Функция становится недетерминированной и в том случае, если она обращается не только к своим аргументам, но и некоторым внешним данным, например глобальным переменным, переменным окружения и так далее. Так происходит потому, что внешние данные могут измениться, и функция начнёт выдавать другой результат, даже если в неё передаются одни и те же аргументы.

```javascript
const getCurrentShell = () => process.env.SHELL;

getCurrentShell(); // /bin/bash
```

Функция `getCurrentShell()` обращается к переменной окружения `SHELL`. Но в разные моменты времени и в разных окружениях значение этой переменой может быть различным.

В общем случае нельзя сказать, что отсутствие детерминированности — абсолютное зло. Для работы многих программ и сайтов нужна функция, возвращающая случайное число или вычисляющая текущую дату. С другой стороны, в нашей власти разделить код так, чтобы в нем было как можно больше детерминированных частей. Общая рекомендация при работе с детерминированностью звучит следующим образом: если есть возможность написать функцию так, что она будет детерминированной, то так и делайте. Не используйте глобальных переменных, создавайте функции, зависящие только от своих собственных аргументов.

Понятие "Детерминированность" не ограничивается программированием или математикой. Сквозь него можно рассматривать практически любой процесс. Например, подбрасывание монетки — недетерминированный процесс, его результат случаен.

### Побочные эффекты (side effects)

Вторая ключевая характеристика функций — наличие побочных эффектов. Побочными эффектами называют любые взаимодействия с внешней средой. К ним относятся файловые операции, такие как запись в файл, чтение файла, отправка или приём данных по сети и даже вывод в консоль.

```javascript
const someFunction = () => {
  // Функция fetch выполняет HTTP-запрос
  // HTTP-запрос — это побочный эффект
  fetch('https://ru.hexlet.io/courses');
};
```

Кроме того, побочными эффектами считаются изменения внешних переменных (например, глобальных) и входных параметров в случае, когда они передаются по ссылке.

```javascript
const someFunction = (obj) => {
  // Какая-то логика
  // Побочный эффект. Изменение входного аргумента.
  obj.key = 'value';
};
```

А вот вычисления (логика), напротив, не содержат побочных эффектов. Например, функция, суммирующая два переданных аргументами числа.

```javascript
const sum = (num1, num2) => num1 + num2;
```

Побочные эффекты составляют одну из самых больших сложностей при разработке. Их наличие значительно затрудняет логику кода и тестирование. Приводит к возникновению огромного числа ошибок. Только при работе с файлами количество возможных ошибок измеряется сотней: начиная с того, что закончилось место на диске, заканчивая попыткой читать данные из несуществующего файла. Для их предотвращения код обрастает большим числом проверок и защитных механизмов.

Без побочных эффектов невозможно написать ни одной полезной программы. Какие бы важные вычисления она ни делала, их результат должен быть как-то продемонстрирован. В самом простом случае его нужно вывести на экран, что автоматически приводит нас к побочным эффектам:

```javascript
console.log(sum(4, 11)); // => 15
```

В реальных же приложениях, обычно, все сводится к взаимодействию с базой данных или отправкой запросов по сети.

Не существует способа избавиться от побочных эффектов совсем, но их влияние на программу можно минимизировать. Как правило, в типичной программе побочных эффектов не так много по отношению к остальному коду, и происходят они лишь в самом начале и в конце. Например, программа, которая конвертирует файл из текстового формата в PDF, в идеале выполняет ровно два побочных эффекта:

1. Читает файл в самом начале работы программы.
2. Записывает результат работы программы в новый файл.

Между этими двумя пунктами и происходит основная работа, которая содержит чистую алгоритмическую часть. Побочные эффекты в таком случае будут находиться только в верхнем слое приложения, а ядро, выполняющее основную работу, останется чистым от них.

*Инкремент и декремент — единственные базовые арифметические операции в JS, которые обладают побочными эффектами (изменяют само значение в переменной). Именно поэтому с ними сложно работать в составных выражениях. Они могут приводить к таким сложноотлавливаемым ошибкам, что во многих языках вообще отказались от их введения (в Ruby и Python их нет). В JS [стандарты кодирования](https://github.com/leonidlebedev/javascript-airbnb#variables--unary-increment-decrement) предписывают их не использовать.*

### Чистые функции

![Чистые функции в JavaScript](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImFjNmU0NWZlNGUzNWU4MDk3M2Q3OTQ1MTI4ZjZlZjE1LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=626960ab20159521f2a746b025ed14fb4b142263797e9c364805bcc3c075c35f)

Идеальная функция с точки зрения удобства работы с ней называется чистой (pure). Чистая функция — это детерминированная функция, которая не производит побочных эффектов. Такая функция зависит только от своих входных аргументов и всегда ведёт себя предсказуемо.

Чистые функции обладают рядом ключевых достоинств:

- Их просто тестировать. Достаточно передать на вход функции нужные параметры и посмотреть ожидаемый выход.
- Их безопасно запускать повторно, что особенно актуально в асинхронном коде или в случае многопоточного кода.
- Их легко комбинировать, получая новое поведение без необходимости переписывать программу (подробнее далее по курсу).

В хорошо спроектированных программах побочные эффекты стараются изолировать в небольшой части приложения так, чтобы большая часть кода была чистой.

Прямо сейчас сказанное выше может звучать довольно абстрактно. Осознание этой темы требует не только общего понимания прочитанного, но и набитых шишек, связанных со сложностью работы в мешанине побочных эффектов. Тему чистоты мы будем поднимать регулярно. Особенно сильно она прорабатывается в проектах, на живом коде.

------

##### Дополнительные материалы

1. [Побочные эффекты](https://ru.wikipedia.org/wiki/Побочный_эффект_(программирование))
2. [Детерминированная функция](https://ru.wikipedia.org/wiki/Чистота_функции#Детерминированность_функции)

## Разделение команд и запросов—JS: Функции


Command-query Separation (CQS) — принцип программирования, изобретённый Бертраном Мейером, создателем языка Eiffel. Согласно этому принципу, каждая функция является либо командой, которая выполняет действие (action), либо запросом (query), который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов.

### Команда

```javascript
// Возвращает true или false как результат своего выполнения
save(user);
```

Согласно принципу CQS, функция `save()` является командой. Единственное, что она может — возвращать (опять же согласно принципу) успешность своего выполнения, то есть `true` или `false` (либо `undefined`, как в случае с `console.log()`). Возврат этой функцией любых осмысленных данных рассматривается как нарушение CQS. Однако, стоит сказать, что существуют ситуации, в которых невозможно соблюсти этот принцип. Например, открытие файла на запись возвращает файловый дескриптор — необходимый идентификатор, через который происходят манипуляции с файлом.

```javascript
const file = fopen('/etc/hosts', 'r');
```

Отделение команд от запросов тесно связано с идеями, описанными в уроке про чистые функции. Команды по определению выполняют недетерминированный код с побочными эффектами. Недетерминированный, потому что повторный вызов команды приводит либо к ошибке, либо к повторному выполнению действия (хотя их и можно сделать детерминированными, но, как правило, такой код скрывает логические ошибки). Следовательно, выделение запроса (возврата данных) из команды в отдельную функцию, помогает изолировать чистый код от кода с эффектами.

### Запрос

```javascript
// Возвращает true или false
isAdmin(user);
```

Функция `isAdmin()` — предикат, типичный запрос (query) или, можно даже сказать, вопрос, который звучит так "Пользователь — администратор?" Такая функция, с точки зрения CQS, не может изменять состояние системы: например, поменять дату проверки на администратора внутри пользователя или даже сделать пользователя администратором. Это противоречит не только CQS, но и здравому смыслу. В отличие от предыдущего примера, `true` и `false` в случае предикатов — это не успешность выполнения функции, а ответ на заданный вопрос.

Взгляните на пример работы функции, которая меняет исходные данные:

```javascript
const users = [
  { 'name': 'Stan', 'children': ['John', 'Mary'] },
  { 'name': 'Donald', 'children': ['James'] },
  { 'name': 'Lily', 'children': [] },
];

// takeChildren() возвращает массив детей всех пользователей
takeChildren(users); // ['John', 'Mary', 'James']
// На самом деле внутри она меняет массив users и возвращает его наружу
console.log(users); // => ['John', 'Mary', 'James']
```

Если сделать еще один вызов `takeChildren(users)`, то выполнение кода, скорее всего, завершится с ошибкой, так как изменилась структура исходного массива. Такое поведение функции-запроса противоестественно. CQS имеет альтернативную формулировку, которая отлично характеризует код выше: "Задавая вопрос, не изменяй ответ".

К запросам относятся и любые вычисления:

```javascript
// Функция Math.max() возвращает максимальное число из переданных
const getMaxNumber = Math.max(1, 30, 4); // 30
```

Этот код не создаёт никаких побочных эффектов и детерминирован. Его можно вызывать сколько угодно раз без риска получить ошибку или неверный результат.

Отсутствие изменения в запросах — очень важный принцип, который нужно соблюдать всегда. Даже на интуитивном уровне ни один человек не ожидает, что проверка `isAdmin()` или вычисление максимального числа в массиве, может выполнить какое-то деструктивное действие. С другой стороны, на практике такой код иногда попадается, и теперь вы знаете, как правильно его исправить.

Как поступать в случаях, когда невозможно отделить команду от запроса? Представьте себе функцию, которая должна сформировать имя пользователя, если его не существует, и записать его в базу данных. Такая задача стоит в [4 проекте Хекслета](https://frontend-l4-chat.herokuapp.com/) на фронтенде. В этом проекте разрабатывается аналог [Slack](http://slack-ru.hexlet.io/). При заходе на сайт, пользователь сразу попадает в чат и в этот момент ему генерируется случайное имя пользователя.

Логика этой функции выглядит так:

```javascript
// Проверяем есть ли
let username = getName();
if (!username) {
  // Если имени нет, то генерируем и запоминаем
  username = generateName();
  setName(username);
}
```

Если убрать эту логику внутрь функции, то как она должна называться? Посмотрите на такой вариант:

```javascript
const username = getUserName();
```

Такое имя функции вводит в заблуждение. Оно выглядит как запрос, но не является им. Не зная устройство этой функции, невозможно догадаться о происходящем внутри. Первая мысль всегда будет о том, что это просто чтение каких-то уже записанных данных.

Правильный подход в подобных ситуациях – именовать функцию как команду. Тогда у нее не будет скрытых смыслов. Да она все еще будет нарушать CQS, но здесь мы и не пытаемся от этого уйти. Главное – явно показанное намерение:

```javascript
const username = setUserName();

// Или даже так
const username = setUserNameIfEmpty();
```

------

##### Дополнительные материалы

1. [Command-query Separation](https://ru.wikipedia.org/wiki/CQRS)
2. [Принцип наименьшего удивления](https://ru.wikipedia.org/wiki/Правило_наименьшего_удивления)

## Оператор Rest (упаковка аргументов)—JS: Функции


Давайте попробуем реализовать очень простую функцию, суммирующую числа. Для начала определим функцию `sum()`, принимающую на вход два числа и возвращающую их сумму:

```javascript
const sum = (a, b) => a + b;

sum(1, 2);   // 3
sum(-3, 10); // 7
```

Пока всё просто и понятно. Сложности возникают при дополнительных требованиях: что, если захотим суммировать не два, а три числа? Или пять, или даже десять? Писать для обработки каждого случая отдельную функцию — очевидно плохой вариант:

```javascript
const sumOfTwo = (a, b) => a + b;
const sumOfTree = (a, b, c) => a + b + c;
const sumOfTen = (a, b, c, d, e, f, g, h, i, j) => a + b + c + d + e + f + g + h + i + j; // фух...
// const sumoOfThousand = ???
// const sumOfMillion = ???
```

Надо, чтобы единая функция могла работать с разным количеством аргументов. Как это сделать?

Можно заметить, что в стандартной библиотеке JavaScript существуют функции, которые могут принимать разное количество аргументов. Например, сигнатура функции [Math.max()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/max) определяется так:

```javascript
Math.max([value1[, value2[, ...]]])
```

Она говорит нам о том, что в `Math.max()` можно передать любое количество элементов и они не обязательны:

```javascript
Math.max(10, 20);             // 20
Math.max(10, 20, 30);         // 30
Math.max(10, 20, 30, 40, 50); // 50
Math.max(-10, -20, -30);      // -10
```

С точки зрения вызова — ничего необычного, просто разное число аргументов. А вот определение функции с переменным числом аргументов выглядит необычно:

```javascript
const func = (...params) => {
  // params — это массив, содержащий все
  // переданные при вызове функции аргументы
  console.log(params);
};

func();            // => []
func(9);           // => [9]
func(9, 4);        // => [9, 4]
func(9, 4, 1);     // => [9, 4, 1]
func(9, 4, 1, -3); // => [9, 4, 1, -3]
```

https://repl.it/@hexlet/js-functions-rest-operator-rest-parameters

Символ троеточия `...` перед именем формального параметра в определении функции обозначает rest-оператор. Запись `...params` в определении `func()` из примера выше означает буквально следующее: "все переданные при вызове функции аргументы поместить в массив `params`".

Если вовсе не передать аргументов, то массив `params` будет пустым:

```javascript
func(); // => []
```

В функцию можно передать любое количество аргументов — все они попадут в массив `params`:

```javascript
func(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
// => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Аргументы могут быть любого типа — числа, строки, массивы и др.:

```javascript
func(1, 2, 'hello', [3, 4, 5], true);
// => [1, 2, 'hello', [3, 4, 5 ], true]
```

Теперь у нас достаточно знаний, чтобы с помощью rest-оператора переписать нашу функцию `sum()` так, чтобы она умела суммировать любое количество чисел (а не только два числа, как сейчас):

```javascript
const sum = (...numbers) => {
  // По умолчанию 0, так как сумма ничего это 0
  let result = 0;
  for (let num of numbers) {
    result += num;
  }
  return result;
};

sum();         // 0
sum(10);       // 10
sum(10, 4);    // 14
sum(8, 10, 4); // 22
```

https://repl.it/@hexlet/js-functions-rest-operator-sum

В таком контексте массив можно считать как "необязательные аргументы", которые можно либо вовсе не передавать, либо передавать столько, сколько хочешь. А что, если мы захотим, чтобы функция имела два обыкновенных ("обязательных") именованных параметра, а остальные были необязательными и сохранялись в rest-массиве? Всё просто: при определении функции сначала указываем стандартные именованные формальные параметры (например, `a` и `b`) и в конце добавляем rest-массив:

```javascript
const func = (a, b, ...params) => {
  // параметр 'a' содержит первый аргумент
  console.log(`a -> ${a}`);
  // параметр 'b' содержит второй аргумент
  console.log(`b -> ${b}`);
  // params содержит все остальные аргументы
  console.log(params);
};

func(9, 4);
// => a -> 9
// => b -> 4
// => []
func(9, 4, 1);
// => a -> 9
// => b -> 4
// => [1]
func(9, 4, 1, -3);
// => a -> 9
// => b -> 4
// => [1, -3]
func(9, 4, 1, -3, -5);
// => a -> 9
// => b -> 4
// => [1, -3, -5]
```

https://repl.it/@hexlet/js-functions-rest-operator-many-more-args

То же можно сделать и для одного аргумента:

```javascript
const func = (a, ...params) => {
  // ...
};
```

и для трёх:

```javascript
const func = (a, b, c, ...params) => {
  // ...
};
```

Эту идею можно продолжать и дальше, делая обязательными то количество аргументов, которое требуется. Единственное ограничение: rest-оператор может быть использован только для последнего параметра. То есть такой код синтаксически неверен:

```javascript
const func = (...params, a) => {
  // ...
};
```

И такой тоже:

```javascript
const func = (a, ...params, b) => {
  // ...
};
```

Именно поэтому оператор называется *rest*, то есть он организует хранение "остальных" ("оставшихся", последних) параметров.



## Оператор Spread (распаковка аргументов)—JS: Функции



spread-оператор в **вызовах** функций **синтаксически** идентичен rest-оператору в определениях, но выполняет **обратное** действие. Посмотрим на примере функции `sum()`:

```javascript
const sum = (...numbers) => {
  let result = 0;
  for (let num of numbers) {
    result += num;
  }
  return result;
};
```

Вызовем `sum()`, применив spread-оператор к массиву аргументов:

```javascript
const numbers = [1, 7, 4];
sum(...numbers); // 12
```

spread-оператор раскладывает массив на аргументы. Количество аргументов, полученных spread-оператором, равно количеству элементов массива. По сути, код выше преобразуется в вызов:

```javascript
sum(numbers[0], numbers[1], numbers[2]);
// sum(1, 7, 4);
```

Как и в случае с определением функций, spread-оператор может использоваться совместно с позиционными аргументами:

```javascript
const numbers = [1, 7, 4];
sum(8, ...numbers); // 20

sum(8, 10, ...numbers);     // 30
sum(8, 10, 70, ...numbers); // 100
```

В отличие от rest-оператора в определении функций, spread-оператор не обязательно должен быть последним, он может располагаться в любой позиции:

```javascript
const numbers = [1, 7, 4];

sum(8, 10, ...numbers); // 30
sum(8, ...numbers, 10); // 30
sum(...numbers, 8, 10); // 30
```

Более того, может быть любое количество spread-операторов и в любом порядке:

```javascript
const numbers1 = [1, 7, 4];
const numbers2 = [5, 5];

// sum(1, 7, 4, 5, 5);
sum(...numbers1, ...numbers2); // 22

// sum(5, 5, 1, 7, 4);
sum(...numbers2, ...numbers1); // 22

// sum(8, 1, 7, 4, 10, 5, 5);
sum(8, ...numbers1, 10, ...numbers2); // 40
```


## Деструктуризация параметров—JS: Функции


Когда мы передаём аргумент при вызове функции, его значение присваивается параметру функции. Это неявное автоматическое присваивание, потому что в коде этой операции "не видно".

```javascript
const func = (x) => {
  // параметру x будет присвоено
  // значение аргумента при вызове функции
  console.log(x);
};

func(1); // => 1
// Это можно представить так, что
// внутри функции создаётся параметр x,
// которому присваивается значение аргумента:
// {
//   let x = 1;
//   console.log(x);
// };

func([1, 2]); // => [1, 2]
// Пример с передачей массива:
// {
//   let x = [1, 2];
//   console.log(x);
// };
```

Передача аргумента ничем не отличается от обыкновенного присвоения значения переменной. Это значит, что нам доступна деструктуризация прямо в определении функции.

### Деструктуризация массива

Напишем функцию, которая принимает на вход массив из двух элементов и печатает их в терминал. Рассмотрим разные способы реализации работы с параметрами.

Не самый выразительный вариант — прямое обращение к элементам массива по индексам:

```javascript
const func = (elements) => {
  console.log(elements[0]);
  console.log(elements[1]);
};

// let elements = [1, 2];
func([1, 2]);
// => 1
// => 2
```

Более интересный вариант — деструктуризация массива в теле функции:

```javascript
const func = (elements) => {
  const [first, second] = elements;
  console.log(first);
  console.log(second);
};

// let elements = [1, 2];
func([1, 2]);
// => 1
// => 2
```

https://repl.it/@hexlet/js-functions-params-destructuring-in-function-body

Но можно пойти еще дальше и добавить деструктуризацию прямо в определение:

```javascript
const func = ([first, second]) => {
  console.log(first);
  console.log(second);
};

// let [first, second] = [1, 2];
func([1, 2]);
// => 1
// => 2
```

https://repl.it/@hexlet/js-functions-params-destructuring-input-argument

При этом действуют все стандартные правила деструктуризации массива:

```javascript
const elements = [1, 2];

// let [first, second] = elements;
func(elements);
// => 1
// => 2

// let [first, second] = [1];
func([1]);
// => 1
// => undefined

// let [first, second] = [];
func([]);
// => undefined
// => undefined
```

Если в передаваемом массиве меньше двух элементов, параметры, которым "не хватило" соответствующих значений, будут содержать `undefined`. Для таких случаев можно подстраховаться и задать значение по умолчанию:

```javascript
const func = ([first = 666, second = 777]) => {
  console.log(first);
  console.log(second);
};

// [first = 666, second = 777] = [1];
func([1]);
// => 1
// => 777

// [first = 666, second = 777] = [];
func([])
// => 666
// => 777
```

https://repl.it/@hexlet/js-functions-params-destructuring-default-value

### Деструктуризация объекта

Напишем функцию, которая принимает на вход объект с информацией об имени и фамилии пользователя и выводит их в терминал. Сразу реализуем вариант с деструктуризацией объекта для параметров:

```javascript
const func = ({ name, surname }) => {
  console.log(name);
  console.log(surname);
};

// let { name, surname } = { name: 'John', surname: 'Doe' };
func({ name: 'John', surname: 'Doe' });
// => John
// => Doe
```

https://repl.it/@hexlet/js-functions-params-destructuring-object

Типичная ситуация на практике, когда на вход функции приходит объект с большим количеством свойств, но фактически нужны значения не всех свойств, а всего нескольких. Например, это бывает при обработке HTTP-ответа (response) от сервера или конфигурации для программы. В таких случаях мы забираем только нужные значения — ведь при деструктуризации необязательно указывать все свойства объекта:

```javascript
const func = ({ surname }) => {
  // берём только значения surname
  console.log(surname);
};

const obj = { name: 'John', surname: 'Doe' };

// let { surname } = { name: 'John', surname: 'Doe' };
func(obj); // => Doe
```

------

##### Дополнительные материалы

1. [Урок из курса JS: Массивы про деструктуризацию](https://ru.hexlet.io/courses/js-arrays/lessons/destructuring/theory_unit)
2. [Урок из курса JS: Объекты про деструктуризацию](https://ru.hexlet.io/courses/js-objects/lessons/destructuring/theory_unit)

## Объекты первого класса—JS: Функции


В языках программирования существует понятие "объекты первого рода (или класса)". Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным (или константам). К таким элементам относятся любые *данные*, например числа, строки, массивы или логические значения.

```javascript
// 5 — число, объект первого рода (сохранено в константе)
const num = 5;

// 2 — число, объект первого рода (аргумент функции)
// содержимое константы num — объект первого рода (аргумент функции)
// содержимое константы result — объект первого рода (возвращаемое значение)
const result = Math.pow(num, 2);
```

Объектами первого рода может быть не только то, что мы привыкли именовать словом "данные", но и любая конструкция языка, например, функции. В JavaScript функции это объекты первого рода. Такая особенность очень серьезно влияет не только на обращение с функциями, но и на общий стиль программирования. Ниже мы поговорим об обращении с функциями как с данными.

### Сохранение в константе

```javascript
// Функция записывается в константу!
const x = () => console.log('I love Hexlet');

x(); // => 'I love Hexlet'
```

В этом коде больше действий чем мы привыкли думать:

1. Создание (определение) функции: `() => console.log('I love Hexlet')`
2. Создание константы `x` и сохранение в ней значения в виде функции: `const x =`

Этот момент нужно хорошо прочувствовать. Минимальное определение функции, которое только возможно, выглядит так: `() => {}`. Это пустая функция с пустым телом, которая не делает ничего. Присваивать её константе или нет — вопрос отдельный.

Даже сохранив функцию внутри константы, ничего не мешает передать ее в другую константу. Только не забывайте об объектной природе функции. В другую константу передается не сама функция, а ссылка на нее:

```javascript
const a = () => console.log('I love Hexlet');

a(); // => 'I love Hexlet'

const b = a;

b(); // => 'I love Hexlet'
```

Более того, любую функцию можно использовать напрямую, без сохранения в константе:

```javascript
(() => console.log('I love Hexlet'))(); // => I love Hexlet
```

В примере мы сделали вызов функции, что называется, "на лету": сначала создали `(() => console.log('I love Hexlet'))` и сразу же сделали вызов с помощью *оператора вызова функции* `()`. При этом определение функции следует обернуть в круглые скобки, чтобы обозначить границы определения для интерпретатора, которому нужно "понимать", что конкретно вы хотите вызвать. Понятно, что после такого выражения доступ к функции будет утерян, потому что она нигде не была сохранена.

Имя константы ⎯ это лишь её имя, а сама функция не имеет имени. Поэтому такие функции в программировании принято называть "анонимными". В других языках анонимные функции нередко называют лямбда-функциями. В JavaScript их иногда зовут так же.

### Создание внутри другой функции

Раз анонимная функция — выражение, мы можем определять её в любом месте программы, допускающем использование выражений, например, в теле другой функции!

```javascript
const sum = (a, b) => {
  // определили "внутреннюю" анонимную функцию и
  // сохранили в константе innerSum
  const innerSum = (x, y) => x + y;

  // вызвали внутреннюю функцию и
  // вернули результат вызова наружу из sum
  return innerSum(a, b);
};

sum(1, 4); // 5
```

Из того факта, что определение функции является обыкновенным выражением, следует, что её можно передавать в другие функции в качестве аргументов и возвращать из других функций, как значения. Подробнее поговорим об этом, когда будем изучать *функции высшего порядка*.

Использование анонимных функций значительно повышает выразительные возможности языка, и в этом вы скоро убедитесь. В JavaScript анонимные функции составляют костяк любой программы. Функции, создающие функции, возвращающие функции и принимающие функции как аргументы — основной способ разрабатывать в JavaScript.

------

##### Дополнительные материалы

1. [Документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

## Функции высшего порядка—JS: Функции


В JavaScript встроен метод [sort](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/sort), который сортирует массив. По умолчанию этот метод сортирует массив весьма замысловатым способом: приводит каждый элемент массива к строковому типу и сравнивает полученные строки на основе порядка следования кодовых точек Unicode. Подобная сортировка подходит для простых ситуаций, например для числовых значений, но перестает работать в случае более сложного сравнения, например тогда, когда каждый элемент массива — объект.

Давайте вообразим ситуацию: на вход в программу приходит список пользователей, который нужно отсортировать по возрасту и вывести на экран.

```javascript
const users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];
```

Сортировка по умолчанию не может правильно отсортировать подобный массив. Причем это касается любого вида сортировки, который мог бы нам понадобиться. Мы можем захотеть сортировать по любому параметру (или даже по набору параметров) и в любом порядке. Сортировки нужны часто, и многие из них довольно сложны.

В языках, где функции не являются данными (объектами первого рода), нам пришлось бы для каждого вида сортировки реализовывать свою собственную функцию `sort()`. Но в JavaScript есть способ лучше. Посмотрим на определение встроенного метода `sort()`:

```javascript
elements.sort([compareFunction])
```

Он принимает необязательный параметр `compareFunction()`, функцию, которая указывает как сортировать данный массив. Общая идея состоит в том, что нам не нужно реализовывать алгоритм сортировки каждый раз для каждой ситуации, ведь он не меняется. Всё, что меняется — элементы, которые сравниваются между собой в процессе сортировки. И метод `sort()` делегирует взаимодействие с этими элементами вызываемому коду:

```javascript
const users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

// Функция принимает на вход сравниваемые элементы массива
const compare = (a, b) => {
  if (a.age === b.age) {
    return 0;
  }

  return a.age > b.age ? 1 : -1;
};

users.sort(compare);

console.log(users);
// => [ { name: 'Danil', age: 1 },
//      { name: 'Vovan', age: 4 },
//      { name: 'Matvey', age: 16 },
//      { name: 'Igor', age: 19 } ]
```

https://repl.it/@hexlet/js-functions-high-order-functions-sort

Метод `sort()` выполняет всю работу по непосредственному перемещению элементов в массиве. Но то, какой элемент больше или меньше, — зависит от программиста. Достигается подобная схема за счёт той самой пользовательской функции, которая передаётся при вызове `sort()`. Эта функция принимает на вход два параметра — `sort()` отдаёт в неё два элемента, которые она сравнивает в данный момент. В нашем случае элементы — пользователи. Ваша задача — внутри этой функции посчитать, что больше или меньше, и сделать следующее: если элементы равны, то нужно вернуть `0`, если первый элемент больше второго, то считается, что они отсортированы неправильно, и возвращается `1`, иначе возвращается `-1`, а `sort()` производит их сортировку.

Из кода видно, что внутри функции сравнение идёт по свойству `age` переданных пользователей. Нетрудно догадаться, что эта функция вызывается внутри `sort()` множество раз (а именно на каждое сравнение). Как только она начнёт возвращать `-1` для каждой пары элементов — сортировка завершена.

Метод `sort()` относится к так называемым *функциям высшего порядка* (higher order functions). Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают всё сразу. Такие функции, как правило, реализуют некий обобщённый алгоритм (например, сортировку), а ключевую часть логики делегируют программисту через функцию. Главный плюс от применения таких функций — сокращение дублирования.

У функции, которая передается внутрь метода `sort()` есть свое название. Подобные функции называют колбеками (callback, обратный вызов). Колбеком становится любая функция, которая вызывается не напрямую программистом, а ее вызывает какая-то функция, в которую мы передаем наш колбек.

В примере выше необязательно создавать константу для функции. Говоря откровенно, их вообще редко записывают в константы. Типичное использование выглядит как прямая передача функции в функцию:

```javascript
users.sort((a, b) => {
  if (a.age === b.age) {
    return 0;
  }
  return a.age > b.age ? 1 : -1;
});

// То же самое, но используя функцию Math.sign
users.sort((a, b) => Math.sign(a.age - b.age));
```

Потратьте немного времени, чтобы понять, где заканчивается одна функция и начинается другая. Подобный код мы начнём использовать уже со следующего урока.

Осталось рассмотреть то, как происходит вызов внутри. С точки зрения синтаксиса ничего нового не будет.

```javascript
const say = (fn) => {
  const message = fn();
  console.log(message);
};
// или так:
// const say = (fn) => console.log(fn());

const myCallbackFn = () => 'hi!';
say(myCallbackFn); // => hi!
// или так:
// say(() => 'hi!');
```

Функция `say()` делает вызов функции, находящейся внутри параметра `fn()`. В нашем примере функция возвращает строку, которая тут же выводится на экран.

Функции высшего порядка настолько удобны в большинстве языков, что практически целиком могут заменить использование циклов. Например, канонический код на JS выглядит так:

```javascript
// Просто демонстрация
// Разбирать его не надо
users
  .filter((user) => user.age >= 16)
  .map((user) => `${user.name} is ${user.age} years old`)
  .join('\n');
// => Igor is 19 years old
//    Matvey is 16 years old
```

В этом коде присутствует 2 функции высшего порядка (`filter()` и `map()`), 2 функции — аргументы и два прохода (это делают функции высшего порядка) по списку пользователей. Код весьма выразителен и лаконичен.

В следующих уроках мы рассмотрим три самые главные функции высшего порядка, которыми можно решать практически любые задачи. Две из них используются в примере выше, это `map()` и `filter()`, а третья — `reduce()`. Они все доступны в стандартной библиотеке JavaScript.

Постепенно, используя эти функции, мы полностью уйдем от использования циклов. JavaScript - язык, в котором логика работы строится на функциях высшего порядка. К ним нужно привыкать и постепенно внедрять в свой арсенал разработчика. Начиная со следующего урока в курсах JavaScript циклы больше не используются. Посмотрите на [пример реального кода](https://github.com/hexlet-authors/hexlet-exercise-kit/blob/master/import-documentation/src/index.js) и обратите внимание на отсутствие циклов. Скоро вы научитесь писать его так же.

------

##### Дополнительные материалы

1. [Функция высшего порядка](https://ru.wikipedia.org/wiki/Функция_высшего_порядка)

## Отображение (map)—JS: Функции


Рассмотрим следующую задачу. Возьмём список пользователей и извлечём из него имена всех пользователей:

```javascript
const users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

const result = [];
for (const user of users) {
  result.push(user.name);
}

console.log(result); // => ['Igor', 'Danil', 'Vovan', 'Matvey']
```

Здесь мы видим обычную агрегацию с использованием цикла *for...of*. А что, если нам понадобится извлечь возраст? Повторяем:

```javascript
const result = [];
// Добавили деструктуризацию
for (const { age } of users) {
  result.push(age);
}

console.log(result); // => [19, 1, 4, 16]
```

В примерах выше легко увидеть закономерность. Выполняется один и тот же проход по циклу, и результат собирается в массив `result`. Единственное, что меняется — значение, которое мы извлекаем из элементов исходного массива.

Операция, которую мы выполняли в обоих ситуациях, называется **отображением** (по английски mapping). В коде мы взяли исходный массив и отобразили его в другой массив, попутно выполнив необходимые преобразования над каждым элементом. Важно, что размер получившегося массива равен размеру исходного массива.

Задача отображать данные в реальном коде встречается буквально на каждом шагу. Это настолько важная операция, что для нее создана специальная функция высшего порядка [map()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map):

```javascript
const names = users.map((user) => user.name);
console.log(names); // => ['Igor', 'Danil', 'Vovan', 'Matvey']


const ages = users.map((user) => user.age);
console.log(ages); // => [19, 1, 4, 16]

// Или что тоже самое
const callback = (user) => user.age;
console.log(users.map(callback)); // => [19, 1, 4, 16]
```

Метод `map()` принимает первым параметром функцию. Дальше, внутри себя, `map()` перебирает элементы переданной коллекции и для каждого элемента вызывает переданную функцию. На вход этой функции передаётся элемент исходного массива, а её результат записывается в новый массив, который и возвращается наружу.

Сравните решение задачи получения списка имен через цикл и с помощью метода `map()`. Последний имеет довольно много преимуществ. Во-первых, код с ним значительно короче. Во-вторых, от нас скрыта повторяющаяся логика перебора. Больше не нужно явно определять цикл и выполнять руками все те операции, которые можно не выполнять. Метод `map()` позволяет сосредоточиться на сути происходящего, скрывая ненужные детали (проход по циклу).

Типичный пример, который любят приводить в документации к функции `map()` разных языков программирования — применение некоторой арифметической операции к каждому элементу коллекции:

```javascript
const numbers = [5, 2, 3];

const newNumbers = numbers.map((number) => number ** 2);
console.log(newNumbers); // => [25, 4, 9]

const newNumbers2 = numbers.map((number) => number + 3);
console.log(newNumbers2); // => [8, 5, 6]
```

Пример выглядит искусственно, но хорошо отражает суть операции.

### Реализация

Напишем свою собственную функцию `myMap()`, работающую аналогично методу массива `map()`:

```javascript
const myMap = (collection, callback) => {
  const result = [];
  for (const item of collection) {
    // Вызов переданного колбека на каждом элементе коллекции
    const newItem = callback(item);
    // Возврат из колбека добавляется в результирующий массив
    result.push(newItem);
  }

  return result;
};

const numbers = [5, 2, 3];
const newNumbers = myMap(numbers, (number) => number ** 2);
console.log(newNumbers); // => [25, 4, 9]
```

Главное отличие кода функции `myMap()` (и метода `map()`) от ручного обхода массива заключается в том, что функция `myMap()` не знает, что нужно сделать с каждым элементом массива. Поэтому она принимает вторым аргументом функцию, которую вызывает для каждого элемента исходного массива, а результат вызова записывается в выходной массив. Чем будет этот результат — функция `myMap()` не знает, и ей этого знать не нужно. Ответственность за обработку лежит на пользователях.

------

##### Дополнительные материалы

1. [Метод map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

## Фильтрация (filter)—JS: Функции

Понятие "фильтрация" интуитивно понятно каждому человеку. Мы пьём фильтрованную воду и фильтруем то, что говорим. В программировании практически то же самое. Операция "фильтрация" по отношению к коллекции означает, что мы отбираем из неё только те элементы, которые удовлетворяют нужному условию. Типичная задача может выглядеть так — выбрать пользователей старше 10 лет:

```javascript
const users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

const result = [];
for (const user of users) {
  if (user.age > 10) {
    result.push(user);
  }
}

console.log(result);
// => [ { name: 'Igor', age: 19 }, { name: 'Matvey', age: 16 } ]
```

Фильтрация встречается так же часто, как отображение. Общая схема кода при фильтрации практически один в один как и в отображении, кроме пары ключевых моментов:

- Фильтрация возвращает коллекцию либо того же размера (если ничего не было отфильтровано), либо меньшего. Она может вернуть даже пустую коллекцию, если ни один из элементов не подошёл.
- Фильтрация всегда возвращает исходные элементы. Она никогда не делает отображение. Если на вход фильтрации поступил список пользователей, то список пользователей будет и на выходе.

Теперь посмотрим, как выглядит фильтрация при использовании метода `filter()`:

```javascript
const filteredUsers = users.filter((user) => user.age > 10);
```

Функция, передаваемая в метод `filter()`, должна быть предикатом. То есть её задача вернуть либо `true`, либо `false` для каждого элемента коллекции. Значение, которое возвращается, никак не используется — оно всего лишь говорит о том, включать ли текущий элемент в итоговый массив или нет. Новички часто делают ошибку на этом этапе и начинают возвращать из фильтра то, что они бы хотели увидеть в результирующем массиве (для этого надо применять метод `map()`).

### Реализация

Напишем свою собственную функцию `myFilter`, работающую аналогично методу массива `filter`:

```javascript
const myFilter = (collection, callback) => {
  const result = [];
  for (const item of collection) {
    // Предикат используется только для проверки
    // Внутрь callback по очереди передается каждый элемент коллекции collection
    if (callback(item)) {
      // В результат всегда добавляется элемент исходной коллекции
      result.push(item);
    }
  }

  return result;
}

const users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

const filteredUsers = myFilter(users, (user) => user.age > 10);
console.log(filteredUsers);
// [
//   { name: 'Igor', age: 19 },
//   { name: 'Matvey', age: 16 },
// ]
```

------

##### Дополнительные материалы

1. [Метод filter](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

## Агрегация (reduce)—JS: Функции

Последняя функция из нашей тройки — метод `reduce()` (говорят "свертка"), который используется для **агрегации** данных. Под агрегацией понимается операция, вычисляющая значение, зависящее от всего набора данных. К таким операциям, например, относятся нахождение среднего значения, суммы элементов, большего или меньшего. Этот подход разбирался в [курсе по массивам](https://ru.hexlet.io/courses/js-arrays/lessons/aggregation/theory_unit).

`reduce()` устроен немного сложнее, чем `map()` и `filter()`, но, в целом, сохраняет общий подход с передачей функции. Реализуем код, находящий общее количество денег у группы людей. Здесь сразу прослеживается агрегация, нам нужно свести количество денег всех пользователей к одному значению:

```javascript
const users = [
  { name: 'Igor', amount: 19 },
  { name: 'Danil', amount: 1 },
  { name: 'Vovan', amount: 4 },
  { name: 'Matvey', amount: 16 },
];

let sum = 0;
for (const user of users) {
  sum += user.amount;
}

console.log(sum); // => 40
```

Основное отличие агрегации от отображения и фильтрации в том, что результатом агрегации может быть любой тип данных — как примитивный, так и составной, например, массив. Кроме того, агрегация нередко подразумевает инициализацию начальным значением, которое принято называть аккумулятором. В примере выше она выполняется на строчке `let sum = 0`. Здесь переменная `sum` "аккумулирует" результат внутри себя.

Посмотрим ещё один пример агрегации — группировку имён пользователей по возрасту:

```javascript
const users = [
  { name: 'Petr', age: 4 },
  { name: 'Igor', age: 19 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

const usersByAge = {};
for (const { age, name } of users) {
  // Проверяем добавлено ли уже свойство age в результирующий объект или нет
  if (!Object.hasOwn(usersByAge, age)) {
    usersByAge[age] = [];
  }
  usersByAge[age].push(name);
}

console.log(usersByAge);
// => { 4: [ 'Petr', 'Vovan' ], 16: [ 'Matvey' ], 19: [ 'Igor' ] }
```

В этом примере результатом агрегации становится объект, в свойствах которого записаны массивы. Этот результат в самом начале инициируется пустым объектом, а затем постепенно, на каждой итерации, "наполняется" нужными данными. Значение, которое накапливает результат агрегации, принято называть словом "аккумулятор". В примерах выше это `sum` и `usersByAge`.

Реализуем первый пример, используя `reduce()`:

```javascript
const users = [
  { name: 'Igor', amount: 19 },
  { name: 'Danil', amount: 1 },
  { name: 'Vovan', amount: 4 },
  { name: 'Matvey', amount: 16 },
];

const sum = users.reduce((acc, user) => {
  const newAcc = acc + user.amount;
  return newAcc;
}, 0);
// const sum = users.reduce((acc, user) => acc + user.amount, 0);

// Распишем
// user: Petr, acc = 0, return value 0 + 19
// user: Danil, acc = 19, return value 19 + 1
// user: Vovan, acc = 20, return value 20 + 4
// user: Matvey, acc = 24, return value 24 + 16
console.log(sum); // => 40
```

Метод `reduce()` принимает на вход два параметра — функцию-обработчик и начальное значение аккумулятора. Этот же аккумулятор возвращается наружу в качестве результата всей операции.

Функция, передаваемая в `reduce()` — самая важная часть и ключ к пониманию работы всего механизма агрегации. Она принимает на вход два значения. Первый — текущее значение аккумулятора, второй — текущий обрабатываемый элемент. Задача функции — вернуть новое значение аккумулятора. `reduce()` никак не анализирует содержимое аккумулятора. Всё, что он делает, передаёт его в каждый новый вызов до тех пор, пока не будет обработана вся коллекция, и в конце концов вернёт его наружу. Подчеркну, что возвращать аккумулятор надо всегда, даже если он не изменился.

Второй пример с использованием `reduce()` выглядит так:

```javascript
// предварительно подготовим функцию-обработчик
const cb = (acc, user) => {
  if (!Object.hasOwn(acc, user.age)) {
    acc[user.age] = [];
  }
  acc[user.age].push(user.name);
  return acc; // обязательно вернуть!
};

// Начальное значение – пустой объект
const usersByAge = users.reduce(cb, {});
```

Код практически не изменился, за исключением того, что ушёл цикл и появился возврат аккумулятора из анонимной функции.

`reduce()` — очень мощный метод. Формально, можно работать, используя только его, так как он может заменить и отображение, и фильтрацию. Но делать так не стоит. Агрегация управляет состоянием (аккумулятором) явно. Такой код всегда сложнее и требует больше действий. Поэтому, если задачу возможно решить отображением или фильтрацией, то так и нужно делать.

### Как думать о редьюсе

Распишем алгоритм, который поможет правильно подступаться к задачам, в которых требуется редьюс. Представьте, что перед вами список курсов с уроками внутри них и вам нужно посчитать количество всех уроков. Например такое может быть нужно для вычисления длительности программы обучения. На Хекслете подобные задачи встречаются регулярно.

```javascript
// Упрощенная структура, чтобы не перегружать
// В реальности тут была бы куча дополнительных данных о курсе и об уроках
const courses = [
  {
    name: 'Arrays',
    lessons: [{ name: 'One' }, { name: 'Two' } ]
  },
  {
    name: 'Objects',
    lessons: [{ name: 'Lala' }, { name: 'One' }, { name: 'Two' } ]
  }
];
```

Здесь мы видим два курса, в которых суммарно 5 уроков. Попробуем теперь высчитать это число программно. Первый вопрос на который надо ответить, является ли данная операция агрегацией? Ответ - Да, так как мы сводим исходные данные, к какому-то вычисляемому результату. Дальше смотрим чем является результат операции. В нашем случае это число, которое вычисляется как сумма уроков в каждом курсе. Значит начальным значением аккумулятора будет 0 ([тут можно освежить](https://ru.hexlet.io/courses/js-arrays/lessons/aggregation/theory_unit)). Теперь примерный алгоритм:

1. Инициализируем накапливаемый результат нулем
2. Обходим коллекцию курсов по одному
3. Прибавляем к аккумулятору количество уроков в текущем курсе

Этот алгоритм будет идентичным в любом варианте решения, как через цикл, так и через редьюс:

```javascript
// loop
const result = 0;
for (const course of courses) {
  result += course.lessons.length;
}
console.log(result); // => 5

// reduce
const result = courses.reduce((acc, course) => acc + course.lessons.length, 0);
console.log(result); // => 5
```

### Реализация

Напишем свою собственную функцию `myReduce()`, работающую аналогично методу массива `reduce()`:

```javascript
const myReduce = (collection, callback, init) => {
  let acc = init; // инициализация аккумулятора
  for (const item of collection) {
    acc = callback(acc, item); // Заменяем старый аккумулятор новым
  }
  return acc;
};

const users = [
  { name: 'Petr', age: 4 },
  { name: 'Igor', age: 19 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

const oldest = myReduce(
  users,
  (acc, user) => (user.age > acc.age ? user : acc),
  users[0],
);
console.log(oldest); // => { name: 'Igor', age: 19 }
```

------

##### Дополнительные материалы

1. [Метод reduce](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
2. [Функция has из библиотеки Lodash](https://lodash.com/docs/#has)

## Сигналы—JS: Функции

Метод `sort()` хорошо демонстрирует важность и удобство функций высшего порядка для решения повседневных задач. Описав алгоритм один раз, мы можем получать различные варианты поведения, специфицируя их прямо по месту сортировки. То же самое относится к рассмотренным методам `map()`, `filter()` и `reduce()`.

При использовании функций высшего порядка принято разделять задачу на подзадачи и выполнять их последовательно друг за другом, выстраивая в цепочку операций. Такое решение выглядит как протаскивание данных сквозь цепочку функций-преобразователей.

В [СИКП](https://www.ozon.ru/product/struktura-i-interpretatsiya-kompyuternyh-programm-5322055/?partner=hexlet&sh=CjnOUmRR) такой подход сравнивают с тем, как происходит [обработка сигналов](https://ru.wikipedia.org/wiki/Обработка_сигналов) при проектировании электросхем. Ток, протекая по схеме, проходит через цепочку преобразователей: фильтров, подавителей шума, усилителей и так далее. Напряжение (и создаваемый им ток) в этом случае выполняет роль данных, а преобразователи – роль функций.

Такой способ работы с коллекциями в JavaScript является основным. А вот циклы практически не используются из-за гораздо меньшей гибкости, большего количества кода (легче ошибиться) и сложностях при разделении сложного алгоритма на независимые шаги.

![Обработка сигналов](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImZjZTNjNGYxNDQ3MGFlNDI2MjI4OGQ5MzRmOGZjOGI0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9d0d60b613ac611c3e7e68743b57cef57206f736a89a3561d14a51bc162e4f2c)

Предположим, что мы пишем функцию, которая принимает на вход список путей файловой системы, находит среди них файлы с расширением js без учёта регистра и возвращает имена этих файлов. Для решения этой задачи нам понадобятся следующие функции:

- [fs.existsSync(filepath)](https://nodejs.org/api/fs.html#fs_fs_existssync_path) — проверяет, существует ли файл по указанному пути
- [fs.lstatSync(filepath).isFile()](https://nodejs.org/api/fs.html#fs_stats_isfile) — проверяет, является ли объект обычным "регулярным" файлом (а не директорией, ссылкой или другим типом файлов)
- [path.extname(filepath)](https://nodejs.org/api/path.html#path_path_extname_path) — извлекает "расширение" из имени файла
- [path.basename(filepath)](https://nodejs.org/api/path.html#path_path_basename_path_ext) — извлекает имя файла из полного пути

```javascript
const getJSFileNames = (paths) => {
  const result = [];
  // Подход противоположный потоковой обработке.
  // Здесь всё выполняется сразу в куче без разделения по шагам.
  for (const filepath of paths) {
    // Извлекаем расширение
    const extension = path.extname(filepath).toLowerCase();
    // Если путь существует, это файл и у него расширение .js
    if (fs.existsSync(filepath) && fs.lstatSync(filepath).isFile() && extension === '.js') {
      // Нормализуем путь и добавляем в результирующий список
      result.push(path.basename(filepath.toLowerCase(), extension));
    }
  }

  return result;
};

const names = getJSFileNames(['index.js', 'wop.JS', 'nonexists', 'node_modules']);
console.log(names); // => [index, wop]
```

В примере выше типовое решение с использованием цикла. Его алгоритм можно описать так:

1. Просматриваем каждый путь
2. Если текущий путь — обычный файл с расширением *.js* (без учёта регистра), то добавляем в результирующий массив

Если попытаться то же самое реализовать, используя метод `reduce()`, то на выходе получится код, идентичный решению на циклах. Но если хорошо подумать, то можно увидеть, что эта задача распадается на две: фильтрацию и отображение.

```javascript
const getJsFileNames = (paths) => paths
   // отбираем реально существующие файлы
  .filter((filepath) => fs.existsSync(filepath))
   // отбор по типу файла
  .filter((filepath) => fs.lstatSync(filepath).isFile())
   // отбор по расширению
  .filter((filepath) => path.extname(filepath).toLowerCase() === '.js')
   // отображаем в имена (нам нужен массив с именами)
  .map((filepath) => path.basename(filepath.toLowerCase(), '.js'));

const names = getJsFileNames(['index.js', 'wop.JS', 'nonexists', 'node_modules']);
console.log(names); // => [index, wop]
```

Код получился чуть короче (без учёта комментариев), и выразительнее, но главное не его размер. С увеличением количества операций и их сложности, код, разбитый таким образом, читается и анализируется значительно проще, так как каждая операция выполняется независимо для всего набора сразу. В голове приходится держать меньше деталей и можно сразу увидеть то, как операция влияет на все данные. Однако, научиться правильно разбивать задачу на подзадачи не так просто, как может показаться вначале. Нужна некоторая практика и сноровка перед тем, как ваш код станет удобоварим.

Заметьте, что здесь фильтрация разбита на три шага, а не выполнена в одном. Учитывая лаконичность определения функции в js, гораздо лучше разбивать проверки на большее число фильтров, чем делать один сложный фильтр.

![Standard Interfaces](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjNiODE4ZTU5ZWU2NGI4Y2M0OWNlMzQ3NjljYmViYmE1LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=84f1ab8602e2c9e39748c31becb2f71c35e6eb9a27c81358ec8a336252ba297b)

Сама возможность такого разбиения основывается на простой идее, которую иногда называют "стандартные интерфейсы". Заключается она в том, что на входе и выходе из функций ожидается один и тот же тип данных, в нашем случае, массив. Это позволяет соединять функции и строить цепочки, выполняющие большое количество разных задач, без необходимости реализовывать новые функции. Рассмотренные ранее операции — отображение, фильтрация и агрегация — комбинируясь друг с другом, позволяют решать подавляющее число задач по обработке коллекций. С чем-то подобным мы все встречались в своей жизни, когда собирали конструкторы Lego. Небольшое число примитивных деталей за счёт одинаковых соединений позволяет строить конструкции практически неограниченной сложности.

Кстати, подобные цепочки нередко заканчиваются на агрегации, так как агрегация почти всегда выполняется в конце и сводит коллекцию к некоторому значению.

### Производительность

За кадром остался вопрос производительности. Возможно, кто-то из вас догадался, что на каждый вызов функции, обрабатывающей коллекцию, мы получаем проход по всему списку. Чем больше таких функций, тем больше проходов. Казалось бы, код замедляется, зачем так делать? На практике дополнительные проходы практически никогда не проблема (см. ссылку "Продуманная оптимизация"). Задачи, в которых требуется одномоментная обработка десятков и сотен тысяч элементов, встречаются крайне редко. Большая часть операций происходит со списками до тысяч элементов. А для такого списка одним проходом больше одним меньше — разницы, можно сказать, никакой.

Но это не вся правда. На самом деле, существуют специальные коллекции, которые в момент вызова функций фильтрации, отображения и т.п. не выполняют операции сразу. Они накапливают необходимые действия, а во время первого использования выполняют сразу все одним проходом. Это так называемые "ленивые коллекции".

------

##### Дополнительные материалы

1. [Обработка сигналов](https://ru.wikipedia.org/wiki/Обработка_сигналов)
2. [Продуманная оптимизация](http://optimization.guide/)

## Парадигмы программирования—JS: Функции

В программировании часто используется термин "парадигма".

> Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером. (Wikipedia)

Парадигма — это больше, чем просто другой алгоритм решения задачи. Как правило, структура кода при использовании разных парадигм отличается очень значительно и требует знаний, выходящих за рамки только синтаксиса языка (например, автоматное программирование требует хотя бы базового понимания теории автоматов). Причём подавляющее большинство современных (и не очень) языков программирования являются мультипарадигменными и позволяют писать код, используя множество стилей. Иногда эти стили взаимоисключающие, иногда они дополняют друг друга. К текущему моменту мы писали код, используя две парадигмы: императивную и декларативную.

![Paradigms](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjgwMjgwZTIwM2JiYWZkNDg4MzlmNmI2ZGRjOWQxMjJmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f580c01ce890b4d5194ccf1228423796acf5fe91ec8baddea236cca631d6b772)

### Императивная парадигма

Императивная парадигма — стиль написания кода в виде набора последовательных инструкций (команд) с активным использованием переменных. Возможно, данное определение звучит страшно, но на практике императивный стиль является доминирующим. Не считая этого курса, весь остальной код мы писали именно в императивном стиле.

```javascript
// Поиск максимального числа
const numbers = [10, 20, 52, 105, 56, 89, 96];

let max = numbers[0];
for (const number of numbers) {
  if (number > max) {
    max = number;
  }
}

console.log(max); // => 105
```

В императивном стиле широко используется присваивание (а значит, и переменные) и циклы. Эта парадигма популярна потому, что она в точности соответствует тому, как работает компьютер: последовательно выполняет инструкции и использует память для хранения промежуточных результатов. Обычно говорят, что императивная программа отвечает на вопрос *КАК* («как достичь нужного результата»).

JavaScript, впрочем, как и Java/Ruby/Python/C#/Perl/PHP/Go, относится к императивным языкам. То есть языкам, в которых доминирующей является императивная парадигма (язык толкает к её использованию). Что, однако, не мешает использовать и другие парадигмы в рамках этих языков.

### Декларативная парадигма

Императивному стилю противопоставляют декларативный, который нередко называют функциональным. Ключевое отличие функционального стиля от императивного в том, что при таком стиле программа выглядит как спецификация (которая может быть очень сложной), а не как набор инструкций. То есть программа отвечает на вопрос *ЧТО* («что мы хотим получить»). Эту грань довольно трудно уловить сразу, но, например, вся математика, по своей сути, декларативна.

```javascript
// Поиск максимального числа
const numbers = [10, 20, 52, 105, 56, 89, 96];

const max = numbers.reduce(
  (acc, number) => number > acc ? number : acc,
  numbers[0],
);

console.log(max); // => 105
```

Главное отличие декларативной парадигмы от императивной на практике — отсутствие присваивания. Вы можете мне возразить, что в коде выше определяются константы и в них сохраняются значения. Присмотритесь к коду внимательнее, вы заметите что константы создаются ровно один раз, инициализируются первоначальными значениями, которые больше не меняются (в этом смысл констант). Конструкцию, типа `const myVar = expression`, можно рассматривать как логическое высказывание. В математике это звучало бы так: "допустим, A — это множество чисел". Что бы мы дальше ни делали, "A" остаётся всегда тем же, чем было во время определения.

*Дело в том, что в математике доказательства строятся с помощью логических цепочек. Из одних утверждений следуют другие, и таким образом мы можем прийти к решению задачи. Всё это возможно только в том случае, когда утверждения не изменяются. Иначе, следствия могут оказаться неверными уже после того, как они были получены, а значит мы не сможем рассуждать логически.*

То же самое касается и `acc` с `number`. Эти параметры всегда определяются ровно один раз, так как каждый вызов функции при таком определении (без использования ссылок) не зависит от другого вызова. В мире функциональных языков такую операцию называют **связывание**. Визуально оно выглядит как присваивание, но это не оно. Попытка связать уже связанный идентификатор (в функциональных языках нет переменных) завершится ошибкой. Ниже пример на языке Erlang:

```erlang
1> A = 4.
4
2> A = 'hey'.
** exception error: no match of right hand side value hey
```

Отсутствие присваивания автоматически означает то, что в функциональной парадигме невозможно использование циклов. Вместо них используется рекурсия. Другой важной особенностью функционального стиля считается активное использование функций как объектов первого рода. В основном в функциях высшего порядка. Причём они способны заменить рекурсию в подавляющем большинстве задач, в чем мы уже убедились в предыдущих уроках (убедились так, что даже не рассматривали рекурсию). Любая задача из представленных решалась основной тройкой функций высшего порядка.

Языков, использующих декларативную парадигму, довольно много. Они, в своей массе, менее популярны, чем императивные, но прочно занимают определённые ниши и активно используются в промышленном программировании. К таким языкам относятся: Haskell/Erlang/Elixir/OCaml/F#. В этих языках нет присваивания и циклов. Императивный код на них написать просто невозможно. Немного особняком стоят такие языки, как Scala и Clojure (и другие из семейства LISP). В этих языках основная парадигма — декларативная, и язык толкает к тому, чтобы писать в таком стиле, но при необходимости на них можно написать самый настоящий императивный код с присваиванием и циклами. А вот почти все императивные языки позволяют писать декларативно. Причём, если одни языки имеют довольно слабую поддержку декларативной парадигмы, то другие настолько мощную, что в них можно писать только декларативно (если хочется). К последним относится и современный JavaScript.

### Другие парадигмы

Большинство других парадигм являются разновидностями функциональной или императивной парадигм. Из наиболее значимых я бы выделил следующие:

- Логическое программирование
- Автоматное программирование
- Объектно-ориентированное программирование
- Метапрограммирование

------

##### Дополнительные материалы

1. [Парадигмы](https://ru.wikipedia.org/wiki/Парадигма_программирования)
2. [Ссылочная (референциальная) прозрачность](https://ru.wikipedia.org/wiki/Ссылочная_прозрачность)

## Абстракция с помощью функций—JS: Функции

Главная причина создания функций — повышение уровня абстракции, а не сокращение дублирования кода. Второе является следствием первого. И действительно, вместо того, чтобы реализовывать сортировку самостоятельно в каждом месте, где это требуется, можно воспользоваться функцией `sort()`, которая прячет реализацию внутри себя и позволяет программисту не отвлекаться на ненужные детали (вид сортировки, код для её выполнения).

![Абстракция с помощью функций](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjZkZGE4MTNhNGI2OTQ2Nzk0ODNiMzZhZmU3Mzg0NDFiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=7576ffedac0e2435cce3261c0f8db01f8dfdaa18b3b99b18816a981ceaf885d6)

В этом заключается суть абстракции, мы игнорируем несущественные стороны, свойства и связи рассматриваемого объекта или процесса, что позволяет представить сложную концепцию в более простой форме. Умение абстрагировать — одно из важнейших свойств нашего мозга. Маленькие дети очень быстро учатся классифицировать предметы нашего мира. Без особого труда понимая, что дерево это дерево, даже если конкретную породу дерева они видят впервые. А два разведённых пальца обозначают зайчика (потому что уши).

Несмотря на это, понимание, как грамотно строить абстракции (в нашем случае выделять функции), не появляется само по себе. Оно приходит с опытом, при условии, что есть другой человек сильнее вас, который может вам указать на допущенные ошибки, и вы сами отслеживаете проблемы вашей абстракции в процессе эксплуатации (рефлексируете). С другой стороны, излишнее абстрагирование скорее вредно, чем полезно. За нагромождением новых сущностей можно потерять суть и тратить больше времени на понимание происходящего. Построение абстракции — всегда компромисс. Слишком низкий уровень абстракции приводит к дублированию кода, слишком высокий — может быть очень трудным для понимания (Попробуйте понять [Теорию Категорий](https://ru.wikipedia.org/wiki/Теория_категорий)) и усложняющим решение простых задач.

![Huge Java Call Stack](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjllNzA1NTgxZDNlYzkwZTUyOTViNTA4OWFlNmEzZWE4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=6af8c0445d6bcf93756ac69f75fb3cbc6c5359635d8019bc24c011475290d88e)

Функции высшего порядка выводят абстрагирование с помощью функций на новый уровень. Благодаря делегированию поведения внешнему коду (используя анонимные функции), резко расширяется возможность повторного использования кода (алгоритма) в разных ситуациях. И вместо десяти функций для десяти разных участков кода появляется одна функция, которая специфицируется 10 раз разным поведением.

Но не забывайте, что [абстракции почти всегда текут](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/).

### Пример дырявой абстракции

В первом проекте Хекслета наши ученики совершают одну (совершают много, но сейчас нас интересует одна) ошибку, связанную с неверным выделением абстракций. Если отбросить детали (абстрагироваться!), то задача сводится к написанию функции, которая принимает на вход число, и должна напечатать на экран *yes*, если оно чётное, и *no* в обратном случае.

Первое решение выглядит примерно так:

```javascript
const check = (number) => {
  const result = number % 2 === 0 ? 'yes' : 'no';
  console.log(result);
};
```

Оно рабочее, но сама концепция чётности не выделена в свою абстракцию, что, например, затрудняет тестирование и понимание кода. Здесь он простой, но в более сложных случаях догадаться, что за операция выполняется — проблематично. Правильно было бы выделить чётность в отдельную функцию (абстракцию).

```javascript
const isEven = (number) => (number % 2 === 0) ? 'yes' : 'no';

const check = (number) => {
  const result = isEven(number);
  console.log(result);
};
```

Посмотрите на код выше внимательно. Всё ли с ним нормально?

На самом деле, этот код даже хуже, чем первая версия, потому что создана неверная абстракция. Понятие чётности числа никак не связано ни с выводом на экран, ни со строчками *yes* или *no*. Оно существует в вакууме как математическая концепция и не может знать о том, как её собираются использовать. Не говоря уже про то, что имя `isEven()` начинается с *is*, а это значит, что функция — предикат. Такие функции могут возвращать только логическое значение и никак иначе (исключений не существует!). Правильный вариант выглядит так:

```javascript
const isEven = (number) => (number % 2 === 0);
const check = (number) => {
  const result = isEven(number) ? 'yes' : 'no';
  console.log(result);
};
```

И это самый примитивный вариант создания абстракций. В реальном коде обычно всё значительно сложнее. Отработка построения правильных абстракций ведется в проектах Хекслета.

------

##### Дополнительные материалы

1. [Ментальное программирование 2](https://www.youtube.com/watch?v=vkUTX1hruF8)

## Дополнительные материалы

### [JS: Функции](https://ru.hexlet.io/courses/js-functions)

1. [О курсе](https://ru.hexlet.io/courses/js-functions/lessons/about/theory_unit)
   - Без материалов
2. [Чистые функции](https://ru.hexlet.io/courses/js-functions/lessons/pure-functions/theory_unit)
   - [Побочные эффекты](https://ru.wikipedia.org/wiki/Побочный_эффект_(программирование))
   - [Детерминированная функция](https://ru.wikipedia.org/wiki/Чистота_функции#Детерминированность_функции)
3. [Разделение команд и запросов](https://ru.hexlet.io/courses/js-functions/lessons/command-query-separation/theory_unit)
   - [Command-query Separation](https://ru.wikipedia.org/wiki/CQRS)
   - [Принцип наименьшего удивления](https://ru.wikipedia.org/wiki/Правило_наименьшего_удивления)
4. [Оператор Rest (упаковка аргументов)](https://ru.hexlet.io/courses/js-functions/lessons/rest-operator/theory_unit)
   - Без материалов
5. [Оператор Spread (распаковка аргументов)](https://ru.hexlet.io/courses/js-functions/lessons/spread-operator/theory_unit)
   - Без материалов
6. [Деструктуризация параметров](https://ru.hexlet.io/courses/js-functions/lessons/params-destructuring/theory_unit)
   - [Урок из курса JS: Массивы про деструктуризацию](https://ru.hexlet.io/courses/js-arrays/lessons/destructuring/theory_unit)
   - [Урок из курса JS: Объекты про деструктуризацию](https://ru.hexlet.io/courses/js-objects/lessons/destructuring/theory_unit)
7. [Объекты первого класса](https://ru.hexlet.io/courses/js-functions/lessons/first-class-citizen/theory_unit)
   - [Документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
8. [Функции высшего порядка](https://ru.hexlet.io/courses/js-functions/lessons/high-order-functions/theory_unit)
   - [Функция высшего порядка](https://ru.wikipedia.org/wiki/Функция_высшего_порядка)
9. [Отображение (map)](https://ru.hexlet.io/courses/js-functions/lessons/map/theory_unit)
   - [Метод map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
10. [Фильтрация (filter)](https://ru.hexlet.io/courses/js-functions/lessons/filter/theory_unit)
    - [Метод filter](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
11. [Агрегация (reduce)](https://ru.hexlet.io/courses/js-functions/lessons/reduce/theory_unit)
    - [Метод reduce](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
    - [Функция has из библиотеки Lodash](https://lodash.com/docs/#has)
12. [Сигналы](https://ru.hexlet.io/courses/js-functions/lessons/signals/theory_unit)
    - [Обработка сигналов](https://ru.wikipedia.org/wiki/Обработка_сигналов)
    - [Продуманная оптимизация](http://optimization.guide/)
13. [Парадигмы программирования](https://ru.hexlet.io/courses/js-functions/lessons/paradigms/theory_unit)
    - [Парадигмы](https://ru.wikipedia.org/wiki/Парадигма_программирования)
    - [Ссылочная (референциальная) прозрачность](https://ru.wikipedia.org/wiki/Ссылочная_прозрачность)
14. [Абстракция с помощью функций](https://ru.hexlet.io/courses/js-functions/lessons/abstraction/theory_unit)
    - [Ментальное программирование 2](https://www.youtube.com/watch?v=vkUTX1hruF8)