## Введение—JS: Асинхронное программирование

JavaScript – язык, созданный для выполнения на клиентской стороне. Это сильно повлияло не только на устройство самого языка, но и на то, как устроены его среды исполнения: браузеры, Node.js и другие. Браузер заточен под так называемую **событийную модель**, когда код не исполняется непрерывно, а ожидает пользовательских событий: нажатий на кнопки, кликов мышкой или скроллинга. Каждое из этих (и десятка других) событий запускает нужный обработчик, причём к нему предъявляются особые требования: он не должен блокировать работу, так как на одно событие может выполняться много задач (практически параллельно), и при этом пользователь должен иметь возможность продолжать взаимодействовать с интерфейсом.

По этим причинам все движки (исполнители js-кода) построены по асинхронной модели. Любые операции ввода/вывода (например, выполнение Ajax-запросов) выполняются асинхронно. Асинхронный код устроен совершенно отлично от синхронного и требует времени на привыкание. У него другой способ обработки ошибок и, в целом, другие подходы при написании кода. Добавляя одни возможности, он создаёт проблемы в других местах: то, что легко делалось в синхронном коде, становится сложным в асинхронном. Это цена за производительность.

Асинхронное программирование в JavaScript прошло несколько стадий: от **колбеков**, через **промисы** и до концепции **async/await**. Все эти подходы по-своему важны и рассматриваются в данном курсе. В конце вы узнаете и научитесь писать современный, эффективный и понятный код, обладающий преимуществами асинхронного кода и почти не уступающий синхронному в понятности и простоте.

Основные темы данного курса:

- Асинхронное IO
- Обработка ошибок
- Event Loop
- Таймеры
- Промисы
- Async/Await
- EventEmitter

## Стек вызовов (Call Stack)—JS: Асинхронное программирование

Перед тем, как погружаться в асинхронное программирование, разберём один важный момент, связанный с исполнением кода. Посмотрите на пример:

```javascript
const data = [16, 64, 4];
const data2 = data.map(Math.sqrt); // [4, 8, 2]
const predicate = (v) => v > 2;
const data3 = data2.filter(predicate); // [4, 8]
```

Каждая строчка в коде выше выполняется только тогда, когда выполнится предыдущая. В программировании, такое последовательное исполнение кода (инструкций) называют синхронным. Причём выполнение каждой конкретной строчки, может быть сколь угодно сложным.

Если посмотреть на вторую строку, то видно, что вызывается метод `map()`, который внутри себя вызывает функцию `Math.sqrt()`. В реальных приложениях глубина проваливания внутрь функций может быть просто огромной, на сотни уровней. Во время выполнения кода, такое проваливание создает **стек вызовов** (call stack). Почему именно стек? Потому что так происходит процесс исполнения кода. Каждый внутренний вызов добавляет текущую функцию внутрь стека — и так до самой глубокой функции. Затем, когда происходит возврат, начинается раскрутка стека — из него по очереди (в обратном порядке) извлекаются функции и продолжают своё выполнение с того места, где внутренняя функция вернула результат.

![Стек вызовов функций](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImNkODM4ZDIwZjcxZGI1YmJjM2U2NDRiZGQ4YjFlNGE1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=83e559007ebe39e156e7d945f15264e8710e5da68b45e5cabed67c09c9b1da8e)

Предположим что у нас есть цепочка функций _one() вызывает two() вызывает three(), который вызывает four()_:

```javascript
const four = () => console.log("END!");
const three = () => four();
const two = () => three();
const one = () => two();

one(); // Запускаем
```

Тогда процесс исполнения кода будет выглядеть так:

```
one
=> two
   => three
      => four
   => three
=> two
one
```

То есть сначала идет погружение до самого вложенного вызова, затем подъем до первой функции в стеке вызовов.

Мы, как разработчики, видим стек вызовов каждый день в выводе ошибок. **Backtrace** (обратная трассировка) — не что иное, как стек вызовов, записанный в обратном порядке. Для демонстрации я допустил ошибку в третьей строке нашего кода:

```javascript
const data = [16, 64, 4];
const data2 = data.map(Math.sqrt); // [4, 8, 2]
const predicate = (v) => unknown > 2;
const data3 = data2.filter(predicate); // ReferenceError
```

Запуск (код расположен в файле _index.js_) и вывод:

```javascript
node index.js

index.js:3
const predicate = (v) => unknown > 2;
                               ^

ReferenceError: unknown is not defined
    at predicate (index.js:3:32)
    at Array.filter (<anonymous>)
    at Object.<anonymous> (index.js:4:21)
```

Важно понимать, что стек вызовов растёт только тогда, когда вызовы идут _в глубину_. Это видно по выводу: в бектрейсе не фигурирует первая и вторая строчки, в нём описана последовательность, начиная от вызова фильтра и дальше.

Механизм исключений в js, как и в других языках, полностью опирается на наличие стека вызовов. Более того, он создан, чтобы было удобно "раскручивать" этот стек. Любое возникающее исключение поднимается вверх по стеку вызовов, до тех пор пока не наткнется на конструкцию _try/catch_ либо до тех пор пока стек вызовов не закончится.

```javascript
const data = [16, 64, 4];
const data2 = data.map(Math.sqrt); // [4, 8, 2]
const predicate = (v) => unknown > 2;

try {
  const data3 = data2.filter(predicate); // ReferenceError
} catch (e) {
  console.log("Catch it");
  console.log(e.stack);
}
```

И хотя объявление функции `predicate()`, содержащей ошибку, находится вне блока try/catch, он всё равно поймает ошибку внутри этой функции, так как `predicate()` вызывается _внутри_ по цепочке.

```javascript
node index.js

Catch it
ReferenceError: unknown is not defined
    at predicate (index.js:3:32)
    at Array.filter (<anonymous>)
```

Существуют специальные инструменты, которые позволяют визуализировать стек вызовов. Обычно их используют во время _профайлинга_ — процесса поиска узких мест для ускорения приложения.

![Анализ стека вызовов](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImY2YzdmNzEwZTIzNjhmNzY4ZDAwOWVjYjMwNjEzNzdhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=19515d8344413309221b38943afad3a0f3600a815dfdb0351f92556bb61a71f4)

Но всё меняется, когда речь идёт об асинхронном коде. Подробнее в следующем уроке.

---

##### Дополнительные материалы

1. [Стек](https://ru.wikipedia.org/wiki/Стек)
2. [Стек вызовов](https://ru.wikipedia.org/wiki/Стек_вызовов)

## Асинхронный код—JS: Асинхронное программирование

_Примеры в этом уроке даются на основе работы с файловой системой, потому что именно они лучше всего раскрывают суть асинхронного программирования. Принципы работы асинхронного кода абсолютно идентичны и для фронтенда, и для бекенда._

В синхронном коде выполнение функций происходит в том же месте, где они были вызваны, и в тот момент, когда происходит вызов. В асинхронном коде всё по-другому. Вызов функции не означает, что она отработает прямо здесь и сейчас. Более того, мы не знаем, когда она отработает. Разберём пример с копированием файла через чтение и повторную запись в другой файл:

```javascript
import fs from "fs";

// Обязательно передавать вторым параметром `utf-8`,
// только тогда данные возвратятся в строковом представлении
const content = fs.readFileSync("./myfile", "utf-8");
fs.writeFileSync("./myfile-copy", content);
```

Пример кода написан для Node.js: здесь используется модуль `fs` и его синхронные функции для чтения и записи файла (их особенность в том, что имена оканчиваются на `Sync`). Такой код работает как ожидается: сначала читается содержимое файла в константу `content`, затем оно же записывается в другой файл. Каждая строчка приводит к блокировке, то есть выполнение программы ждёт, пока операционная система прочитает файл (а это делает именно она) и отдаст его содержимое программе, и только затем выполняется следующая строчка. Соответственно, там, где происходит запись, программа ожидает, пока операционная система запишет файл на диск (это не совсем правда, но данная тема выходит за рамки урока, подробнее в книгах по операционным системам), и только затем продолжает работу.

![Синхронный ввод/вывод](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjhjOGQzYjVkZGFmOTFkMmM4NDY2OTU3Y2YzNjk0NTg0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=58bfd994ef20a1a7ce8a58c8b6b56c77dad9b79c997db69bd00da021e7beea6e)

В принципе, здесь можно было бы и остановиться — зачем что-то делать с этим кодом? Дело в том, что любые файловые операции занимают много времени (они в тысячи раз медленнее, чем вызов обычной функции). В течение этого времени процесс ожидает ответ от ядра о результате операции, не делая ничего другого. Поэтому синхронный подход в случае файловых операций очень неэффективно утилизирует ресурсы. Асинхронный же код продолжает выполняться во время любых файловых операций. Другими словами, код никогда не блокируется на IO операциях, но может узнать об их завершении. Правильно написанные асинхронные программы (в тех ситуациях, где это нужно) значительно эффективнее синхронных. Иногда это настолько критично, что синхронная версия просто не справится с задачей.

_Небольшая ремарка. IO — это ввод/вывод. К нему относится не только работа с файлами, но и любое сетевое взаимодействие (которое, в конечном итоге, сводится к работе с файлами). Даже печать на экран — это тоже запись в файл._

Теперь попробуем прийти к асинхронному коду через понимание принципов его работы. Представим, что функция `readFile` в примере ниже асинхронная. Это значит, что она читает файл не прямо в том месте, где её вызвали, а где-то в другом месте на фоне:

```javascript
import fs from "fs";

// пустая функция, чуть позже разберём её смысл,
// но асинхронная версия readFile требует передачи функции третьим параметром
const noop = () => {};
const content = fs.readFile("./myfile", "utf-8", noop);
console.log(content);
```

Возможно ли появление такого асинхронного кода? Ответ сразу — нет. Неважно, какую конкретно задачу выполняет эта функция, важно лишь одно — она не выполняет её сразу, а значит у неё невозможен возврат результата выполнения асинхронной операции. Если запустить подобный код, то мы увидим такой вывод:

```
node index.js
undefined
```

Это фундаментальная особенность асинхронных функций, которую нужно запомнить раз и навсегда. Приходится подчёркивать этот момент, потому что новички постоянно спотыкаются на нём, пытаясь работать с асинхронными функциями как с синхронными.

Тогда возникает вопрос: как получить результат выполнения этой функции? А вот для этого используется ещё одна функция, которая передаётся в асинхронную. В этом качестве она называется функцией обратного вызова или просто **колбек** (callback). Эта функция будет вызвана в тот момент, когда операция закончится (возможно, с ошибкой). Она имеет следующую сигнатуру: `callback(error, result)`. Первым параметром в неё передаётся ошибка, если всё было плохо, вторым — результат операции, если всё было хорошо. Про ошибки мы поговорим чуть позже, а сейчас разберём общие принципы работы.

```javascript
import fs from "fs";

// Вызовется тогда, когда выполнится асинхронная операция
const callback = (_error, data) => console.log(data);
// префиксом нижнего подчёркивания обозначается неиспользуемый аргумент

// readFile запускает на выполнение задачу чтения файла.
// Вторым параметром обязательно передать utf-8. Только в этом случае данные прочитаются в строковом виде.
fs.readFile("./myfile", "utf-8", callback);
```

Запуск и вывод:

```javascript
node index.js
content of file
```

Как только операция чтения файла завершилась, интерпретатор Node.js внутри себя вызвал колбек, передав ему параметром содержимое файла. Осталось убедиться в том, что этот код действительно асинхронный:

```javascript
import fs from "fs";

const callback = (_error, data) => console.log(data);
console.log("before read");
// вызов функции не дожидается конца чтения файла, код сразу продолжит выполняться дальше
fs.readFile("./myfile", "utf-8", callback);
console.log("after read?");
```

Запуск и вывод:

```javascript
node index.js

before read
after read?
content of file
```

Несмотря на то, что _after read?_ выводится последней инструкцией, реальный вывод отличается от порядка инструкций в коде. Асинхронная функция хоть и запустилась на выполнение сразу, но _колбек вызывается только в тот момент, когда в текущем стеке вызовов не останется ни одной функции_. В нашем случае это означает, что колбек запускается только после того, как отработает весь файл. И этот запуск породит свой собственный стек вызовов.

В асинхронном коде каждый колбек асинхронной функции порождает свой собственный стек вызовов, который, в свою очередь, может выполнять новые асинхронные вызовы и так далее до бесконечности.

Node.js дожидается завершения всех асинхронных вызовов, которые были сделаны в процессе работы программы:

```javascript
import fs from "fs";

fs.readFile("./myfile", "utf-8", (_error, data) => console.log("First!"));
fs.readFile("./myfile", "utf-8", (_error, data) => console.log("Second!"));
```

В примере выше мы видим запуск двух асинхронных операций. Теперь мы знаем, что второе чтение файла запустится практически одновременно с первым, так как операции асинхронные и их выполнение не блокирует поток выполнения программы. Попробуйте ответить на вопрос, в каком порядке появится результат?

Запуск и вывод:

```
node index.js

Second!
First!

node index.js

First!
Second!
```

Как видите, на этот вопрос нельзя дать однозначный ответ. Асинхронные операции могут выполниться в любом порядке, если они запускаются одновременно. И единственный способ упорядочить их — делать последовательный запуск, и об этом мы поговорим далее.

Асинхронное программирование значительно сложнее синхронного. Видеть линейный код (последовательно записанный) и думать о нём нелинейно — очень тяжело. Дальше вы увидите, что с ростом числа асинхронных функций в рамках одной программы сложность увеличивается экспоненциально, и в какой-то момент перестаёшь понимать, что происходит. Для борьбы с ней придумано множество выходов, некоторые из которых оказались очень удачными и рассматриваются в более поздних уроках курса.

---

##### Дополнительные материалы

1. [синхронная функция readFileSync из модуля fs](https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options)
2. [асинхронная функция readFile из модуля fs](https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback)

## Возврат в асинхронном коде—JS: Асинхронное программирование

Остановимся чуть подробнее на возврате значений из асинхронных функций. В прошлом уроке мы выяснили, что асинхронные функции никогда не возвращают результат асинхронной операции:

```javascript
import fs from "fs";

const noop = () => {};
const content = fs.readFile("./myfile", "utf-8", noop);
console.log(content); // undefined
```

И единственный способ получить результат — описать логику в колбеке. Тогда возникает вопрос: а что, если сделать `return` внутри колбека? К чему это приведёт?

```javascript
import fs from "fs";

const content = fs.readFile("./myfile", "utf-8", (_error, data) => {
  // что-нибудь делаем
  return data;
});
console.log(content); // undefined
```

В результате ничего не меняется, так как этот возврат никем не используется. Это не означает, что сама инструкция `return` бесполезна в асинхронном коде. Напротив, она часто бывает полезна, но лишь как способ прервать выполнение кода, а не вернуть результат.

```javascript
import fs from "fs";

const content = fs.readFile("./myfile", "utf-8", (_error, data) => {
  if (data === "") {
    return;
  }
  // делаем что-нибудь с данными
});
console.log(content); // undefined
```

Этот паттерн называется [guard expression](https://ru.hexlet.io/courses/js-functions-hard-way/lessons/guard-expression/theory_unit).

Всё то же самое распространяется и на асинхронные функции, которые мы пишем сами. Асинхронной является любая функция, внутри которой есть хоть одна асинхронная операция. Без исключения. Даже если помимо асинхронной операции, она выполняет и синхронные, например, производит манипуляции с текстом. В свою очередь, каждая асинхронная функция обязана принимать на вход колбек, так как это единственный способ упорядочивать события и отслеживать завершение.

Напишем асинхронную функцию-обёртку для чтения файла, которая, кроме самого чтения, выполняет небольшую чистку, удаляя начальные и концевые пробелы из содержимого. Сразу вспоминаем, что, раз наша функция асинхронная, то она обязана принимать на вход функцию-колбек, которая будет вызвана по окончании операции. Эта функция должна иметь общепринятую сигнатуру, то есть принимать первым параметром ошибку и вторым — сами данные. Возврата данных через `return` в нашей асинхронной функции быть не может.

```javascript
import fs from "fs";

const readFileWithTrim = (filepath, cb) => {
  fs.readFile(filepath, "utf-8", (_error, data) => {
    cb(null, data.trim());
  });
};

readFileWithTrim("./myfile", (_error, data) => console.log(data));
```

Этот процесс рекурсивен по своей природе, любая функция, которая внутри работает с асинхронной функцией, становится асинхронной и начинает принимать на вход колбек. Почему так происходит? Почему нельзя просто выполнить асинхронную операцию внутри, никак не сообщая об этом наружу? Дело в том, что в такой ситуации вы не можете ни воспользоваться результатом работы асинхронной функции (ведь данные приходят в колбек в другом стеке вызовов), ни узнать о том, закончилась ли операция вообще и закончилась ли она успешно. Всё это рассмотрим в следующих уроках.

## Упорядочивание асинхронных операций—JS: Асинхронное программирование

Асинхронное программирование помогает эффективно использовать вычислительные ресурсы. Но создаёт сложности там, где изначально было просто. В первую очередь это касается **порядка выполнения** (flow). Предположим, что перед нами стоит задача прочитать содержимое двух файлов и записать в третий (объединение файлов).

```javascript
import fs from "fs";

fs.readFile("./first", "utf-8", "?");
fs.readFile("./second", "utf-8", "?");
fs.writeFile("./new-file", content, "?");
```

Вся задача сводится к последовательному выполнению трёх операций, так как записать новый файл мы можем лишь тогда, когда прочитаем данные первых двух. Упорядочить подобный код можно лишь одним способом: каждая последующая операция должна запускаться внутри колбека предыдущей. Тогда мы построим нужную цепочку вызовов:

```javascript
import fs from "fs";

fs.readFile("./first", "utf-8", (_error1, data1) => {
  fs.readFile("./second", "utf-8", (_error2, data2) => {
    fs.writeFile("./new-file", `${data1}${data2}`, (_error3) => {
      console.log("File has been written");
    });
  });
});
```

В реальных программах количество операций может быть значительно больше: например, десятки — и тогда у вас получится лесенка из 10-ти вложенных вызовов. Подобное свойство асинхронного кода нередко называют _Callback Hell_ ("ад колбеков") из-за большого числа вложенных колбеков, которые очень затрудняют анализ программы. Кто-то даже сделал сайт http://callbackhell.com/ , на котором разбирается эта проблема и приводится вот такой код:

```javascript
import fs from 'fs';

// В этом коде происходит обработка ошибок, которую мы рассмотрим в следующем уроке
fs.readdir(source, (err, files) => {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach((filename, fileIndex) => {
      console.log(filename)
      gm(source + filename).size((err, values) => {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach((width, widthIndex) => {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, (err) => {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
```

В некоторых случаях заранее неизвестно, сколько надо будет выполнить операций. Например, может понадобиться прочитать содержимое директории и посмотреть, кто владелец каждого файла (его _uid_). Если бы код был синхронный, то наше решение выглядело бы так:

```javascript
import path from "path";
import fs from "fs";

const getFileOwners = (dirpath) => {
  // Читаем содержимое директории
  const files = fs.readdirSync(dirpath);
  // Получаем информацию по каждому файлу и формируем результат
  return files
    .map((fname) => [fname, fs.statSync(path.join(dirpath, fname))])
    .map(([fname, stat]) => ({ filename: fname, owner: stat.uid }));
};
// [ { filename: 'Makefile', owner: 65534 },
//       { filename: '__tests__', owner: 65534 },
//       { filename: 'babel.config.js', owner: 65534 },
//       { filename: 'info.js', owner: 65534 },
//       { filename: 'package.json', owner: 65534 } ]
```

Последовательный код прост и понятен, каждая следующая строчка выполняется после того, как закончится предыдущая, а в `map` каждый элемент обрабатывается гарантированно последовательно.

С асинхронным кодом возникают вопросы. И если чтение директории — операция, которую мы сделаем в любом случае, то как описать анализ файлов, ведь их может быть любое количество. К сожалению, без использования готовых абстракций, упрощающих данную задачу, мы получим много сложного кода. Настолько сложного, что в реальной жизни так лучше никогда не делать, этот код приводится только в образовательных целях.

```javascript
import path from "path";
import fs from "fs";

const getFileOwners = (dirpath, cb) => {
  fs.readdir(dirpath, (_error1, filenames) => {
    const readFileStat = (items, result = []) => {
      if (items.length === 0) {
        // Обработку ошибок пока не рассматриваем
        cb(null, result);
        return;
      }
      const [first, ...rest] = items;
      const filepath = path.join(dirpath, first);
      fs.stat(filepath, (_error2, stat) => {
        readFileStat(rest, [...result, { filename: first, owner: stat.uid }]);
      });
    };
    readFileStat(filenames);
  });
};
```

Общий принцип такой: формируется специальная функция (`readFileStat`), которая рекурсивно вызывается, передавая себя в функцию `stat`. С каждым новым вызовом она отрабатывает один файл и уменьшает массив `items`, в котором содержатся ещё необработанные файлы. Вторым параметром она аккумулирует (собирает) получившийся результат, который в конце передаётся в колбек `cb` (переданный вторым аргументом функции `getFileOwners`). Пример выше реализует [итеративный процесс, построенный на рекурсивных функциях](https://ru.hexlet.io/blog/posts/recursive). Чтобы лучше понять код выше, попробуйте скопировать его к себе на компьютер и позапускайте с разными аргументами, предварительно расставив отладочный вывод внутри неё.

---

##### Дополнительные материалы

1. [Итеративный процесс](https://ru.hexlet.io/courses/introduction_to_programming/lessons/iterative/theory_unit)

## Обработка ошибок—JS: Асинхронное программирование

Чтение и запись файлов, получение данных по сети, выполнение HTTP запросов — всё это операции ввода/вывода. Через них программа взаимодействует с внешней средой. Внешняя среда — штука не простая, с большим количеством разнообразных правил, которые необходимо соблюдать. Например, для успешного чтения файла программа должна иметь к нему доступ. Для записи — свободное место на диске. Для выполнения запросов по сети нужно соединение с сетью. Подобных условий десятки, а то и сотни. Невыполнение хотя бы одного из них приводит к ошибке. Посмотрите на этот впечатляющий [список из нескольких сотен всевозможных ошибок](https://nodejs.org/api/errors.html#errors_node_js_error_codes).

В JavaScript обработка ошибок работает через механизм исключений. Одни функции их возбуждают, другие обрабатывают через _try..catch_. Так было в синхронном коде. В асинхронном стандартный механизм уже не работает.

Подумайте над тем как отработает код ниже:

```javascript
import fs from "fs";

try {
  // Пытаемся читать директорию, а это ошибка
  fs.readFile("./directory", "utf-8", () => {
    callUndefinedFunction();
  });
} catch (e) {
  console.log("error!");
}
```

Так как _try/catch_ работает только с кодом из текущего стека вызовов, то он не сможет перехватить то, что вызвалось в другом стеке. Поэтому мы не увидим сообщения _error!_, хотя сама ошибка на экране появится:

```javascript
callUndefinedFunction();
^

ReferenceError: callUndefinedFunction is not defined
    at ReadFileContext.fs.readFile [as callback] (/private/var/tmp/index.js:6:5)
```

Из вывода видно, что колбек вызвался в своем стеке вызовов, начавшимся внутри функции `readFile()`. Фактически это означает, что использовать _try/catch_ в асинхронном коде с колбеками — бесполезно, эта конструкция здесь просто неприменима.

Что выведет на экран код ниже?

```javascript
import fs from "fs";

try {
  // Пытаемся читать директорию, а это ошибка
  fs.readFile("./directory", "utf-8", () => {
    console.log("finished!");
  });
} catch (e) {
  console.log("error!");
}
```

Правильный ответ: _finished!_. Это кажется странным, учитывая что ошибка возникла внутри функции `readFile()`, а не в колбеке. Это происходит потому, что содержимое функции `readFile()` не принадлежит текущему стеку вызовов.

Асинхронные функции всегда имеют дело с внешней средой (операционной системой). Это значит, что любая асинхронная функция потенциально может завершиться с ошибкой. Причём не важно возвращает ли она какие-то данные или нет, ошибка может возникнуть всегда. Именно по этой причине колбеки всех асинхронных функций первым параметром принимают ошибку _err_ и, соответственно, проверять её наличие придётся руками. Если пришёл `null`, то ошибки нет, если не `null` — есть. Это очень важное _соглашение_, которого придерживаются не только разработчики стандартной библиотеки, но и все разработчики сторонних решений.

```javascript
fs.readFile("./directory", "utf-8", (err, data) => {
  // Любые ошибки чтения файла: доступ, отсутствие файла, директория вместо файла
  // null неявно приводится к false, поэтому достаточно такой проверки,
  // любой другой ответ трактуется как true
  if (err) {
    console.log("error!");
    return; // guard expression
  }

  console.log("finished!");
});
```

В цепочке вызовов придётся делать проверку на каждом уровне:

```javascript
import fs from "fs";

fs.readFile("./first", "utf-8", (error1, data1) => {
  if (error1) {
    console.log("error in first file");
    return;
  }
  fs.readFile("./second", "utf-8", (error2, data2) => {
    if (error2) {
      console.log("error in second file");
      return;
    }
    fs.writeFile("./new-file", `${data1}${data2}`, (error3, data3) => {
      if (error3) {
        console.log("error during writing");
        return;
      }
      console.log("finished!");
    });
  });
});
```

Тот же самый код, помещённый внутрь функции, выглядит немного по-другому. Как только происходит ошибка, мы вызываем основной колбек и отдаём туда ошибку. Если ошибка не возникла, то мы всё равно вызываем исходный колбек и передаём туда `null`. Вызывать его обязательно, иначе внешний код не дождётся окончания операции. Следующие вызовы больше не выполняются:

```javascript
import fs from "fs";

const unionFiles = (inputPath1, inputPath2, outputPath, cb) => {
  fs.readFile(inputPath1, "utf-8", (error1, data1) => {
    if (error1) {
      cb(error1);
      return;
    }
    fs.readFile(inputPath2, "utf-8", (error2, data2) => {
      if (error2) {
        cb(error2);
        return;
      }
      fs.writeFile(outputPath, `${data1}${data2}`, (error3) => {
        if (error3) {
          cb(error3);
          return;
        }
        cb(null); // не забываем последний успешный вызов
      });
    });
  });
};
```

Последний вызов можно сократить. Если в самом конце не было ошибки, то вызов `cb(error3)` отработает так же, как и `cb(null)`, а значит, весь код последнего колбека можно свести к вызову `cb(error3)`:

```
fs.writeFile(outputPath, `${data1}${data2}`, cb);
// что равносильно fs.writeFile(outputPath, `${data1}${data2}`, error3 => cb(error3));
```

## Параллельное выполнение операций—JS: Асинхронное программирование

Попытаемся выполнить несколько асинхронных вызовов одновременно и затем воспользоваться их результатом. Попробуем переписать нашу задачу по объединению файлов. Вот её текст:

> Предположим, что перед нами стоит задача прочитать содержимое двух файлов и записать в третий (объединение файлов)

Из постановки видно, что оба исходных файла можно прочитать одновременно и затем, когда они оба будут прочитаны, записать новый файл.

```javascript
fs.readFile("./first", "utf-8", (error1, data1) => {
  // ?
});

fs.readFile("./second", "utf-8", (error2, data2) => {
  // ?
});
```

Так как наш код асинхронный, результат работы каждой функции можно получить лишь внутри колбеков. Причём, порядок запуска колбеков мы не можем знать — всё зависит от того, какой файл прочитается быстрее. Для отслеживания состояния выполнения этих операций придётся ввести **глобальное состояние** (относительно этих операций), через которое мы будем отслеживать завершённость и в котором сохраним данные. И только когда все операции завершились — запишем новый файл. Кроме того, нам нужно чётко разделять данные первого и второго файлов, так как запись в новый файл (в отличие от чтения) должна происходить в определённом порядке.

```javascript
const state = {
  count: 0,
  results: [],
};

fs.readFile("./first", "utf-8", (error1, data1) => {
  state.count += 1;
  state.results[0] = data1;
});

fs.readFile("./second", "utf-8", (error2, data2) => {
  state.count += 1;
  state.results[1] = data2;
});
```

Когда обе операции завершатся, состояние заполнится данными, а значение `count` станет `2`. Именно на это условие мы и завяжем наш код:

```javascript
import fs from "fs";

const state = {
  count: 0,
  results: [],
};

const tryWriteNewFile = () => {
  if (state.count !== 2) {
    return; // guard expression
  }

  fs.writeFile("./new-file", state.results.join(""), (error) => {
    if (error) {
      return;
    }
    console.log("finished!");
  });
};

console.log("first reading was started");
fs.readFile("./first", "utf-8", (error1, data1) => {
  console.log("first callback");
  if (error1) {
    return;
  }
  state.count += 1;
  state.results[0] = data1;
  tryWriteNewFile();
});

console.log("second reading was started");
fs.readFile("./second", "utf-8", (error2, data2) => {
  console.log("second callback");
  if (error2) {
    return;
  }
  state.count += 1;
  state.results[1] = data2;
  tryWriteNewFile();
});

// Один запуск
// node index.js
// first reading was started
// second reading was started
// second callback
// first callback
// finished!

// Другой запуск
// node index.js
// first reading was started
// second reading was started
// first callback
// second callback
// finished!
```

Теперь файлы читаются параллельно и мы, наконец-то, увидели на практике преимущество одновременного выполнения асинхронных операций. Скорость выполнения этой программы значительно выше синхронного варианта! Причём, чем больше размер файлов, тем больше разница. Однако, стоит заметить, что, хотя чтение файлов происходит параллельно, работа самого js, обрабатывающего результат — строго последовательна. Колбеки начинают запускаться только после того, как опустеет текущий стек вызовов, и в том порядке, в котором завершились асинхронные операции (параллельный запуск не означает, что операции заканчиваются и начинаются одновременно).

Каждый раз писать подобный код очень утомительно, поэтому лучше воспользоваться библиотекой под названием [async](https://caolan.github.io/async/), которая предоставляет набор готовых абстракций для работы в асинхронном стиле. Она содержит десятки функций для большого числа задач, связанных с упорядочиванием асинхронных операций. Ниже пример решения нашей задачи с использованием этой библиотеки:

```javascript
import { map } from "async";
import fs from "fs";

map(["./first", "./second"], fs.readFile, (err1, results) => {
  if (err1) {
    return;
  }
  fs.writeFile("./new-file", results.join(""), (err2) => {
    if (err2) {
      return;
    }
    console.log("finished!");
  });
});
```

Согласитесь, что это значительно лучше ;) Но, как увидите позже, можно пойти ещё дальше.

---

##### Дополнительные материалы

1. [async — библиотека для работы в асинхронном стиле](https://caolan.github.io/async/)

## Таймеры—JS: Асинхронное программирование

Отдельное место в асинхронном мире занимают таймеры. Они позволяют отложить выполнение какой-либо функции "на потом". Наиболее важная функция для работы с таймерами — `setTimeout(f, delay)`

```javascript
const f = () => console.log("hey!");
setTimeout(f, 1000);
```

В коде выше функция `f` выполнится не раньше, чем через секунду. Об этом нам говорит второй параметр, в который передаётся время, указанное в миллисекундах, после которого запустится функция, указанная первым параметром. По историческим причинам у таймеров есть минимальная задержка, которую они соблюдают всегда, и она равна четырём миллисекундам. Другими словами, нет разницы между вызовами `setTimeout(f, 1)`, `setTimeout(f, 3)` и `setTimeout(f, 4)` — во всех этих случаях минимальная задержка равна `4`.

Для чего нужны таймеры? У них много разных применений. Если говорить про браузер, то это могут быть автоматически скрываемые элементы: например, нотификации. Другой пример — это регулярный (например, раз в 5 секунд) Ajax-запрос для получения новых данных. На сервере таймеры используются реже, но тоже встречаются: с помощью них можно разбить объёмную синхронную операцию на несколько кусков, давая возможность выполниться другому коду.

_В операционных системах такое поведение называется кооперативной многозадачностью. Она позволяет создавать ощущение параллельного выполнения кода, даже если этого не происходит._

Функция, переданная в таймер, выполняется не в текущем стеке вызовов, а значит к таймерам применимы все те особенности и подходы, о которых мы говорили ранее. Ошибки, возникающие в таймерах, невозможно отследить с помощью _try/catch_, для этого нужно использовать колбеки.

```javascript
const f = () => console.log("hey!");
console.log("before timeout");
setTimeout(f, 1000);
console.log("after timeout");
// скрипт не заканчивается, а дожидается выполнения таймеров
```

Запуск:

```javascript
node index.js

before timeout
after timeout
hey!
```

Попробуйте ответить на такой вопрос. Могут ли таймеры гарантировать точный запуск через указанный промежуток времени? На самом деле не могут. Все зависит от того, что выполняется прямо сейчас. Проверкой таймеров занимается рантайм в тот момент, когда в текущем стеке вызовов не осталось кода. Если запустить тяжелое вычисление, которое не прекращается долго, то все колбеки, все таймеры, будут ждать пока вычисление закончится. Фактически это означает, что в таймерах задается минимальное время, после которого их можно запускать.

Эта особенность имеет два важных следствия:

- Старайтесь минимизировать время выполнения долгих вычислений. Например, их можно разбивать на шаги.
- Не рассчитывайте на точность времени вызова. Оно всегда будет отличаться в большую сторону.

Таймеры можно не только создавать, но и отменять. Вызов `setTimeout` возвращает специальное значение — идентификатор таймера. Если передать его в функцию `clearTimeout`, то таймер отменится:

```javascript
const f = () => console.log("hey!");
console.log("before timeout");
// В браузере идентификатор таймера это числовое значение
// В node.js это объект
const timerId = setTimeout(f, 1000);
console.log("after timeout");
clearTimeout(timerId);
```

Запуск:

```
node index.js

before timeout
after timeout
```

_То, что асинхронная функция вернула идентификатор таймера, не противоречит тому, что мы ранее говорили про возврат в асинхронных функциях. Асинхронная функция не может вернуть результат выполнения асинхронной операции, но может вернуть что-нибудь другое, что делалось синхронно внутри нее. В случае таймеров, идентификатор таймера возвращается синхронно, а вот сам таймер выполняется асинхронно._

Частая ошибка новичков в том, что они передают в таймер не саму функцию, а делают её вызов. Обычно она встречается тогда, когда в функцию нужно передать некоторые заранее определённые аргументы:

```javascript
const f = (message) => console.log(message);
console.log("before timeout");
setTimeout(f("hey!"), 1000);
console.log("after timeout");
```

Запуск:

```javascript
node index.js

before timeout
hey!
timers.js:390
    throw new ERR_INVALID_CALLBACK();
    ^

TypeError [ERR_INVALID_CALLBACK]: Callback must be a function
```

До последнего лога дело не дошло, потому что скрипт упал на вызове `setTimeout`, так как он ожидал на вход функцию, а пришла не функция (вызов в примере вернул значение `undefined`).

Передать данные внутрь функции можно тремя способами:

**Дополнительные параметры в setTimeout**

Все аргументы, переданные в `setTimeout` после второго аргумента (времени), автоматически становятся аргументами функции, которую вызовет таймер.

```javascript
const f = (a, b) => console.log(a + b);
setTimeout(f, 1000, 5, 8);
// =>  13
```

**Функция-обёртка**

Наиболее распространённый способ — создание функции-обёртки. Такой способ лучше предыдущего из-за его прозрачности: сразу видно, что происходит.

```javascript
const f = (a, b) => console.log(a + b);
setTimeout(() => f(5, 8), 1000);
// =>  13
```

**bind**

Последний способ — использовать функцию `bind`. Основное предназначение этой функции — смена контекста функции. Но она может использоваться и для частичного применения функции:

```javascript
const f = (a, b) => console.log(a + b);
// Первый параметр null потому что контекст не меняется
setTimeout(f.bind(null, 5, 8), 1000);
// =>  13
```

Вызов этой функции возвращает новую функцию с применёнными аргументами.

Важно понимать, что таймер не делает операцию (ту, что выполняется при вызове функции, переданной в setTimeout) асинхронной — таймер лишь откладывает время её выполнения. Если сама операция синхронная, то после запуска она заблокирует основной поток выполнения программы, и все остальные будут ждать её завершения.

### setInterval

Функция `setInterval` имеет точно такую же сигнатуру, как и `setTimeout`. Смысл аргументов — тот же самый. Разница в том, что `setInterval` автоматически запускает функцию не один раз, а до тех пор, пока её явно не остановят через `clearInterval`. Время между запусками равно значению второго параметра.

```javascript
const id = setInterval(() => console.log(new Date()), 5000);
setTimeout(() => clearInterval(id), 16000);

// node index.js
// 2019-06-05T19:05:28.149Z
// 2019-06-05T19:05:33.172Z
// 2019-06-05T19:05:38.177Z
```

Таймер можно остановить изнутри, передав в колбек его _id_.

```javascript
let counter = 0;
const id = setInterval(() => {
  counter += 1;
  if (counter === 4) {
    clearInterval(id);
    return;
  }
  console.log(new Date());
}, 5000);
```

---

##### Дополнительные материалы

1. [setTimeout](https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout)
2. [setInterval](https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/setInterval)

## Промисы (Promise)—JS: Асинхронное программирование

Асинхронный код, при всех его преимуществах, очень сложен в анализе. Буквально несколько вложенных колбеков с параллельным выполнением операций и уже практически невозможно разобраться в происходящем. Страшно представить себе большую программу в которой асинхронно все. Тысяча-другая строк кода и ни один человек не сможет понять его.

С самого начала разработчики понимали ограниченность подхода с колбеками, но понадобилось немало времени до того, как в JavaScript появилась альтернатива – Promises. Промисы меняют способ организации кода не добавляя нового синтаксиса. При правильном использовании, они позволяют "выпрямить" асинхронный код и сделать его предельно плоским и последовательным.

Большая часть современного JavaScript кода пишется на промисах, а колбеки уходят в прошлое. Например разработчики Node.js внедрили промисы практически во все встроенные модули. Функции для работы с файловой системой, построенные на промисах, доступны через свойство `promises` модуля _fs_. Сравните примеры:

```javascript
import fs from "fs";

// Код на колбеках похож на лесенку

fs.readFile("./first", "utf-8", (_error1, data1) => {
  console.log(data1);
  fs.readFile("./second", "utf-8", (_error2, data2) => {
    console.log(data2);
    fs.readFile("./third", "utf-8", (_error3, data3) => {
      console.log(data3);
    });
  });
});

// Код на промисах практически плоский

// Переименование свойства promises в fsp для краткости
const { promises: fsp } = fs;

fsp
  .readFile("./first", "utf-8")
  .then((data1) => console.log(data1))
  .then(() => fsp.readFile("./second", "utf-8"))
  .then((data2) => console.log(data2))
  .then(() => fsp.readFile("./third", "utf-8"))
  .then((data3) => console.log(data3));
```

Технически промис это специальный объект, который отслеживает асинхронную операцию и хранит внутри себя её результат. Он возвращается всеми асинхронными функциями, построенными на промисах.

```javascript
const promise = fsp.readFile(src, "utf-8");
```

Очень важно понимать, что промис — это не результат асинхронной операции. Это объект, который отслеживает выполнение операции. Операция по-прежнему асинхронна и выполнится когда-нибудь потом.

```javascript
const promise = fsp.readFile(src, "utf-8");
// Файл еще не прочитан
console.log(promise);
// Promise { <pending> }
// pending – это состояние промиса, говорит о том что операция еще в процессе
```

Как получить результат выполнения асинхронной операции? Снаружи — никак, это просто невозможно. Но промис можно "продолжить", используя метод `then()`, в который нужно передать колбек-функцию. Параметром этого колбека и будет тот самый результат асинхронной операции

```javascript
// Результат чтения файла передан в колбек-функцию переданную в then
// колбек вызовется только тогда, когда выполнится чтение файла
fsp.readFile(src, "utf-8").then((content) => console.log(content));
```

Колбек именно передается внутрь `then()`, а не вызывается. Вызов делает уже сам промис тогда, когда выполнится асинхронная операция.

Независимо от содержимого колбек-функции, вызов `then()` всегда возвращает новый промис. А возврат колбек-функции становится доступным как параметр колбека следующего `then()`. Именно такая организация промисов позволяет строить цепочки без необходимости вкладывать вызовы друг в друга, тем самым избегая Callback Hell.

```javascript
// Предположим что внутри файла был текст Hexlet
const promise = fsp
  .readFile(src, "utf-8") // результат цепочки ВСЕГДА промис
  .then((content) => `go to the next then with ${content}`) // игнорируем результат операции
  .then((text) => console.log(text)); // в этот колбек, роль которого играет лог, передается значение с предыдущего then
// => go to the next then with Hexlet
// Вопрос на самопроверку.
// Что выведется на экран, если добавить к промису выше then(console.log)?
```

А что если колбек-функция вернет не просто значение, а промис? Тогда параметром следующего `then()` становится [результат выполнения](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#return_value) этого промиса. Иначе промисы были бы бесмысленны. Пример:

```javascript
const promise = /* тут какая-то операция */
  // Из колбека возвращается промис
  .then(() => fsp.readFile(filePath))
  // В колбек попадает результат выполнения предыдущего промиса
  .then((text) => console.log(text));
```

Использование промисов внутри любой функции, автоматически делает эту функцию асинхронной. Она больше не может вызываться как обычная синхронная функция, так как в таком случае невозможно воспользоваться результатом ее работы, дождаться выполнения операции или узнать об ошибках:

```javascript
// Неправильное определение

export const copy = (src, dest) => {
  fsp.readFile(src, "utf-8").then((content) => fsp.writeFile(dest, content));
};

// Использование

// делаем что-то синхронное
copy(src, dest);
// делаем что-то еще
```

Как только в коде появляется асинхронность, код должен менять свою структуру. В случае колбеков он становится вложенным, в случае промисов весь код превращается в непрерывную цепочку промисов.

```javascript
// Правильное определение

export const copy = (src, dest) => {
  return fsp
    .readFile(src, "utf-8")
    .then((content) => fsp.writeFile(dest, content));
};

// Использование

// делаем что-то синхронное
copy(src, dest)
  .then(() => {
    // делаем что-то еще
  })
  .then(/* продолжаем */)
  .then(/* продолжаем */);
```

### Неправильное использование промисов

Главное преимущество промисов перед колбеками в том, что с их помощью асинхронный код становится немного похож на синхронный. Видно цепочку вызовов и она не растет вглубь. По крайней мере в теории. На практике же, промисы используются не всегда правильно. Посмотрите на код:

```javascript
fsp.readFile("./first", "utf-8").then((data1) => {
  console.log(data1);
  // Читаем файл и продолжаем промис от этой, внутренней функции
  return fsp.readFile("./second", "utf-8").then((data2) => {
    console.log(data2);
    // Читаем файл и продолжаем промис от этой, внутренней функции
    return fsp.readFile("./third", "utf-8").then((data3) => {
      console.log(data3);
    });
  });
});
```

Несмотря на то что здесь используются промисы, код выглядит даже сложнее чем с колбеками. Проблема в том как построены вызовы. Продолжение цепочки идет не от верхнего промиса, а от каждой последующей асинхронной операции. В теории промисы действительно бывают вложенными, но только там, где по другому никак. В любой другой ситуации код должен быть плоским и простым:

```javascript
// Плоская цепочка промисов
fsp
  .readFile("./first", "utf-8")
  .then((data1) => console.log(data1))
  .then(() => fsp.readFile("./second", "utf-8"))
  .then((data2) => console.log(data2))
  .then(() => fsp.readFile("./third", "utf-8"))
  .then((data3) => console.log(data3));
```

---

##### Дополнительные материалы

1. [promisejs.org](https://www.promisejs.org/)

## Обработка ошибок в промисах—JS: Асинхронное программирование

Ошибки внутри промисов обрабатываются крайне просто. Для перехвата достаточно вызвать метод `catch` и передать туда колбек, принимающий на вход саму ошибку:

```javascript
import fsp from "fs/promises";

const promise = fsp.readFile("unknownfile");
promise.catch((e) => console.log("error!!!", e));
// => error!!! { [Error: ENOENT: no such file or directory, open 'unknownfile']
// errno: -2, code: 'ENOENT', syscall: 'open', path: 'unknownfile' }
```

`catch`, в свою очередь, возвращает _promise_, что позволяет коду восстанавливать работу после ошибок и продолжать цепочку. Вполне нормально писать код в стиле цепочки, в которой чередуются `then` и `catch`:

```javascript
import fsp from "fs/promises";

const promise = fsp
  .readFile("unknownfile")
  .catch(console.log)
  .then(() => fsp.readFile("anotherUnknownFile"))
  .catch(console.log);
```

В большинстве ситуаций не имеет значения, на какой из операций возникла ошибка. Любое "падение" должно прерывать текущее выполнение и уходить в блок обработки ошибки. Именно так работает код с _try/catch_, и такое же поведение эмулируется промисами. Дело в том, что, если возникла ошибка, то она передаётся по цепочке первому встреченному `catch`, а все встречающиеся на пути `then` игнорируются. Поэтому код выше можно упростить так:

```javascript
import fsp from "fs/promises";

const promise = fsp
  .readFile("unknownfile")
  .then(() => fsp.readFile("anotherUnknownFile"))
  .catch(console.log);
```

Семантически эти версии кода не эквивалентны. В первом случае вторая операция чтения начнёт выполняться обязательно, независимо от того, как закончилась предыдущая. В последнем — если упадёт первое чтение файла, то второе не будет выполнено.

![Обработка ошибок в промисах](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjVjNGYxNTk5MzM5MTZhMTkzZDMwZjI0NWY2YjlkZmJmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c999f0cd41ed055790ffd3e205095c93feb66d871013768b01121dff9ba93712)

Иногда ошибку нужно генерировать самостоятельно. Самый простой способ сделать это — бросить исключение. К этому тоже надо привыкнуть. _try/catch_ использовать нельзя (потому что бесполезно), а вот бросать исключения можно. Промис сам их преобразует, как надо, и отправит по цепочке в поиске вызова `catch`:

```javascript
import fsp from "fs/promises";

const promise = fsp
  .readFile("unknownfile")
  .then((data) => {
    // делаем что-нибудь
    throw new Error("boom!");
  })
  .then(() => {
    // Этот then не будет вызван из—за исключения на предыдущем шаге
  })
  .catch(console.log);
```

Другой способ — вернуть результат вызова функции `Promise.reject`, внутрь которой передаётся сама ошибка:

```javascript
import fsp from "fs/promises";

const promise = fsp
  .readFile("unknownfile")
  .then((data) => {
    // делаем что-нибудь
    return Promise.reject(new Error("boom!"));
  })
  .catch(console.log);
```

Помимо чисто технических моментов в обработке ошибок есть и архитектурно-организационные. Если вам приходится реализовывать асинхронные функции, которыми будут пользоваться другие люди, то никогда не подавляйте ошибки:

```javascript
import fsp from "fs/promises";

const readFileEasily = (filepath) => fsp.readFile(filepath).catch(console.log);
```

Перехватив ошибку, вы не оставляете шансов узнать о ней вызывающему коду. Тот, кто использует эту функцию, не сможет отреагировать на ошибочную ситуацию. Если обработка ошибки всё же нужна — обрабатывайте, но не забывайте генерировать её снова:

```javascript
import fsp from "fs/promises";

const readFileEasily = (filepath) =>
  fsp.readFile(filepath).catch((e) => {
    console.log(e); // В библиотеках так делать нельзя, только в своем коде
    throw e;
  });

// Теперь вызывающий код может обработать ошибку:

readFileEasily("path/to/file").catch(/* ... */);
```

## Цепочка промисов—JS: Асинхронное программирование

Даже при использовании промисов не всегда понятно, как структурировать асинхронный код. В этом уроке мы разберём некоторые полезные практики, делающие его проще для написания и анализа. Возьмём уже знакомую нам задачку по объединению двух файлов.

```javascript
import fs from "fs";

const unionFiles = (inputPath1, inputPath2, outputPath, cb) => {
  fs.readFile(inputPath1, "utf-8", (error1, data1) => {
    if (error1) {
      cb(error1);
      return;
    }
    fs.readFile(inputPath2, "utf-8", (error2, data2) => {
      if (error2) {
        cb(error2);
        return;
      }
      fs.writeFile(outputPath, `${data1}${data2}`, cb);
    });
  });
};
```

Запомните этот код — таким вы больше никогда его не увидите ;) Сейчас мы проведём серию рефакторингов и получим в результате код, который является каноническим при работе с промисами. Итак, первая версия:

```javascript
import fsp from "fs/promises";

const unionFiles = (inputPath1, inputPath2, outputPath) => {
  // Промисы всегда должны возвращаться и строиться в цепочку!
  const result = fsp.readFile(inputPath1, "utf-8").then((data1) => {
    const promise = fsp
      .readFile(inputPath2, "utf-8")
      .then((data2) => fsp.writeFile(outputPath, `${data1}${data2}`));
    return promise;
  });
  return result; // это промис
};
```

Хорошая новость — код стал понятнее и уменьшился в объёме. К тому же, из него целиком ушла обработка ошибок, так как промисы обрабатывают их автоматически и, если вызывающий код захочет их перехватывать, то сделает это самостоятельно через метод `catch()`. Но есть и плохая новость — код всё ещё структурирован, как колбеки, "лесенкой". В этом коде не учитывается свойство промисов, связанное с возвратом из `then()`.

```javascript
import fsp from 'fs/promises';

const unionFiles = (inputPath1, inputPath2, outputPath) => {
  const result = fsp.readFile(inputPath1, 'utf-8')
    .then((data1) => fsp.readFile(inputPath2, 'utf-8'))
    // then ниже берется от промиса readFile
    .then((data2) => fsp.writeFile(outputPath, `${<как сюда попадет data1?>}${data2}`));
  return result;
};
```

Эта версия совсем плоская, именно к такому коду нужно стремиться в промисах. Но она таит в себе одну проблему. Если где-то в цепочке ниже нужны данные, которые были получены сверху, то придется протаскивать их сквозь всю цепочку. В примере выше это результат чтения первого файла. Переменная `data1` недоступна в том месте, где происходит запись в файл. Основной выход из данной ситуации — создание переменных, через которые данные будут прокинуты дальше:

```javascript
import fsp from "fs/promises";

const unionFiles = (inputPath1, inputPath2, outputPath) => {
  let data1;
  return fsp
    .readFile(inputPath1, "utf-8")
    .then((content) => {
      data1 = content;
    })
    .then(() => fsp.readFile(inputPath2, "utf-8"))
    .then((data2) => fsp.writeFile(outputPath, `${data1}${data2}`));
};
```

Уже не так красиво, но всё ещё плоско. Преимущество такого подхода становится всё более и более очевидным с увеличением количества промисов. Тем более далеко не всегда нужно передавать данные дальше.

### Контроль асинхронных операций

Частая ошибка при работе с промисами – потеря контроля. Посмотрите на немного измененный код из примеров выше:

```javascript
import fsp from "fs/promises";

// Чего здесь не хватает?
const unionFiles = (inputPath1, inputPath2, outputPath) => {
  const result = fsp.readFile(inputPath1, "utf-8").then((data1) => {
    const promise = fsp
      .readFile(inputPath2, "utf-8")
      .then((data2) => fsp.writeFile(outputPath, `${data1}${data2}`));
  });
  return result;
};
```

Этот код хоть и сработает во многих ситуациях, все же содержит серьезную ошибку. Промис внутри константы `promise` не возвращается наружу. Цепочка промисов прервалась. Любая ошибка в этом промисе пройдет незамеченной для внешнего кода. Нет гарантии что этот промис вообще успеет выполниться к тому моменту, когда этого будет ожидать вызывающий код.

Нарушение непрерывности (контроля) асинхронных операций частая ошибка даже у опытных программистов. В некоторых ситуациях ошибка заметна сразу, в других код начинает вести себя странно: часть запусков проходит без проблем, другая падает со странными ошибками.

Чтобы этого не происходило, нужно всегда убеждаться в непрерывности асинхронных операций. Завершение любой операции должно приводить к какой-то реакции, кто-то всегда должен ждать этого момента.

### Динамическая цепочка

Иногда количество асинхронных операций заранее неизвестно, но они должны выполняться строго по очереди. Эту задачу можно решить, используя циклы или свертку. Какой бы способ не был выбран, сам принцип построения цепочки не поменяется. Цепочка промисов это всегда _then().then().then()..._.

Единственный нюанс, который нужно учесть – начальный промис, с которого начнёт строиться цепочка. Если такого промиса нет, то его можно создать используя функцию `Promise.resolve()`. Она возвращает промис, который ничего не делает, но с него можно начинать свертку. Ниже пример, в котором последовательно читается набор файлов и возвращается массив их содержимого:

```javascript
const filePaths = /* список путей до файлов */;

// Эта функция принимает на вход необязательное значение,
// которое появится в promise.then((<тут>) => ...)
// Начальное значение в данном случае – массив,
// в котором накапливаются данные из файлов
const initPromise = Promise.resolve([]);

// В then отдается функция, а не ее вызов!
const promise = filePaths.reduce((acc, path) => {
  // Аккумулятор – всегда промис, внутри которого массив с содержимым файлов
  const newAcc = acc.then((contents) =>
    // Читаем файл и добавляем его данные в аккумулятор
    fsp.readFile(path).then((data) => contents.concat(data)));
  return newAcc;
}, initPromise);

// Если надо, продолжаем обработку
promise.then((contents) => /* обрабатываем все данные полученные из файлов */);
```

## Promise.all—JS: Асинхронное программирование

Промисы, как и колбеки, позволяют выполнять асинхронные операции параллельно. Причём умеют делать это в автоматическом режиме, без ручного отслеживания окончания одной из операций. Для этого достаточно собрать массив из промисов и передать их в функцию `Promise.all`. В результате вернётся обычный промис, на основе которого можно строить дальнейшую цепочку. Данными в первом `then` будет массив с данными всех выполненных операций.

```javascript
import fsp from "fs/promises";

const unionFiles = (inputPath1, inputPath2, outputPath) => {
  const promise1 = fsp.readFile(inputPath1, "utf-8");
  const promise2 = fsp.readFile(inputPath2, "utf-8");
  // На вход идет МАССИВ из промисов
  const promise = Promise.all([promise1, promise2]);
  // Обязательно делать возврат!
  return promise.then(([data1, data2]) =>
    fsp.writeFile(outputPath, `${data1}${data2}`)
  );
};
```

Получился эффективный код, который ещё и легко понять. К тому же здесь нет дополнительных переменных. `Promise.all` хоть и возвращает данные в том же порядке, в котором в него были переданы промисы, но не гарантирует последовательность выполнения операций. Не рассчитывайте на это никогда, все операции запускаются одновременно, и какая из них выполнится раньше или позже — неизвестно.

Функции `Promise.all` не важно, каким образом была получена коллекция промисов. Единственное, что ей нужно – получить на вход массив этих промисов. Поэтому `Promise.all` легко комбинируется с любыми функциями, возвращающими коллекции. В примере ниже дается массив путей до файлов, которые нужно прочитать и вывести на экран их содержимое. Первым делом в коде формируется массив из промисов, затем он передается в `Promise.all` и, наконец, содержимое файлов выводится на экран:

```javascript
// promises – массив промисов
const promises = filepaths.map((filepath) => fsp.readFile(filepath, "utf-8"));
const promise = Promise.all(promises);
// Выводим на экран содержимое каждого файла
promise.then((contents) => contents.map(console.log));
```

`map` проходится по каждому файлу, и отдает его в нашу функцию, которая выполняет вызов `fsp.readFile()`. Каждый такой вызов возвращает промис. Если попробовать распечатать этот массив, то он будет выглядеть так:

```javascript
const promises = filepaths.map((filepath) => fsp.readFile(filepath, 'utf-8'));
console.log(promises);
[
  Promise { <pending> },
  Promise { <pending> },
  Promise { <pending> },
  Promise { <pending> },
  ...
]
```

`Promise.all` всегда запускает операции одновременно, и эти операции друг от друга никак не зависят. Это значит, что никакая ошибка (кроме остановки программы) не остановит запросы. Ошибка хотя бы в одном из промисов не помешает выполниться всем остальным запросам. Однако, если хотя бы один промис завершился с ошибкой, весь результат `Promise.all` будет помечен как ошибочный, а значит управление попадёт в ближайший `catch`. Чтобы этого избежать, можно передавать в `Promise.all` не просто промисы, а промисы с повешенными на них обработчиками ошибок `catch`, из которых уже возвращаются данные с пометкой об успешности.

```javascript
const promises = filepaths.map((filepath) =>
  fsp
    .readFile(filepath, "utf-8")
    .then((v) => ({ result: "success", value: v }))
    .catch((e) => ({ result: "error", error: e }))
);
const promise = Promise.all(promises);
```

---

##### Дополнительные материалы

1. [Promise.all](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)

## new Promise—JS: Асинхронное программирование

Если в проекте появились промисы, то, по-хорошему, весь код должен работать только через них. К сожалению, далеко не все библиотеки имеют интерфейс с промисами и работают по старинке, на колбеках. В таких случаях функции нужно "обернуть" или, как говорят, "промисифицировать". Создание промиса происходит с помощью конструктора `Promise`:

```javascript
import fs from "fs";

const promise = new Promise((resolve, reject) => {
  fs.readFile("/etc/passwd", (err, data) => {
    if (err) {
      reject(err);
      return;
    }
    resolve(data);
  });
});
```

Промис ожидает на вход функцию, которая будет вызвана в момент создания. Именно внутри этой функции и нужно выполнять асинхронную операцию (на колбеках), которую мы хотим превратить в промис. Промис прокидывает в эту функцию два колбека:

- `resolve` — должна быть вызвана в случае успешного завершения асинхронной операции. Ей на вход отдаётся результат этой операции.
- `reject` — должна быть вызвана в случае ошибки. На вход, соответственно, отдаётся ошибка.

Эти функции принимают на вход ровно один аргумент, который затем передаётся либо в `then` (как данные), либо в `catch` (как ошибка). Причём достаточно, чтобы вызывалась хотя бы одна из этих функций. Вполне возможно, что понадобится создать промис, который всегда завершается успешно — и это легко сделать, никогда не вызывая `reject`.

В конечном итоге конструкция `new Promise()` возвращает самый настоящий промис, с которым можно работать уже привычным для нас способом:

```javascript
promise.then(console.log).catch(console.log);
```

А что, если нужно обернуть две асинхронных операции или три, или даже больше? Придётся оборачивать каждую из них независимо. Другими словами, одна асинхронная операция — один конструктор `new Promise`. Кстати, эту задачу можно автоматизировать, и в ноду встроена специальная функция, которая делает промисы из асинхронных функций:

```javascript
import util from "util";
import fs from "fs";

const stat = util.promisify(fs.stat);
stat(".")
  .then((stats) => {
    // Do something with `stats`
  })
  .catch((error) => {
    // Handle the error.
  });
```

Во фронтенде такое тоже возможно, достаточно "загуглить" пакет, предоставляющий функцию `promisify`.

В реальной жизни, встречаются задачи, когда асинхронного кода нет, но нужен промис, чтобы построить цепочку. Такой промис можно создать самостоятельно:

```javascript
const promise = new Promise((resolve) => resolve());
// promise.then ...
```

То же самое для промиса, который завершается неуспешно:

```javascript
const promise = new Promise((resolve, reject) => reject());
// promise.catch ...
```

Для этих задач добавили специальные сокращения, с которыми код становится чище:

```javascript
const promise1 = Promise.resolve();
// promise1.then

const promise2 = Promise.reject();
// promise2.catch ...
```

### Устройство

![Состояния промиса](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImQwZmNjYTc5MzYxNzk1YzliMWMyYWIxMTJhYzRiZjEzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=8f13394ac92efc37bbac457bda4aeb08b09174be09f487f06d48b4afaf5bd882)

С технической точки зрения, промис — это объект, имеющий три состояния (см. конечные автоматы и автоматное программирование): _pending_, _fulfilled_ и _rejected_. Промис начинается в состоянии _pending_, а затем, с помощью функций ("событий", как говорят в теории автоматов) `resolve` и `reject` переводится в одно из конечных (терминальных) состояний _fulfilled_ или _rejected_. Перейдя однажды в эти состояния, промис уже не может откатиться назад или уйти в другое терминальное состояние. То есть после вызова `resolve`, нет способа привести промис в состояние _rejected_, вызывая функцию `reject`.

---

##### Дополнительные материалы

1. [util.promisify](https://nodejs.org/api/util.html#util_util_promisify_original)
2. [Автоматное программирование](https://ru.hexlet.io/courses/js-abp)

## Async/Await—JS: Асинхронное программирование

Несмотря на все удобства, промисы не являются вершиной эволюции. Вспомним минусы, которые они добавляют:

- Своя собственная обработка ошибок, которая идёт в обход _try/catch_. Это значит, что в коде будут появляться оба способа обработки, комбинирующихся в причудливых формах
- Иногда бывает нужно передавать данные вниз по цепочке с самых верхних уровней, и с промисами делать это неудобно. Придётся создавать переменные вне промиса
- С промисами по-прежнему легко начать создавать вложенность, если специально за этим не следить

Все эти сложности убираются механизмом _async/await_, делающим код с промисами ещё более похожим на синхронный! Вспомним нашу задачу по объединению двух файлов. Вот её код:

```javascript
import fsp from "fs/promises";

const unionFiles = (inputPath1, inputPath2, outputPath) => {
  let data1;
  return fsp
    .readFile(inputPath1, "utf-8")
    .then((content) => {
      data1 = content;
    })
    .then(() => fsp.readFile(inputPath2, "utf-8"))
    .then((data2) => fsp.writeFile(outputPath, `${data1}${data2}`));
};
```

А теперь посмотрим на этот же код с использованием _async/await_. Подчеркну, что _async/await_ работает с промисами:

```javascript
import fsp from "fs/promises";

const unionFiles = async (inputPath1, inputPath2, outputPath) => {
  // Очень важный момент. Так же как и в примере выше, эти запросы выполняются строго друг за другом
  // (хотя при этом не блокируется программа, это значит, что другой код тоже может выполняться во время этих запросов)
  const data1 = await fsp.readFile(inputPath1, "utf-8");
  const data2 = await fsp.readFile(inputPath2, "utf-8");
  await fsp.writeFile(outputPath, `${data1}${data2}`);
};
```

Эта версия визуально практически не отличается от её синхронной версии. Код настолько простой, что даже не верится, что он асинхронный. Разберём его по порядку.

Первое, что мы видим, — это ключевое слово `async` перед определением функции. Оно означает, что данная функция всегда возвращает промис: `const promise = unionFiles(...)`. Причём теперь не обязательно возвращать результат из этой функции явно, он всё равно станет промисом.

Внутри функции используется ключевое слово `await`, которое ставится перед вызовом функций, которые, в свою очередь, тоже возвращают промисы. Если результат этого вызова присваивается переменной или константе, то в них записывается результат вызова. Если присвоения нет, как в последнем вызове `await`, то происходит ожидание выполнения операции без использования её результата.

Асинхронность в данном случае (как и в промисах) гарантирует нам, что программа не блокируется ожидая завершения вызовов, она может продолжать делать что-то еще (но не в этой функции). Но она не гарантирует параллельности. Более того, подряд идущие `await` в рамках одной функции всегда выполняются строго друг за другом. Проще всего это понимать, если представлять код как цепочку промисов, где каждая следующая операция выполняется внутри `then`.

А что с обработкой ошибок? Теперь достаточно поставить обычные _try/catch_ и ошибки будут отловлены!

```javascript
import fsp from "fs/promises";

const unionFiles = async (inputPath1, inputPath2, outputPath) => {
  try {
    const data1 = await fsp.readFile(inputPath1, "utf-8");
    const data2 = await fsp.readFile(inputPath2, "utf-8");
    await fsp.writeFile(outputPath, `${data1}${data2}`);
  } catch (e) {
    console.log(e);
    throw e; // снова бросаем, потому что вызывающий код должен иметь возможность отловить ошибку
  }
};
```

Однако, при параллельном выполнении промисов не обойтись без функции `Promise.all`:

```javascript
const unionFiles = async (inputPath1, inputPath2, outputPath) => {
  // Эти вызовы начинают чтение почти одновременно и не ждут друг друга
  const promise1 = fsp.readFile(inputPath1, "utf-8");
  const promise2 = fsp.readFile(inputPath2, "utf-8");
  // Теперь дожидаемся когда они оба завершатся
  // Данные можно сразу разложить
  const [data1, data2] = await Promise.all([promise1, promise2]);
  await fsp.writeFile(outputPath, `${data1}${data2}`);
};
```

Подводя итог, механизм _async/await_ делает код максимально плоским и похожим на синхронный. Благодаря ему появляется возможность использовать _try/catch_, и легко манипулировать данными полученными в результате асинхронных операций.

```javascript
// Код на колбеках
import fs from "fs";

fs.readFile("./first", "utf-8", (error1, data1) => {
  if (error1) {
    console.log("boom!");
    return;
  }
  fs.readFile("./second", "utf-8", (error2, data2) => {
    if (error2) {
      console.log("boom!");
      return;
    }
    fs.writeFile("./new-file", `${data1}${data2}`, (error3) => {
      if (error3) {
        console.log("boom!");
      }
    });
  });
});

// Код на промисах
import fsp from "fs/promises";

let data1;
fsp
  .readFile("./first", "utf-8")
  .then((d1) => {
    data1 = d1;
    return fsp.readFile("./second", "utf-8");
  })
  .then((data2) => fsp.writeFile("./new-file", `${data1}${data2}`))
  .catch(() => console.log("boom!"));

// Код на async/await
import fsp from "fs/promises";

// В реальной жизни чтение файлов лучше выполнять параллельно, как в функции unionFiles выше
const data1 = await fsp.readFile("./first", "utf-8");
const data2 = await fsp.readFile("./second", "utf-8");
await fsp.writeFile("./new-file", `${data1}${data2}`);
```

---

##### Дополнительные материалы

1. [Пример реального кода из проектов Хекслета](https://github.com/Hexlet/hexlet-exercise-kit/blob/master/import-documentation/src/index.js)

## HTTP-запросы—JS: Асинхронное программирование

Асинхронность всегда возникает там, где есть операции ввода/вывода, к которым относятся не только файловые операции, но и любое сетевое взаимодействие. В первую очередь это касается запросов по HTTP, без которых не обходится практически ни одно веб-приложение. А фронтенд только и делает, что выполняет запросы к серверу.

Для понимания этого урока, нужно представлять как работает HTTP API. Если вы не знакомы с этой концепцией, то прочитайте наш гайд [Что такое API](https://guides.hexlet.io/http-api/)

Асинхронность в сетевых запросах возникает естественным образом. Серверу нужно какое-то время на то, чтобы принять запрос, обработать и вернуть ответ обратно. Причём ответ может и не дойти в случае ошибок сети.

На низком уровне HTTP-запрос и HTTP-ответ — это всего лишь текст, посылаемый к серверу и от сервера обратно клиенту:

```
GET / HTTP/1.1
HOST: ru.hexlet.io


HTTP/1.1 200 OK
Date: Mon, 27 Jul 2020 12:28:53 GMT
Server: Nginx/2.2.14 (Win32)
Last-Modified: Wed, 22 Jul 2020 19:15:56 GMT
Content-Length: 666
Content-Type: text/html
Connection: Closed
```

В прикладном коде реальная структура запроса и ответа скрывается для более удобного управления. Сами же запросы выполняются с помощью HTTP-клиентов, библиотек, задача которых сводится к выполнению запросов и обработке ответов по HTTP. В мире JavaScript (фронтенд и бекенд) для этого используют библиотеку [axios](https://github.com/axios/axios). Ниже простой пример:

```javascript
import axios from "axios";

// Не забываем, что функция асинхронная
const fn = async () => {
  // GET-запрос сайта Хекслета
  const response = await axios.get("https://ru.hexlet.io");
  console.log(response.status); // код ответа
  console.log(response.headers); // напечатает заголовки
  console.log(response.data); // тело ответа
};
```

Интерфейс работы этой библиотеки крайне прост. Для каждого метода HTTP внутри нее определен соответствующий метод объекта `axios`. В примере выше используется `get()`, но также можно использовать `post()`, `delete()` и другие. Первым параметром каждый из этих методов принимает URL. Последующие параметры варьируются в зависимости от смысла методов. Сами методы асинхронны, поэтому их использование обычно сопровождается _async/await_.

В свою очередь, результатом любого запроса будет объект Response, представляющий собой ответ сервера. Для удобства использования, в этом объекте хранится не только "сырой" ответ, но и данные ответа, подготовленные для удобной обработки. Например, для получения статуса ответа достаточно обратиться к свойству `response.status`.

Для выполнения POST-запроса нужно воспользоваться методом `post()`. Вторым параметром этот метод принимает объект с данными, который отправится на сервер. Axios достаточно умная библиотека, чтобы самостоятельно представить этот объект в виде текста (как часть тела запроса) и установить все нужные заголовки для его обработки (например, content-length или content-type).

```javascript
const fn = async () => {
  const data = {
    email: "mysuper@email.com",
    firstName: "Ivan",
  };
  // axios сам упакует данные в json
  const response = await axios.post("https://ru.hexlet.io/u/new", data);
};
```

Как правило, HTTP-запросы не выполняются пачками. В реальном коде, действия пользователя, такие как отправка формы или загрузка данных приводят к одному простому запросу. Поэтому хоть здесь и используется асинхронность, сложности такой код практически не добавляет. А благодаря _async/await_ код в принципе выглядит, как синхронный.

## Дополнительные материалы

### [JS: Асинхронное программирование](https://ru.hexlet.io/courses/js-asynchronous-programming)

1. [Введение](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/init/theory_unit)
   - Без материалов
2. [Стек вызовов (Call Stack)](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/call-stack/theory_unit)
   - [Стек](https://ru.wikipedia.org/wiki/Стек)
   - [Стек вызовов](https://ru.wikipedia.org/wiki/Стек_вызовов)
3. [Асинхронный код](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/asynchronous-code/theory_unit)
   - [синхронная функция readFileSync из модуля fs](https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options)
   - [асинхронная функция readFile из модуля fs](https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback)
4. [Возврат в асинхронном коде](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/asynchronous-return/theory_unit)
   - Без материалов
5. [Упорядочивание асинхронных операций](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/asynchronous-flow/theory_unit)
   - [Итеративный процесс](https://ru.hexlet.io/courses/introduction_to_programming/lessons/iterative/theory_unit)
6. [Обработка ошибок](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/error-handling/theory_unit)
   - Без материалов
7. [Параллельное выполнение операций](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/parallel-execution/theory_unit)
   - [async — библиотека для работы в асинхронном стиле](https://caolan.github.io/async/)
8. [Таймеры](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/timers/theory_unit)
   - [setTimeout](https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout)
   - [setInterval](https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/setInterval)
9. [Промисы (Promise)](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/promises/theory_unit)
   - [promisejs.org](https://www.promisejs.org/)
10. [Обработка ошибок в промисах](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/promises-catch/theory_unit)
    - Без материалов
11. [Цепочка промисов](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/chain-of-promises/theory_unit)
    - Без материалов
12. [Promise.all](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/promise-all/theory_unit)
    - [Promise.all](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
13. [new Promise](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/new-promise/theory_unit)
    - [util.promisify](https://nodejs.org/api/util.html#util_util_promisify_original)
    - [Автоматное программирование](https://ru.hexlet.io/courses/js-abp)
14. [Async/Await](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/async-await/theory_unit)
    - [Пример реального кода из проектов Хекслета](https://github.com/Hexlet/hexlet-exercise-kit/blob/master/import-documentation/src/index.js)
15. [HTTP-запросы](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/http/theory_unit)
    - Без материалов
