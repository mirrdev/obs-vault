## Синтаксис—JS: Объекты

Объект – тип данных в JavaScript, с помощью которого представляют связанный набор данных. Это позволяет оперировать данными как единым целым. Например, любой объект реального мира можно описать объектом в JavaScript. То же самое относится и к математическsим объектам, например — фигурам.

```javascript
const user = { name: "Vasya", married: true, age: 25 };

const rectangle = { width: 10, height: 5 };
```

Объект описывается как перечисление ключей и значений через запятую в фигурных скобках. Ключи в объектах называются свойствами (property). Они уникальны, то есть в одном объекте не может быть двух одинаковых свойств, имеющих разные значения.

Если свойств много, то определение можно растянуть на несколько строк:

```javascript
const user = {
  name: "Vasya",
  married: true,
  age: 25,
};
```

Запятая в конце не обязательна, но [рекомендуется линтером](https://eslint.org/docs/rules/comma-dangle). Это удобно при добавлении или удалении ключей. Не придется менять окончание последней строчки.

Для обращения к свойствам объектов используется точечный синтаксис:

```javascript
user.name; // 'Vasya'
rectangle.width; // 10
```

Иногда по ошибке или намеренно обращаются к свойствам, которых в объекте нет. В этом случае JavaScript возвращает `undefined`, и продолжает работать как ни в чем не бывало. Такое поведение может приводить к трудноотловимым ошибкам, поэтому будьте осторожны и всегда проверяйте написание свойств, если возвращаются не те данные, или данных нет:

```javascript
user.nme; // undefined
user.name; // 'Vasya'
```

JavaScript поддерживает альтернативный способ обращения к свойствам объектов – через квадратные скобки — как в массивах:

```javascript
// имена свойств хранятся внутри объекта в виде строк.
user["name"]; // 'Vasya'
rectangle["width"]; // 10
user["company"]; // undefined
```

Зачем нужен такой способ доступа? В реальном использовании объектов часто встречаются алгоритмы, когда имя свойства может меняться в процессе обработки. Обращение к свойству через точку не позволяет задавать имя динамически, а способ через скобки — позволяет:

```javascript
const user = { name: "Vasya", married: true, age: 25 };

let propertyName = "name";
user[propertyName]; // 'Vasya'

propertyName = "married";
user[propertyName]; // true
```

Подробнее про такое использование мы поговорим в одном из следующих уроков.

---

#### Самостоятельная работа

1. Запустите REPL
2. Создайте внутри него объект, выполните обращение к его свойствам разными способами

---

#### Дополнительные материалы

1. [Документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object)

## Модификация—JS: Объекты

Для создания и обновления значений свойств в объекте используется одна и та же операция — присваивание. Для несуществующих свойств она запишет новый элемент, для существующих — перезапишет новым значением:

```javascript
const user = { name: "Vasya", married: true, age: 25 };

user.married = false;
// То же самое
// user['married'] = false;

user.surname = "Petrov";
// То же самое
// user['surname'] = 'Petrov';

console.log(user);
// => { name: 'Vasya', married: false, age: 25, surname: 'Petrov' }
```

Несмотря на то, что объект объявлен как константа, он меняется. Причина такого поведения точно такая же, как и в случае массивов. В константе хранится не сам объект, а ссылка на него. Это значит, что менять объект можно, но заменить объект на другой – нельзя:

```javascript
const user = { name: "Maria" };
user.name = "Igor";

// Возникнет ошибка
user = { name: "Mike" }; // Boom!
```

Подробнее об этом - в одном из следующих уроков.

Изменяемость объектов позволяет наполнять их постепенно. То есть мы можем создать пустой объект и затем расширить его нужными свойствами:

```javascript
const course = {};

course.name = "Хекслет – JS: Объекты";
course.description = "Самый классный курс на свете, не проходите мимо, дети!";

console.log(course.name); // 'Хекслет – JS: Объекты'

console.log(course);
// {
//   name: 'Хекслет – JS: Объекты',
//   description: 'Самый классный курс на свете, не проходите мимо, дети!'
// }
```

Удалить элемент из объекта можно с помощью оператора `delete`:

```javascript
const user = { name: "Vasya", wrongProp: "bug" };

delete user.wrongProp;

console.log(user);
// => { name: 'Vasya' }
```

Несмотря на наличие удаления, удалять свойства из объекта плохая практика. Как вы увидите далее, любую задачу можно решить без удаления и главное, что такой код будет лучше.

https://repl.it/@hexlet/js-objects-syntax-add-update-delete-values

## Ссылки—JS: Объекты

Объекты – ссылочный тип данных. То есть переменные и константы хранят не сами объекты (их данные), а ссылку на них. Поэтому возникает ощущение, что константы в JavaScript изменяемы, но это не так. Главное понимать, что константа связана со ссылкой, а не с данными в случае объекта:

```javascript
const company = {};

// Поменять объект можно
company.name = "Hexlet";

// Заменить ссылку нельзя
company = {}; // Boom!

let object = {};

// А так можно
object = {};
```

Ссылочная природа влияет и на сравнение. Объекты равны между собой не тогда, когда у них одинаковая структура, а когда это один и тот же объект:

```javascript
const company = { name: "Hexlet" };

company === { name: "Hexlet" }; // false

const copyOfCompany = company; // передается ссылка

// Это одно и то же
copyOfCompany === company; // true

// Меняя одно, меняем и другое
company.createdAt = 2012;

console.log(copyOfCompany); // { name: 'Hexlet', createdAt: 2012 }
```

Каждое объявление объекта (в том числе пустого), создает новый объект. Поэтому даже два пустых объекта никогда не равны друг другу:

```javascript
{} === {}; // false
```

Больше всего ссылочная природа объектов влияет на их работу с функциями. Любой объект, передаваемый в функцию, попадает туда по ссылке. Изменение такого объекта внутри функции меняет его и снаружи:

```javascript
const changeObj = (o) => {
  o.key = "value";
};

const obj = {};

changeObj(obj);
console.log(obj); // { key: 'value' };
```

## Объекты в действии—JS: Объекты

Рассмотрим пример, в котором используется объект. Напишем функцию, которая принимает на вход путь до файла и возвращает информацию об этом файле в виде объекта.

```javascript
const filepath = "/path/to/index.js";
const fileinfo = getFileInfo(filepath);
// {
//     extension: js
//     filename: index.js
// };
```

В Node.js встроен модуль _path_, который может быстро извлечь нужные данные. Именно им и нужно пользоваться при написании реального кода, здесь же мы фокусируемся не на способе получения данных, а на формировании объекта.

Для начала нам нужно извлечь имя файла. Это можно сделать, используя метод `split()`.

```javascript
import _ from "lodash";

// Разделяем путь на промежуточные директории и файл
const parts = filepath.split("/");
// Извлекаем имя файла
// last извлекает последний элемент из массива
const filename = _.last(parts);
```

Затем, точно таким же способом, можно получить и расширение:

```javascript
const extension = _.last(filename.split("."));
```

Теперь, объединяя все вместе, реализуем нужную функцию:

```javascript
const getFileInfo = (filepath) => {
  const parts = filepath.split("/");
  const filename = _.last(parts);
  const extension = _.last(filename.split("."));

  // В значения вместо переменных подставятся нужные значения
  const info = { filename: filename, extension: extension };

  return info;
};
```

В примере выше объект создается сразу, когда все данные уже готовы. Иногда делают по-другому, инициализируют объект в самом начале и постепенно наполняют его данными:

```javascript
const getFileInfo = (filepath) => {
  // Инициализация объекта
  const info = {};

  const parts = filepath.split("/");
  const filename = _.last(parts);
  info.filename = filename;

  const extension = _.last(filename.split("."));
  info.extension = extension;

  return info;
};
```

Какой способ предпочесть? В подавляющем большинстве ситуаций первый способ лучше. Когда объект создается сразу со всеми данными, то его структура очевидна с первого взгляда. Во втором примере придется пробежаться глазами по всему коду чтобы понять что же получится в итоге. С другой стороны, второй способ нужен в ситуациях, когда объект заполняется по условиям, которые могут не выполняться:

```javascript
// Добавляем свойство в объект только если расширение существует
if (extension) {
  info.extension = extension;
}
```

Такое встречается значительно реже, но все же бывает.

## Упрощенный синтаксис создания объектов

Когда объект создается сразу наполненным данными, то он часто выглядит так, как в примерах выше:

```javascript
const info = { filename: filename, extension: extension };
```

Обратите внимание на совпадение имени ключа и имени константы, которая содержит значение для данного ключа. Это настолько распространенный способ создания объектов, что в JavaScript добавили специальный, упрощенный синтаксис создания объектов. Если имя константы соответствует имени свойства в объекте, то можно просто добавить имя константы в определение объекта без указания свойства:

```javascript
const info = { filename, extension };
```

Как показывает жизнь, этот подход оказался очень удобным и практичным. К тому же он сочетается с обычным способом создать объект. JavaScript позволяет миксовать разные способы определения в рамках одного объекта:

```javascript
const filename = "hexlet";
const ext = "jpg";

const info = { filename, extension: ext };
// Порядок не важен, можно было и так
const info = { extension: ext, filename };

// В результате получится
// const info = { filename: 'hexlet', extension: 'jpg' };
```

## Проверка существования свойства—JS: Объекты

В работе с объектами иногда бывает нужно проверить наличие свойства и выполнить особую логику в случае его отсутствия. Проще всего такая проверка выполняется через сравнение с `undefined`, но этот подход не универсальный. При определенных условиях он сработает неверно.

```javascript
if (obj.key === undefined) {
  // логика
}
```

Представьте себе функцию, которая должна посчитать количество повторяющихся элементов в массиве:

```javascript
// Вход

const bag = [
  "apple",
  "banana",
  "pear",
  "apricot",
  "apple",
  "banana",
  "apple",
  "orange",
  "pear",
];

// Выход

const result = {
  apple: 3,
  banana: 2,
  pear: 2,
  orange: 1,
  apricot: 1,
};
```

Алгоритм ее работы достаточно прост, но есть один тонкий момент. Во время обхода массива эта функция берет объект-результат, извлекает из него нужное свойство и увеличивает значение на единицу. Но это в случае, когда свойство уже есть. А если его нет? Так как изначально объект-результат пустой, то когда элемент массива появляется первый раз, в объекте нужно создавать соответствующее свойство со значением 1. Посмотрите на реализацию:

```javascript
const countFruits = (fruits) => {
  const result = {};

  for (const name of fruits) {
    // Проверка на существование
    if (result[name] === undefined) {
      result[name] = 1;
    } else {
      result[name] += 1;
    }
  }

  return result;
};
```

В подобной ситуации сравнение значения с `undefined` сработает всегда, но только потому, что `undefined` не может оказаться внутри существующего свойства. Но бывает и по-другому. Посмотрите на код:

```javascript
const obj = {
  key: doSomething(),
};
```

В примере выше значением `key` станет результат вызова функции `doSomething()`. Если эта функция может вернуть `undefined`, то окажется, что в объекте ключ `key` определен, но его значение `undefined`.

В JavaScript есть более надежный и более правильный по смыслу способ проверить существование свойства, не сравнивая значения – это метод [Object.hasOwn()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn). Вот как меняется функция `countFruits()`, если использовать это свойство:

```javascript
const countFruits = (fruits) => {
  const result = {};

  for (const name of fruits) {
    // Проверка на существование
    if (Object.hasOwn(result, name)) {
      result[name] += 1;
    } else {
      result[name] = 1;
    }
  }

  return result;
};
```

## Оператор нулевого слияния

Конкретно в нашем примере с поиском фруктов, внутри результирующего объекта не может оказаться `undefined` просто так в качестве значения. Там всегда будет какое-то число, начиная от единицы. Более того, даже проверка на наличие значения лишняя. Всё, что нам нужно – извлекать текущее значение с возможностью задать значение по умолчанию. Сделать это можно, воспользовавшись [оператором нулевого слияния](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator). Он позволяет задать значение по умолчанию в случае, когда оно равно `null` или `undefined`.

```javascript
let value;

value ?? "wow"; // 'wow'

value = null;
value ?? "wow"; // 'wow'

value = true;
value ?? "wow"; // true
for (const name of fruits) {
  result[name] = (result[name] ?? 0) + 1;
}
```

---

#### Дополнительные материалы

1. [Функция has из библиотеки Lodash](https://lodash.com/docs/#has)

## Обход свойств объекта—JS: Объекты

Объект в JavaScript, в отличие от массива, не является коллекцией. Его нельзя обходить как обычный массив с помощью цикла _for..of_, хотя подобная задача иногда возникает. Например, когда мы хотим распечатать все свойства на экран, или когда свойства в объект добавляются динамически — то есть их имена могут меняться в процессе жизни объекта.

В JavaScript для обхода объектов есть несколько способов. Самый простой – использовать конструкцию _for..in_, которая очень похожа на обычный цикл.

```javascript
const course = { name: "JS: React", slug: "js-react" };
for (const prop in course) {
  console.log(`course.${prop} = ${course[prop]}`);
}
// course.name = JS: React
// course.slug = js-react
```

Несмотря на простоту использования, _for..in_ работает не совсем так, как может показаться. _for..in_ выводит не только свойства самого объекта, но и свойства, добавленные в прототип этого объекта. Эту тему мы пока не проходили и дается она позже, но если в двух словах, то объекты в JavaScript могут быть связаны друг с другом и обращение к свойству в одном объекте может приводить к обращению (неявному) к свойству в другом объекте (прототипе). Мы уже сталкивались с таким поведением на практике, но пока обходили этот вопрос стороной.

Главное, что сейчас нужно понимать, в подавляющем большинстве случаев это нежелательное поведение. Именно поэтому _for..in_ используется не так часто, как может показаться. Гораздо более распространенный способ – обходить ключи. Метод `Object.keys(obj)` позволяет получить массив всех ключей объекта:

```javascript
const course = { name: "JS: React", slug: "js-react" };

const keys = Object.keys(course); // [ 'name', 'slug' ]
```

Далее мы можем обойти в цикле массив ключей и получить нужные значения. На практике, обычно, сначала получают массив ключей и что-то с ним делают. Например, фильтруют, отбирая только нужные ключи, а затем обрабатывают исходный объект или создают новый, получая в цикле значение по ключу.

```javascript
for (const key of keys) {
  console.log(course[key]);
}
```

Если ключи в процессе обхода не используются, то можно сразу получить массив значений свойств объекта. Это делает метод `Object.values(obj)`:

```javascript
const course = { name: "JS: React", slug: "js-react" };

const values = Object.values(course); // [ 'JS: React', 'js-react' ]

for (const value of values) {
  console.log(value);
}
```

Ну, и последний вариант, метод, который возвращает сразу ключи и значения объекта. То есть каждый элемент сам будет массивом, содержащим ключ и соответствующее ему значение — `[ key, value ]`. За это отвечает метод `Object.entries(obj)`:

```javascript
const course = { name: "JS: React", slug: "js-react" };

const entries = Object.entries(course);
// [[ 'name', 'JS: React' ], [ 'slug', 'js-react' ]]
```

Обойти такой массив циклом `for...of` не составит никакого труда, а деструктуризация позволит сделать это красиво:

```javascript
for (const [key, value] of entries) {
  console.log(key);
  console.log(value);
}
```

Рассмотрим пример. Реализуем функцию `findKeys()`, которая возвращает список ключей объекта, значение которых равно переданному значению:

```javascript
const lessonMembers = {
  syntax: 3,
  using: 2,
  foreach: 10,
  operations: 10,
  destructuring: 2,
  array: 2,
};

findKeys(lessonMembers, 10); // ['foreach', 'operations']
findKeys(lessonMembers, 3); // ['syntax']
```

Логика работы функции выглядит так:

1. Обходим свойства объекта
2. Если значение в свойстве совпадает с переданным, то добавляем ключ в результат

```javascript
const findKeys = (obj, expectedValue) => {
  const result = [];

  const entries = Object.entries(obj);
  for (const [key, value] of entries) {
    if (value === expectedValue) {
      result.push(key);
    }
  }

  return result;
};
```

https://repl.it/@hexlet/js-objects-for-of-find-keys

## Порядок ключей

Одна из ключевых особенностей массива – наличие строгого порядка, в котором следуют элементы. В объектах это не так, порядок какой-то есть, но им нельзя управлять. Этот порядок базируется на внутренних правилах работы JavaScript. Если нам важен порядок, то для этого придется вводить дополнительный массив, в котором будет храниться список ключей в том порядке, в котором мы хотим получить вывод.

## Вложенные объекты—JS: Объекты

Значением свойства объекта может быть всё, что угодно, включая другой объект или массив:

```javascript
const user = { name: "Vasya", married: true, age: 25 };

// Добавим свойство friends со списком друзей
user.friends = ["Kolya", "Petya"];

// Добавим свойство children со списком детей,
// каждый ребёнок представлен отдельным объектом
user.children = [
  { name: "Mila", age: 1 },
  { name: "Petr", age: 10 },
];

// Добавим вложенный объект
user.company = { name: "Hexlet" };

console.log(user); // =>
// { name: 'Vasya',
//   married: true,
//   age: 25,
//   friends: [ 'Kolya', 'Petya' ],
//   company: { name: 'Hexlet' },
//   children: [ { name: 'Mila', age: 1 }, { name: 'Petr', age: 10 } ] }
```

Все то же самое можно определить сразу при создании объекта:

```javascript
const user = {
  name: "Vasya",
  married: true,
  age: 25,
  friends: ["Kolya", "Petya"],
  children: [
    { name: "Mila", age: 1 },
    { name: "Petr", age: 10 },
  ],
  company: {
    name: "Hexlet",
  },
};
```

В этом случае обращение к вложенным элементам происходит по цепочке:

```javascript
user.friends[1]; // 'Petya'
user.children[0].name; // 'Mila'
user.company.name; // 'Hexlet'
```

## Печать на экран

В `console.log()` встроено одно ограничение. Если в объекте есть другие объекты на глубине больше второго уровня вложенности, то при выводе такого объекта на экран вместо объектов отобразится строка `[Object]`, а вместо массива `[Array]`.

```javascript
const obj = { a: { b: { c: { key: "value" }, e: [1, 2] } } };
console.log(obj);
// { a: { b: { c: [Object], e: [Array] } } }
```

Для вывода таких объектов можно воспользоваться функцией преобразования в JSON:

```javascript
console.log(JSON.stringify(obj));
// {"a":{"b":{"c":{"key":"value"},"e":[1,2]}}}

// Или форматированный вывод
console.log(JSON.stringify(obj, null, "  "));
// {
//   "a": {
//     "b": {
//       "c": {
//         "key": "value"
//       },
//       "e": [
//         1,
//         2
//       ]
//     }
//   }
// }
```

## Проверки в глубину

При работе с вложенными объектами резко усложняется задача проверки существования ключей. Приходится строить цепочку из условий до нужного свойства. Представьте, что нам нужно добраться до 4 уровня вложенности и мы не уверены в том, что существуют все промежуточные объекты:

```javascript
// Добираемся до obj.one.two.three
if (Object.hasOwn(obj, "one")) {
  if (Object.hasOwn(obj.one, "two")) {
    if (Object.hasOwn(obj.one.two, "three")) {
      // ...
    }
  }
}
```

Так будет выглядеть решение в лоб. Однако, есть более удобный способ, речь о котором ниже.

### Оператор опциональной последовательности

Если задача состоит в том, чтобы извлечь данные, а не просто проверить их существование, то можно пойти другим путем. В Javascript встроен [оператор опциональной последовательности](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (optional chaining), который позволяет извлекать вложенные данные без проверок:

```javascript
const obj = {};
obj?.one?.two?.three; // undefined
```

Этот оператор никогда не приводит к ошибке. Он работает на любых типах данных и всегда возвращает либо `undefined`, либо значение указанного свойства, если оно существует.

### Оператор нулевого слияния

С помощью [оператора нулевого слияния](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator), можно не только получить значение цепочки любой вложенности, но и определить значение по умолчанию для него.

```javascript
const obj = {};
obj?.one?.two?.three ?? "defaultValue"; // 'defaultValue'
```

Значение по умолчанию возвращается только в том случае, когда слева `undefined` или `null`. В этом смысле данный оператор совсем не похож на логическое сравнение `||`:

```javascript
const value = false;

value ?? "default"; // false
value || "default"; // 'default'
```

### get (lodash)

Последний пример перегружен символами и выглядит достаточно сложно. Как альтернативу можно использовать функцию `get()` библиотеки Lodash.

```javascript
import _ from "lodash";

const obj = {};

const value = _.get(obj, "one.two.three", "defaultValue"); // 'defaultValue'
```

`get()` особенно удобен в случае динамических ключей. В таком случае вторым аргументом можно передать массив ключей:

```javascript
_.get(obj, ["one", "two", "three"], "defaultValue"); // 'defaultValue'
```

---

#### Дополнительные материалы

1. [Функция get из библиотеки Lodash](https://lodash.com/docs/#get)

## Слияние—JS: Объекты

Слияние (merge) – операция над объектами, выполняющая их объединение. Она появляется там, где необходимо данные одного объекта перенести в другой объект.

Слияние часто используется при работе с веб-формами. Например, когда пользователь меняет свои персональные данные в настройках аккаунта, измененные данные приходят в приложение в виде объекта. Данные из этого объекта нужно перенести в объект пользователя. Так происходит обновление пользователя:

```javascript
// Такой пользователь есть в системе
const user = { name: "Tirion", email: "support@hexlet.io", age: 44 };

// Из формы пришли данные
const data = { name: "Tirion 2", age: 33 };

// В результате должно получиться
// { name: 'Tirion 2', email: 'support@hexlet.io', age: 33 };
```

Решение в лоб – перенести каждое свойство отдельно:

```javascript
user.name = data.name;
user.age = data.age;

// Где-то тут сохраняем пользователя в базе данных
```

Прямой перенос хорошо работает, когда данных мало и их структура не меняется. Если же данных много или в разные моменты времени могут приходить разные данные, то это превращается в кучу одинакового кода:

```javascript
if (Object.hasOwn(data, "name")) {
  user.name = data.name;
}

// И так нужно перечислить все возможные свойства
```

С помощью слияния (часто говорят "мержа") мы можем сократить все до одной строчки:

```javascript
Object.assign(user, data);
console.log(user);
// => { name: 'Tirion 2', email: 'support@hexlet.io', age: 33 };
```

Функция [Object.assign()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) берёт объект, переданный первым параметром, и переносит в него всё из объектов, переданных остальными параметрами. В нашей ситуации это один объект, переданный вторым параметром.

Слияние работает так. Если какое-то свойство было только в первом объекте, то оно остается тем, что и было. Если свойство присутствует во втором (и далее) объекте, то оно записывается в первый независимо от того, было оно там или нет. Поэтому, если свойство присутствовало и в первом объекте и во втором, то оно будет перезаписано значением из второго объекта:

```javascript
const obj1 = { a: "a", b: "b" };
const obj2 = { c: "c", b: "v" };
Object.assign(obj1, obj2);
console.log(obj1);
// => { a: 'a', b: 'v', c: 'c' }
```

У функции `Object.assign()` есть одно ограничение: она выполняет только _поверхностное_ слияние. Вложенные объекты не сравниваются, а просто заменяются:

```javascript
const obj1 = { a: { a: 1 } };
const obj2 = { a: { b: 1 } };
Object.assign(obj1, obj2);
console.log(obj1);
// => { a: { b: 1 } }
```

Как и любой другой мощный механизм, слияние нуждается в аккуратном использовании. В объектах бывают поля, которые не должны быть перезаписаны при слиянии, например, количество денег на счету у пользователя. Если не контролировать состав данных из второго объекта, то туда могут попасть свойства (случайно или злонамеренно), которые приведут к перезаписыванию важных свойств.

_Если говорить про веб-формы, то технически всегда можно послать больше данных, чем описано в форме._

---

#### Дополнительные материалы

1. [Функция has из библиотеки Lodash](https://lodash.com/docs/#has)

## Клонирование (копирование)—JS: Объекты

Клонирование объектов — ещё одна часто встречающаяся операция в разработке, особенно во фронтенде. При клонировании создается копия исходного объекта, то есть новый объект, но наполненный теми же данными.

В JavaScript нет встроенной функции для выполнения клонирования, но его можно эмулировать с помощью `Object.assign()`. Для этого достаточно первым параметром передать пустой объект, а вторым тот, который нужно клонировать:

```javascript
const user = { name: "Tirion", email: "support@hexlet.io", age: 44 };

// данные из user копируются во вновь созданный объект
const copyOfUser = Object.assign({}, user);

user === copyOfUser; // false
```

В результате получаются два разных объекта, имеющих одно и то же содержимое. Так как они разные, то изменения в одном не трогают изменения в другом.

Клонирование также выполняют с помощью функции [clone()](https://lodash.com/docs#clone) библиотеки _lodash_. Несмотря на то, что ее результат идентичен примерам выше, благодаря своему имени она лучше выражает смысл операции.

```javascript
import _ from "lodash";

const user = { name: "Tirion", email: "support@hexlet.io", age: 44 };
const copyOfUser = _.clone(user);
```

Клонирование способом, приведенным выше, не затрагивает вложенные объекты. Они оказываются в новом объекте по ссылке из старого.

```javascript
const user = { company: { name: "Hexlet" } };
const copyOfUser = Object.assign({}, user);
// Это тот же объект
user.company === copyOfUser.company; // true

user.company.createdAt = 2012;
console.log(copyOfUser.company.createdAt); // 2012
```

Такое клонирование называется _поверхностным_ (shallow). Очень важно запомнить, что именно это имеют ввиду в JavaScript, когда употребляют термин "клонирование". Само по себе это не плохо, поверхностное клонирование подходит для многих ситуаций. Там где его недостаточно, нужно использовать полное клонирование, которое называют глубоким (deep).

В JavaScript нет встроенного способа клонировать объекты полностью. Поэтому у разработчиков принято использовать готовую функцию [cloneDeep()](https://lodash.com/docs#cloneDeep) из библиотеки _lodash_.

```javascript
import _ from "lodash";

const user = { company: { name: "Hexlet" } };
const copyOfUser = _.cloneDeep(user);

user.company === copyOfUser.company; // false
```

У полного копирования есть один серьёзный недостаток. Если объект большой и имеет сложную структуру, то полное копирование может сильно влиять на производительность. Это одна из причин, почему такое копирование не выполняется по умолчанию.

## spread и создание новых объектов—JS: Объекты

Поверхностное копирование (clone) и слияние (merge) можно объединить в одну операцию. Это позволяет "обновлять" объекты в функциональном стиле, другими словами мы создаем новые объекты на основе старых, вместо их обновления. Подробнее с такими задачами мы познакомимся ближе к концу профессии, когда пойдет речь про фреймворки. Ниже пример такой операции:

```javascript
const user = { name: "Tirion", email: "support@hexlet.io", age: 44 };
const data = { name: "Tirion 2", age: 33 };

// Новый объект с данными user дополненными данными из data
const copyOfUser = Object.assign({}, user, data);
```

В современном JavaScript добавили специальный оператор, который позволяет выполнять ту же задачу немного короче и, главное, нагляднее. Он называется **spread оператор** (на русском его так и называют "спред оператор"). Простое поверхностное копирование с помощью спреда:

```javascript
// Поверхностное копирование
const copyOfUser = { ...user };
// Object.assign({}, user);
```

https://repl.it/@hexlet/js-objects-spread-operator-using

Spread оператор – это три точки перед именем переменной (или константы), внутри определения объекта. Он раскладывает соответствующий объект внутри нового объекта. С его помощью можно получить только копию, он не может изменять существующие объекты.

С помощью spread оператора легко расширять новые объекты дополнительными данными:

```
const user = { name: 'Vasya', age: 11 };

const newUser = { ...user, married: true, age: 25 };
// Возраст поменялся
console.log(newUser); // => { name: 'Vasya', married: true, age: 25 }
```

https://repl.it/@hexlet/js-objects-spread-operator-construction

Всё, что появляется с правой стороны спреда, будет иметь приоритет при слиянии, аналогично тому как работает `Object.assign()`. В свою очередь всё что слева — имеет более низкий приоритет:

```javascript
const user = { name: "Vasya", age: 11 };

const newUser = { age: 25, married: true, ...user };
// Возраст остался тем же
console.log(newUser); // => { name: 'Vasya', married: true, age: 11 }
```

Свойства могут одновременно появляться как слева так и справа от этого оператора:

```javascript
const user = { name: "Vasya", age: 11 };

const newUser = { age: 25, ...user, married: true };
// Возраст остался тем же
console.log(newUser); // => { name: 'Vasya', married: true, age: 11 }
```

Сам спред оператор может использоваться в рамках одного объекта любое количество раз:

```javascript
const user = { name: "Vasya", married: true, age: 25 };
const user2 = { name: "Irina", surname: "Petrova" };

const mergedObject = { ...user, ...user2 };
console.log(mergedObject);
// => { name: 'Irina', married: true, age: 25, surname: 'Petrova' }

// В обратном порядке
const mergedObject2 = { ...user2, ...user };
console.log(mergedObject2);
// => { name: 'Vasya', surname: 'Petrova', married: true, age: 25 }
```

https://repl.it/@hexlet/js-objects-spread-operator-merge-with-same-keys

Наконец, можно объединить и новые свойства и несколько спредов вместе:

```javascript
const user = { name: "Irina", age: 25, married: false };
const user2 = { name: "Petya", surname: "Ivanov" };

const newUser = { ...user, married: true, ...user2 };
console.log(newUser);
// => { name: 'Petya', age: 25, married: true, surname: 'Ivanov' }
```

https://repl.it/@hexlet/js-objects-spread-operator-flexible

## Деструктуризация—JS: Объекты

Объекты в реальных приложениях часто имеют сложную структуру. Объекты, вложенные в объекты, которые вложены в объекты и так далее. Использовать глубоко вложенные объекты напрямую неудобно, если такое использование требует повторных обращений:

```
const greeting = `${user.company.name} was founded in ${user.company.createdAt}`;
console.log(greeting);
```

Разработчики стараются сократить такой код и создают промежуточные константы для вложенных данных:

```
const company = user.company;
const greeting = `${company.name} was founded in ${company.createdAt}`;
console.log(greeting);
```

Чем больше обращений к вложенным данным, тем полезнее эта техника. Но само извлечение данных может стать громоздким если этих данных много. Пример из реальной жизни:

```javascript
const response = {
  data: {
    type: "photos",
    id: "550e8400-e29b-41d4-a716-446655440000",
    attributes: {
      title: "Ember Hamster",
      src: "http://example.com/images/productivity.png",
    },
    relationships: {
      author: {
        links: {
          related: "http://example.com/articles/1/author",
        },
      },
    },
    links: {
      self: "http://example.com/photos/550e8400-e29b-41d4-a716-446655440000",
    },
  },
};
```

Это данные вымышленного приложения представленные в виде формата [jsonapi](https://jsonapi.org/). Он, например, используется на Хекслете для взаимодействия серверной и клиентской части сайта. Внутри клиента эти данные извлекаются и выводятся на экран. Представьте себе, как бы мог выглядеть код извлечения внутренностей этой структуры:

```javascript
const user = response.data.attributes;
const links = response.data.links;
const author = response.data.relationships.author;
```

Чем больше данных нужно извлечь и чем они глубже расположены, тем больше однообразного и повторяющегося кода придется написать. В принципе, в этом нет никакого криминала и раньше так жили все. Но с развитием языка появилась возможность сделать код гораздо лучше.

Деструктуризация (destructuring) — специальный синтаксис, позволяющий извлекать части из составных данных. Это удобный способ раскладывать объекты на части. Он позволяет сократить код и сделать его более понятным.

```javascript
const person = { firstName: "Rasmus", lastName: "Lerdorf", manager: true };

const { firstName, manager } = person;

console.log(firstName); // => 'Rasmus'
console.log(manager); // => true
```

https://repl.it/@hexlet/js-objects-destructuring-object-destructuring

Деструктуризация похожа на создание объекта. Абсолютно тот же самый синтаксис, но теперь не для создания объекта, а для разложения его на части. Деструктуризация позволяет "раскладывать" объект по частям, то есть не обязательно извлекать все части сразу. В примере выше у объекта три свойства, но извлекаются только два. Порядок описания свойств при извлечении не важен.

При деструктуризации можно переименовывать имена. Такое бывает нужно, если подобная константа уже определена выше.

```
const manager = /* ... */; // имя занято

const person = { firstName: 'Rasmus', lastName: 'Lerdorf', manager: true };

const { manager: isManager } = person;

console.log(isManager); // => true
```

В случае отсутствия свойств в объекте, деструктуризация позволяет задавать значения по умолчанию для таких свойств:

```javascript
const person = { firstName: "Rasmus", lastName: "Lerdorf" };

console.log(person.manager); // undefined
const { manager = false } = person;
console.log(manager); // => false
```

https://repl.it/@hexlet/js-objects-destructuring-default-value

Деструктуризация может быть вложенной. Она позволяет извлекать части объектов на любую глубину. Поэтому наш пример выше можно переписать так:

```javascript
// const user = response.data.attributes;
// const links = response.data.links;
// const author = response.data.relationships.author;

const {
  links,
  attributes: user,
  relationships: { author },
} = response.data;
```

У spread оператора есть похожий, но выполняющий обратное действие оператор, называемый rest. С его помощью во время деструктуризации можно собрать все "оставшиеся" свойства в один объект:

```javascript
const user = { name: "Tirion", email: "support@hexlet.io", age: 44 };

const { name, ...rest } = user;

console.log(rest);
// => { email: 'support@hexlet.io', age: 44 }
```

Деструктуризация хоть и не является обязательным элементом и она не влияет на архитектуру программ, но ее использование делает код чище и понятнее (если не увлекаться глубиной).

## Хеш-таблицы—JS: Объекты

**Ассоциативный** массив — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. У него есть и другие названия: "словарь", "мап" (от слова map). В разных языках ему соответствуют разные типы данных. В JavaScript — это Object, в других языках:

- Ruby — Hash
- Lua — Table
- Python — Dictionary
- Elixir/Java — Map

Для чего он нужен? Ассоциативные массивы крайне популярны в прикладном программировании. С их помощью удобно представлять составные данные, содержащие множество различных параметров. Фактически все предыдущие уроки по объектам в JavaScript были посвящены тому, как использовать объекты в качестве ассоциативных массивов.

Ассоциативный массив, в отличие от обычного массива (называемого индексированным, так как значения в нем расположены по индексам), нельзя положить в память "как есть". У него нет индексов, которые бы могли определить порядок и простой способ добраться до значений. Для реализации ассоциативных массивов часто используют специальную структуру данных — хеш-таблицу. Она позволяет организовать данные ассоциативного массива удобным для хранения способом. Для этого хеш-таблица использует две вещи: индексированный массив и функцию для хеширования ключей. Обратите внимание, что хеш-таблица это не просто способ размещать данные в памяти, она включает в себя логику.

_Ниже пойдет речь про то, как ассоциативные массивы бывают устроены внутри. Эта информация крайне важна для разработчиков, которые хотят по настоящему разбираться в том, что они делают. Она снимает "магичность" с происходящего внутри языка и дает понимание цены, которую приходится платить за удобство использования объектов._

Итак, что примерно происходит, когда мы выполняем код:

```javascript
const data = {};
data["key"] = "value";
```

## Хеширование

Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс обычного массива. Для получения индекса из ключа нужно выполнить два действия: найти хеш (хешировать ключ) и привести его к индексу (например, через остаток от деления).

Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины. Функция, реализующая алгоритм преобразования, называется "хеш-функцией", а результат называют "хешем" или "хеш-суммой". Наиболее известны CRC32, MD5 и SHA (много разновидностей).

```javascript
// В JavaScript нет встроенной поддержки алгоритма хеширования crc32 (удобен для наглядности)
// Поэтому используется сторонняя библиотека
import crc32 from "crc-32";

const data = "Hello, world!"; // Любые данные, которые мы хотим хешировать
const hash = crc32.str(data);

// Хеш всегда одинаковый для одних и тех же данных!
console.log(hash); // => -337197338
```

С хешированием мы встречаемся в разработке часто. Например, идентификатор коммита в git _0481e0692e2501192d67d7da506c6e70ba41e913_ не что иное, как хеш, полученный в результате хеширования данных коммита.

После того, как хеш получен, его можно преобразовать в индекс массива, например, через получение остатка от деления:

```javascript
// Это делается для того, чтобы индексы не были слишком большими
// Чем больше размер массива, тем больше памяти он занимает
const index = Math.abs(hash) % 1000; // по модулю
console.log(index); // => 338
```

![хеширование](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImZlODhmOGQ3ODBhMTBiMTE4MmQ3MTgwYjBmYmEzYTFmLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=87706cf57668d093ec66ff39aed76569fb3129fc1e34f642a0b2d5581df626c6)

### За кулисами

Рассмотрим процесс добавления нового значения в ассоциативный массив (напомню, в JavaScript представлен типом данных Object). Программист пишет:

```javascript
const data = {};
data["key"] = "value";
```

Такая простая, на первый взгляд, строчка, запускает целый процесс. Ниже его грубое описание, без деталей и с упрощениями:

```javascript
// Для простоты показано на JavaScript, хотя в реальности всё это происходит на более низком уровне

// 1. Создание ассоциативного массива приводит к инициализации индексированного массива внутри интерпретатора.
const internal = [];
// Во время присвоения значения `data['key'] = 'value'`, интерпретатор выполняет несколько действий:

// 2. Хеширует ключ. Результатом хеширования становится число.
const hash = crc32.str("key");
// 3. Число, полученное на предыдущем шаге, преобразуется в индекс массива.
const index = Math.abs(hash) % 1000;
// В значение внутреннего индексированного массива, по найденному индексу, записывается ещё один массив,
// первым элементом которого становится ключ `'key'`, а вторым значение `'value'`.
internal[index] = ["key", "value"];
```

Почему такая странная структура для хранения? Зачем там нужен ключ? Ответ на этот вопрос будет ниже, там где мы поговорим про коллизии.

Теперь посмотрим на чтение:

```javascript
const data = {};
data["key"] = "value";
console.log(data["key"]); // => "value"
// Для простоты показано на JavaScript, хотя в реальности всё это происходит на более низком уровне

// 1. Хешируется ключ. Результатом хеширования становится число.
const hash = crc32.str("key");
// 2. Число, полученное на предыдущем шаге преобразуется в индекс массива.
const index = Math.abs(hash % 1000);

// 3. Если индекс существует, то извлекается массив, который находился внутри, и возвращается наружу.
return internal[index]; // ['key', 'value']
```

## Коллизии

Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и содержания). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат работы хеш-функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.

Из этого факта следует, что не для всех входных данных найдётся уникальный хеш. На каком-то этапе возможно появление дублей (когда для разных значений получается один и тот же хеш). Такую ситуацию принято называть коллизией. Способов разрешения коллизий несколько, и каждому из них соответствует свой тип хеш-таблицы.

```javascript
// Пример коллизии

// Две разных строчки возвращают одинаковый хеш!
crc32.str("aaaaa0.462031558722291"); // 1938556049
crc32.str("aaaaa0.0585754039730588"); // 1938556049
```

Коллизии не так редки, как может показаться. Убедиться в этом можно, изучив [парадокс дней рождений](https://ru.wikipedia.org/wiki/Парадокс_дней_рождения).
