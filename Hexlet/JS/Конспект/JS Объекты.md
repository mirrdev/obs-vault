## Синтаксис—JS: Объекты


Объект – тип данных в JavaScript, с помощью которого представляют связанный набор данных. Это позволяет оперировать данными как единым целым. Например, любой объект реального мира можно описать объектом в JavaScript. То же самое относится и к математическsим объектам, например — фигурам.

```javascript
const user = { name: 'Vasya', married: true, age: 25 };

const rectangle = { width: 10, height: 5 };
```

Объект описывается как перечисление ключей и значений через запятую в фигурных скобках. Ключи в объектах называются свойствами (property). Они уникальны, то есть в одном объекте не может быть двух одинаковых свойств, имеющих разные значения.

Если свойств много, то определение можно растянуть на несколько строк:

```javascript
const user = {
  name: 'Vasya',
  married: true,
  age: 25,
};
```

Запятая в конце не обязательна, но [рекомендуется линтером](https://eslint.org/docs/rules/comma-dangle). Это удобно при добавлении или удалении ключей. Не придется менять окончание последней строчки.

Для обращения к свойствам объектов используется точечный синтаксис:

```javascript
user.name; // 'Vasya'
rectangle.width; // 10
```

Иногда по ошибке или намеренно обращаются к свойствам, которых в объекте нет. В этом случае JavaScript возвращает `undefined`, и продолжает работать как ни в чем не бывало. Такое поведение может приводить к трудноотловимым ошибкам, поэтому будьте осторожны и всегда проверяйте написание свойств, если возвращаются не те данные, или данных нет:

```javascript
user.nme; // undefined
user.name; // 'Vasya'
```

JavaScript поддерживает альтернативный способ обращения к свойствам объектов – через квадратные скобки — как в массивах:

```javascript
// имена свойств хранятся внутри объекта в виде строк.
user['name']; // 'Vasya'
rectangle['width']; // 10
user['company']; // undefined
```

Зачем нужен такой способ доступа? В реальном использовании объектов часто встречаются алгоритмы, когда имя свойства может меняться в процессе обработки. Обращение к свойству через точку не позволяет задавать имя динамически, а способ через скобки — позволяет:

```javascript
const user = { name: 'Vasya', married: true, age: 25 };

let propertyName = 'name';
user[propertyName]; // 'Vasya' 

propertyName = 'married';
user[propertyName]; // true 
```

Подробнее про такое использование мы поговорим в одном из следующих уроков.

------
#### Самостоятельная работа

1. Запустите REPL
2. Создайте внутри него объект, выполните обращение к его свойствам разными способами
------
#### Дополнительные материалы
1. [Документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object)

## Модификация—JS: Объекты

Для создания и обновления значений свойств в объекте используется одна и та же операция — присваивание. Для несуществующих свойств она запишет новый элемент, для существующих — перезапишет новым значением:

```javascript
const user = { name: 'Vasya', married: true, age: 25 };

user.married = false;
// То же самое
// user['married'] = false;

user.surname = 'Petrov';
// То же самое
// user['surname'] = 'Petrov';

console.log(user);
// => { name: 'Vasya', married: false, age: 25, surname: 'Petrov' }
```

Несмотря на то, что объект объявлен как константа, он меняется. Причина такого поведения точно такая же, как и в случае массивов. В константе хранится не сам объект, а ссылка на него. Это значит, что менять объект можно, но заменить объект на другой – нельзя:

```javascript
const user = { name: 'Maria' };
user.name = 'Igor';

// Возникнет ошибка
user = { name: 'Mike' }; // Boom!
```

Подробнее об этом - в одном из следующих уроков.

Изменяемость объектов позволяет наполнять их постепенно. То есть мы можем создать пустой объект и затем расширить его нужными свойствами:

```javascript
const course = {};

course.name = 'Хекслет – JS: Объекты';
course.description = 'Самый классный курс на свете, не проходите мимо, дети!';

console.log(course.name); // 'Хекслет – JS: Объекты'

console.log(course);
// {
//   name: 'Хекслет – JS: Объекты',
//   description: 'Самый классный курс на свете, не проходите мимо, дети!'
// }
```

Удалить элемент из объекта можно с помощью оператора `delete`:

```javascript
const user = { name: 'Vasya', wrongProp: 'bug' };

delete user.wrongProp;

console.log(user);
// => { name: 'Vasya' }
```

Несмотря на наличие удаления, удалять свойства из объекта плохая практика. Как вы увидите далее, любую задачу можно решить без удаления и главное, что такой код будет лучше.

https://repl.it/@hexlet/js-objects-syntax-add-update-delete-values

## Ссылки—JS: Объекты

Объекты – ссылочный тип данных. То есть переменные и константы хранят не сами объекты (их данные), а ссылку на них. Поэтому возникает ощущение, что константы в JavaScript изменяемы, но это не так. Главное понимать, что константа связана со ссылкой, а не с данными в случае объекта:

```javascript
const company = {};

// Поменять объект можно
company.name = 'Hexlet';

// Заменить ссылку нельзя
company = {}; // Boom!

let object = {};

// А так можно
object = {};
```

Ссылочная природа влияет и на сравнение. Объекты равны между собой не тогда, когда у них одинаковая структура, а когда это один и тот же объект:

```javascript
const company = { name: 'Hexlet' };

company === { name: 'Hexlet' }; // false

const copyOfCompany = company; // передается ссылка

// Это одно и то же
copyOfCompany === company; // true

// Меняя одно, меняем и другое
company.createdAt = 2012;

console.log(copyOfCompany); // { name: 'Hexlet', createdAt: 2012 }
```

Каждое объявление объекта (в том числе пустого), создает новый объект. Поэтому даже два пустых объекта никогда не равны друг другу:

```javascript
{} === {}; // false
```

Больше всего ссылочная природа объектов влияет на их работу с функциями. Любой объект, передаваемый в функцию, попадает туда по ссылке. Изменение такого объекта внутри функции меняет его и снаружи:

```javascript
const changeObj = (o) => {
  o.key = 'value';
};

const obj = {};

changeObj(obj);
console.log(obj); // { key: 'value' };
```

## Объекты в действии—JS: Объекты

Рассмотрим пример, в котором используется объект. Напишем функцию, которая принимает на вход путь до файла и возвращает информацию об этом файле в виде объекта.

```javascript
const filepath = '/path/to/index.js';
const fileinfo = getFileInfo(filepath);
// {
//     extension: js
//     filename: index.js
// };
```

В Node.js встроен модуль *path*, который может быстро извлечь нужные данные. Именно им и нужно пользоваться при написании реального кода, здесь же мы фокусируемся не на способе получения данных, а на формировании объекта.

Для начала нам нужно извлечь имя файла. Это можно сделать, используя метод `split()`.

```javascript
import _ from 'lodash';

// Разделяем путь на промежуточные директории и файл
const parts = filepath.split('/');
// Извлекаем имя файла
// last извлекает последний элемент из массива
const filename = _.last(parts); 
```

Затем, точно таким же способом, можно получить и расширение:

```javascript
const extension = _.last(filename.split('.'));
```

Теперь, объединяя все вместе, реализуем нужную функцию:

```javascript
const getFileInfo = (filepath) => {
  const parts = filepath.split('/');
  const filename = _.last(parts); 
  const extension = _.last(filename.split('.'));

  // В значения вместо переменных подставятся нужные значения
  const info = { filename: filename, extension: extension };

  return info;
}
```

В примере выше объект создается сразу, когда все данные уже готовы. Иногда делают по-другому, инициализируют объект в самом начале и постепенно наполняют его данными:

```javascript
const getFileInfo = (filepath) => {
  // Инициализация объекта
  const info = {};

  const parts = filepath.split('/');
  const filename = _.last(parts); 
  info.filename = filename;

  const extension = _.last(filename.split('.'));
  info.extension = extension;

  return info;
}
```

Какой способ предпочесть? В подавляющем большинстве ситуаций первый способ лучше. Когда объект создается сразу со всеми данными, то его структура очевидна с первого взгляда. Во втором примере придется пробежаться глазами по всему коду чтобы понять что же получится в итоге. С другой стороны, второй способ нужен в ситуациях, когда объект заполняется по условиям, которые могут не выполняться:

```javascript
// Добавляем свойство в объект только если расширение существует
if (extension) {
  info.extension = extension;
}
```

Такое встречается значительно реже, но все же бывает.

## Упрощенный синтаксис создания объектов

Когда объект создается сразу наполненным данными, то он часто выглядит так, как в примерах выше:

```javascript
const info = { filename: filename, extension: extension };
```

Обратите внимание на совпадение имени ключа и имени константы, которая содержит значение для данного ключа. Это настолько распространенный способ создания объектов, что в JavaScript добавили специальный, упрощенный синтаксис создания объектов. Если имя константы соответствует имени свойства в объекте, то можно просто добавить имя константы в определение объекта без указания свойства:

```javascript
const info = { filename, extension };
```

Как показывает жизнь, этот подход оказался очень удобным и практичным. К тому же он сочетается с обычным способом создать объект. JavaScript позволяет миксовать разные способы определения в рамках одного объекта:

```javascript
const filename = 'hexlet';
const ext = 'jpg';

const info = { filename, extension: ext };
// Порядок не важен, можно было и так
const info = { extension: ext, filename };

// В результате получится
// const info = { filename: 'hexlet', extension: 'jpg' };
```