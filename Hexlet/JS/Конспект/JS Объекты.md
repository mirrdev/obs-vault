## Синтаксис—JS: Объекты


Объект – тип данных в JavaScript, с помощью которого представляют связанный набор данных. Это позволяет оперировать данными как единым целым. Например, любой объект реального мира можно описать объектом в JavaScript. То же самое относится и к математическsим объектам, например — фигурам.

```javascript
const user = { name: 'Vasya', married: true, age: 25 };

const rectangle = { width: 10, height: 5 };
```

Объект описывается как перечисление ключей и значений через запятую в фигурных скобках. Ключи в объектах называются свойствами (property). Они уникальны, то есть в одном объекте не может быть двух одинаковых свойств, имеющих разные значения.

Если свойств много, то определение можно растянуть на несколько строк:

```javascript
const user = {
  name: 'Vasya',
  married: true,
  age: 25,
};
```

Запятая в конце не обязательна, но [рекомендуется линтером](https://eslint.org/docs/rules/comma-dangle). Это удобно при добавлении или удалении ключей. Не придется менять окончание последней строчки.

Для обращения к свойствам объектов используется точечный синтаксис:

```javascript
user.name; // 'Vasya'
rectangle.width; // 10
```

Иногда по ошибке или намеренно обращаются к свойствам, которых в объекте нет. В этом случае JavaScript возвращает `undefined`, и продолжает работать как ни в чем не бывало. Такое поведение может приводить к трудноотловимым ошибкам, поэтому будьте осторожны и всегда проверяйте написание свойств, если возвращаются не те данные, или данных нет:

```javascript
user.nme; // undefined
user.name; // 'Vasya'
```

JavaScript поддерживает альтернативный способ обращения к свойствам объектов – через квадратные скобки — как в массивах:

```javascript
// имена свойств хранятся внутри объекта в виде строк.
user['name']; // 'Vasya'
rectangle['width']; // 10
user['company']; // undefined
```

Зачем нужен такой способ доступа? В реальном использовании объектов часто встречаются алгоритмы, когда имя свойства может меняться в процессе обработки. Обращение к свойству через точку не позволяет задавать имя динамически, а способ через скобки — позволяет:

```javascript
const user = { name: 'Vasya', married: true, age: 25 };

let propertyName = 'name';
user[propertyName]; // 'Vasya' 

propertyName = 'married';
user[propertyName]; // true 
```

Подробнее про такое использование мы поговорим в одном из следующих уроков.

------
#### Самостоятельная работа

1. Запустите REPL
2. Создайте внутри него объект, выполните обращение к его свойствам разными способами
------
#### Дополнительные материалы
1. [Документация](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object)

## Модификация—JS: Объекты

Для создания и обновления значений свойств в объекте используется одна и та же операция — присваивание. Для несуществующих свойств она запишет новый элемент, для существующих — перезапишет новым значением:

```javascript
const user = { name: 'Vasya', married: true, age: 25 };

user.married = false;
// То же самое
// user['married'] = false;

user.surname = 'Petrov';
// То же самое
// user['surname'] = 'Petrov';

console.log(user);
// => { name: 'Vasya', married: false, age: 25, surname: 'Petrov' }
```

Несмотря на то, что объект объявлен как константа, он меняется. Причина такого поведения точно такая же, как и в случае массивов. В константе хранится не сам объект, а ссылка на него. Это значит, что менять объект можно, но заменить объект на другой – нельзя:

```javascript
const user = { name: 'Maria' };
user.name = 'Igor';

// Возникнет ошибка
user = { name: 'Mike' }; // Boom!
```

Подробнее об этом - в одном из следующих уроков.

Изменяемость объектов позволяет наполнять их постепенно. То есть мы можем создать пустой объект и затем расширить его нужными свойствами:

```javascript
const course = {};

course.name = 'Хекслет – JS: Объекты';
course.description = 'Самый классный курс на свете, не проходите мимо, дети!';

console.log(course.name); // 'Хекслет – JS: Объекты'

console.log(course);
// {
//   name: 'Хекслет – JS: Объекты',
//   description: 'Самый классный курс на свете, не проходите мимо, дети!'
// }
```

Удалить элемент из объекта можно с помощью оператора `delete`:

```javascript
const user = { name: 'Vasya', wrongProp: 'bug' };

delete user.wrongProp;

console.log(user);
// => { name: 'Vasya' }
```

Несмотря на наличие удаления, удалять свойства из объекта плохая практика. Как вы увидите далее, любую задачу можно решить без удаления и главное, что такой код будет лучше.

https://repl.it/@hexlet/js-objects-syntax-add-update-delete-values

## Ссылки—JS: Объекты

Объекты – ссылочный тип данных. То есть переменные и константы хранят не сами объекты (их данные), а ссылку на них. Поэтому возникает ощущение, что константы в JavaScript изменяемы, но это не так. Главное понимать, что константа связана со ссылкой, а не с данными в случае объекта:

```javascript
const company = {};

// Поменять объект можно
company.name = 'Hexlet';

// Заменить ссылку нельзя
company = {}; // Boom!

let object = {};

// А так можно
object = {};
```

Ссылочная природа влияет и на сравнение. Объекты равны между собой не тогда, когда у них одинаковая структура, а когда это один и тот же объект:

```javascript
const company = { name: 'Hexlet' };

company === { name: 'Hexlet' }; // false

const copyOfCompany = company; // передается ссылка

// Это одно и то же
copyOfCompany === company; // true

// Меняя одно, меняем и другое
company.createdAt = 2012;

console.log(copyOfCompany); // { name: 'Hexlet', createdAt: 2012 }
```

Каждое объявление объекта (в том числе пустого), создает новый объект. Поэтому даже два пустых объекта никогда не равны друг другу:

```javascript
{} === {}; // false
```

Больше всего ссылочная природа объектов влияет на их работу с функциями. Любой объект, передаваемый в функцию, попадает туда по ссылке. Изменение такого объекта внутри функции меняет его и снаружи:

```javascript
const changeObj = (o) => {
  o.key = 'value';
};

const obj = {};

changeObj(obj);
console.log(obj); // { key: 'value' };
```

## Объекты в действии—JS: Объекты

Рассмотрим пример, в котором используется объект. Напишем функцию, которая принимает на вход путь до файла и возвращает информацию об этом файле в виде объекта.

```javascript
const filepath = '/path/to/index.js';
const fileinfo = getFileInfo(filepath);
// {
//     extension: js
//     filename: index.js
// };
```

В Node.js встроен модуль *path*, который может быстро извлечь нужные данные. Именно им и нужно пользоваться при написании реального кода, здесь же мы фокусируемся не на способе получения данных, а на формировании объекта.

Для начала нам нужно извлечь имя файла. Это можно сделать, используя метод `split()`.

```javascript
import _ from 'lodash';

// Разделяем путь на промежуточные директории и файл
const parts = filepath.split('/');
// Извлекаем имя файла
// last извлекает последний элемент из массива
const filename = _.last(parts); 
```

Затем, точно таким же способом, можно получить и расширение:

```javascript
const extension = _.last(filename.split('.'));
```

Теперь, объединяя все вместе, реализуем нужную функцию:

```javascript
const getFileInfo = (filepath) => {
  const parts = filepath.split('/');
  const filename = _.last(parts); 
  const extension = _.last(filename.split('.'));

  // В значения вместо переменных подставятся нужные значения
  const info = { filename: filename, extension: extension };

  return info;
}
```

В примере выше объект создается сразу, когда все данные уже готовы. Иногда делают по-другому, инициализируют объект в самом начале и постепенно наполняют его данными:

```javascript
const getFileInfo = (filepath) => {
  // Инициализация объекта
  const info = {};

  const parts = filepath.split('/');
  const filename = _.last(parts); 
  info.filename = filename;

  const extension = _.last(filename.split('.'));
  info.extension = extension;

  return info;
}
```

Какой способ предпочесть? В подавляющем большинстве ситуаций первый способ лучше. Когда объект создается сразу со всеми данными, то его структура очевидна с первого взгляда. Во втором примере придется пробежаться глазами по всему коду чтобы понять что же получится в итоге. С другой стороны, второй способ нужен в ситуациях, когда объект заполняется по условиям, которые могут не выполняться:

```javascript
// Добавляем свойство в объект только если расширение существует
if (extension) {
  info.extension = extension;
}
```

Такое встречается значительно реже, но все же бывает.

## Упрощенный синтаксис создания объектов

Когда объект создается сразу наполненным данными, то он часто выглядит так, как в примерах выше:

```javascript
const info = { filename: filename, extension: extension };
```

Обратите внимание на совпадение имени ключа и имени константы, которая содержит значение для данного ключа. Это настолько распространенный способ создания объектов, что в JavaScript добавили специальный, упрощенный синтаксис создания объектов. Если имя константы соответствует имени свойства в объекте, то можно просто добавить имя константы в определение объекта без указания свойства:

```javascript
const info = { filename, extension };
```

Как показывает жизнь, этот подход оказался очень удобным и практичным. К тому же он сочетается с обычным способом создать объект. JavaScript позволяет миксовать разные способы определения в рамках одного объекта:

```javascript
const filename = 'hexlet';
const ext = 'jpg';

const info = { filename, extension: ext };
// Порядок не важен, можно было и так
const info = { extension: ext, filename };

// В результате получится
// const info = { filename: 'hexlet', extension: 'jpg' };
```

## Проверка существования свойства—JS: Объекты

В работе с объектами иногда бывает нужно проверить наличие свойства и выполнить особую логику в случае его отсутствия. Проще всего такая проверка выполняется через сравнение с `undefined`, но этот подход не универсальный. При определенных условиях он сработает неверно.

```javascript
if (obj.key === undefined) {
  // логика
}
```

Представьте себе функцию, которая должна посчитать количество повторяющихся элементов в массиве:

```javascript
// Вход

const bag = [
  'apple', 'banana', 'pear',
  'apricot', 'apple', 'banana',
  'apple', 'orange', 'pear',
];

// Выход

const result = {
  apple: 3,
  banana: 2,
  pear: 2,
  orange: 1,
  apricot: 1,
};
```

Алгоритм ее работы достаточно прост, но есть один тонкий момент. Во время обхода массива эта функция берет объект-результат, извлекает из него нужное свойство и увеличивает значение на единицу. Но это в случае, когда свойство уже есть. А если его нет? Так как изначально объект-результат пустой, то когда элемент массива появляется первый раз, в объекте нужно создавать соответствующее свойство со значением 1. Посмотрите на реализацию:

```javascript
const countFruits = (fruits) => {
  const result = {};

  for (const name of fruits) {
    // Проверка на существование
    if (result[name] === undefined) {
      result[name] = 1;
    } else {
      result[name] += 1;
    }
  }

  return result;
};
```

В подобной ситуации сравнение значения с `undefined` сработает всегда, но только потому, что `undefined` не может оказаться внутри существующего свойства. Но бывает и по-другому. Посмотрите на код:

```javascript
const obj = {
  key: doSomething(),
};
```

В примере выше значением `key` станет результат вызова функции `doSomething()`. Если эта функция может вернуть `undefined`, то окажется, что в объекте ключ `key` определен, но его значение `undefined`.

В JavaScript есть более надежный и более правильный по смыслу способ проверить существование свойства, не сравнивая значения – это метод [Object.hasOwn()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn). Вот как меняется функция `countFruits()`, если использовать это свойство:

```javascript
const countFruits = (fruits) => {
  const result = {};

  for (const name of fruits) {
    // Проверка на существование
    if (Object.hasOwn(result, name)) {
      result[name] += 1;
    } else {
      result[name] = 1;
    }
  }

  return result;
};
```

## Оператор нулевого слияния

Конкретно в нашем примере с поиском фруктов, внутри результирующего объекта не может оказаться `undefined` просто так в качестве значения. Там всегда будет какое-то число, начиная от единицы. Более того, даже проверка на наличие значения лишняя. Всё, что нам нужно – извлекать текущее значение с возможностью задать значение по умолчанию. Сделать это можно, воспользовавшись [оператором нулевого слияния](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator). Он позволяет задать значение по умолчанию в случае, когда оно равно `null` или `undefined`.

```javascript
let value;

value ?? 'wow'; // 'wow'

value = null;
value ?? 'wow'; // 'wow'

value = true;
value ?? 'wow'; // true
for (const name of fruits) {
  result[name] = (result[name] ?? 0) + 1;
}
```

------

#### Дополнительные материалы
1. [Функция has из библиотеки Lodash](https://lodash.com/docs/#has)

## Обход свойств объекта—JS: Объекты

Объект в JavaScript, в отличие от массива, не является коллекцией. Его нельзя обходить как обычный массив с помощью цикла *for..of*, хотя подобная задача иногда возникает. Например, когда мы хотим распечатать все свойства на экран, или когда свойства в объект добавляются динамически — то есть их имена могут меняться в процессе жизни объекта.

В JavaScript для обхода объектов есть несколько способов. Самый простой – использовать конструкцию *for..in*, которая очень похожа на обычный цикл.

```javascript
const course = { name: 'JS: React', slug: 'js-react' };
for (const prop in course) {
  console.log(`course.${prop} = ${course[prop]}`);
}
// course.name = JS: React
// course.slug = js-react
```

Несмотря на простоту использования, *for..in* работает не совсем так, как может показаться. *for..in* выводит не только свойства самого объекта, но и свойства, добавленные в прототип этого объекта. Эту тему мы пока не проходили и дается она позже, но если в двух словах, то объекты в JavaScript могут быть связаны друг с другом и обращение к свойству в одном объекте может приводить к обращению (неявному) к свойству в другом объекте (прототипе). Мы уже сталкивались с таким поведением на практике, но пока обходили этот вопрос стороной.

Главное, что сейчас нужно понимать, в подавляющем большинстве случаев это нежелательное поведение. Именно поэтому *for..in* используется не так часто, как может показаться. Гораздо более распространенный способ – обходить ключи. Метод `Object.keys(obj)` позволяет получить массив всех ключей объекта:

```javascript
const course = { name: 'JS: React', slug: 'js-react' };

const keys = Object.keys(course); // [ 'name', 'slug' ]
```

Далее мы можем обойти в цикле массив ключей и получить нужные значения. На практике, обычно, сначала получают массив ключей и что-то с ним делают. Например, фильтруют, отбирая только нужные ключи, а затем обрабатывают исходный объект или создают новый, получая в цикле значение по ключу.

```javascript
for (const key of keys) {
  console.log(course[key]);
}
```

Если ключи в процессе обхода не используются, то можно сразу получить массив значений свойств объекта. Это делает метод `Object.values(obj)`:

```javascript
const course = { name: 'JS: React', slug: 'js-react' };

const values = Object.values(course); // [ 'JS: React', 'js-react' ]

for (const value of values) {
  console.log(value);
}
```

Ну, и последний вариант, метод, который возвращает сразу ключи и значения объекта. То есть каждый элемент сам будет массивом, содержащим ключ и соответствующее ему значение — `[ key, value ]`. За это отвечает метод `Object.entries(obj)`:

```javascript
const course = { name: 'JS: React', slug: 'js-react' };

const entries = Object.entries(course);
// [[ 'name', 'JS: React' ], [ 'slug', 'js-react' ]]
```

Обойти такой массив циклом `for...of` не составит никакого труда, а деструктуризация позволит сделать это красиво:

```javascript
for (const [key, value] of entries) {
  console.log(key);
  console.log(value);
}
```

Рассмотрим пример. Реализуем функцию `findKeys()`, которая возвращает список ключей объекта, значение которых равно переданному значению:

```javascript
const lessonMembers = {
  syntax: 3,
  using: 2,
  foreach: 10,
  operations: 10,
  destructuring: 2,
  array: 2,
};

findKeys(lessonMembers, 10); // ['foreach', 'operations']
findKeys(lessonMembers, 3);  // ['syntax']
```

Логика работы функции выглядит так:

1. Обходим свойства объекта
2. Если значение в свойстве совпадает с переданным, то добавляем ключ в результат

```javascript
const findKeys = (obj, expectedValue) => {
  const result = [];

  const entries = Object.entries(obj);
  for (const [key, value] of entries) {
    if (value === expectedValue) {
      result.push(key);
    }
  }

  return result;
};
```

https://repl.it/@hexlet/js-objects-for-of-find-keys

## Порядок ключей

Одна из ключевых особенностей массива – наличие строгого порядка, в котором следуют элементы. В объектах это не так, порядок какой-то есть, но им нельзя управлять. Этот порядок базируется на внутренних правилах работы JavaScript. Если нам важен порядок, то для этого придется вводить дополнительный массив, в котором будет храниться список ключей в том порядке, в котором мы хотим получить вывод.

## Вложенные объекты—JS: Объекты


Значением свойства объекта может быть всё, что угодно, включая другой объект или массив:

```javascript
const user = { name: 'Vasya', married: true, age: 25 };

// Добавим свойство friends со списком друзей
user.friends = ['Kolya', 'Petya'];

// Добавим свойство children со списком детей,
// каждый ребёнок представлен отдельным объектом
user.children = [
  { name: 'Mila', age: 1 },
  { name: 'Petr', age: 10 },
];

// Добавим вложенный объект
user.company = { name: 'Hexlet' };

console.log(user); // =>
// { name: 'Vasya',
//   married: true,
//   age: 25,
//   friends: [ 'Kolya', 'Petya' ],
//   company: { name: 'Hexlet' },
//   children: [ { name: 'Mila', age: 1 }, { name: 'Petr', age: 10 } ] }
```

Все то же самое можно определить сразу при создании объекта:

```javascript
const user = {
  name: 'Vasya',
  married: true,
  age: 25,
  friends: ['Kolya', 'Petya'],
  children: [
    { name: 'Mila', age: 1 },
    { name: 'Petr', age: 10 },
  ],
  company: {
    name: 'Hexlet'
  },
};
```

В этом случае обращение к вложенным элементам происходит по цепочке:

```javascript
user.friends[1];       // 'Petya'
user.children[0].name; // 'Mila'
user.company.name; // 'Hexlet'
```

## Печать на экран

В `console.log()` встроено одно ограничение. Если в объекте есть другие объекты на глубине больше второго уровня вложенности, то при выводе такого объекта на экран вместо объектов отобразится строка `[Object]`, а вместо массива `[Array]`.

```javascript
const obj = { a: { b: { c: { key: 'value' }, e: [1, 2] } } };
console.log(obj);
// { a: { b: { c: [Object], e: [Array] } } }
```

Для вывода таких объектов можно воспользоваться функцией преобразования в JSON:

```javascript
console.log(JSON.stringify(obj));
// {"a":{"b":{"c":{"key":"value"},"e":[1,2]}}}

// Или форматированный вывод
console.log(JSON.stringify(obj, null, '  '));
// {
//   "a": {
//     "b": {
//       "c": {
//         "key": "value"
//       },
//       "e": [
//         1,
//         2
//       ]
//     }
//   }
// }
```

## Проверки в глубину

При работе с вложенными объектами резко усложняется задача проверки существования ключей. Приходится строить цепочку из условий до нужного свойства. Представьте, что нам нужно добраться до 4 уровня вложенности и мы не уверены в том, что существуют все промежуточные объекты:

```javascript
// Добираемся до obj.one.two.three
if (Object.hasOwn(obj, 'one')) {
  if (Object.hasOwn(obj.one, 'two')) {
    if (Object.hasOwn(obj.one.two, 'three')) {
      // ...
    }
  }
}
```

Так будет выглядеть решение в лоб. Однако, есть более удобный способ, речь о котором ниже.

### Оператор опциональной последовательности

Если задача состоит в том, чтобы извлечь данные, а не просто проверить их существование, то можно пойти другим путем. В Javascript встроен [оператор опциональной последовательности](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (optional chaining), который позволяет извлекать вложенные данные без проверок:

```javascript
const obj = {};
obj?.one?.two?.three // undefined
```

Этот оператор никогда не приводит к ошибке. Он работает на любых типах данных и всегда возвращает либо `undefined`, либо значение указанного свойства, если оно существует.

### Оператор нулевого слияния

С помощью [оператора нулевого слияния](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator), можно не только получить значение цепочки любой вложенности, но и определить значение по умолчанию для него.

```javascript
const obj = {};
obj?.one?.two?.three ?? 'defaultValue' // 'defaultValue'
```

Значение по умолчанию возвращается только в том случае, когда слева `undefined` или `null`. В этом смысле данный оператор совсем не похож на логическое сравнение `||`:

```javascript
const value = false;

value ?? 'default'; // false
value || 'default'; // 'default'
```

### get (lodash)

Последний пример перегружен символами и выглядит достаточно сложно. Как альтернативу можно использовать функцию `get()` библиотеки Lodash.

```javascript
import _ from 'lodash';

const obj = {};

const value = _.get(obj, 'one.two.three', 'defaultValue'); // 'defaultValue'
```

`get()` особенно удобен в случае динамических ключей. В таком случае вторым аргументом можно передать массив ключей:

```javascript
_.get(obj, ['one', 'two', 'three'], 'defaultValue'); // 'defaultValue'
```

------
#### Дополнительные материалы
1. [Функция get из библиотеки Lodash](https://lodash.com/docs/#get)

## Слияние—JS: Объекты

Слияние (merge) – операция над объектами, выполняющая их объединение. Она появляется там, где необходимо данные одного объекта перенести в другой объект.

Слияние часто используется при работе с веб-формами. Например, когда пользователь меняет свои персональные данные в настройках аккаунта, измененные данные приходят в приложение в виде объекта. Данные из этого объекта нужно перенести в объект пользователя. Так происходит обновление пользователя:

```javascript
// Такой пользователь есть в системе
const user = { name: 'Tirion', email: 'support@hexlet.io', age: 44 };

// Из формы пришли данные
const data = { name: 'Tirion 2', age: 33 };

// В результате должно получиться
// { name: 'Tirion 2', email: 'support@hexlet.io', age: 33 };
```

Решение в лоб – перенести каждое свойство отдельно:

```javascript
user.name = data.name;
user.age = data.age;

// Где-то тут сохраняем пользователя в базе данных
```

Прямой перенос хорошо работает, когда данных мало и их структура не меняется. Если же данных много или в разные моменты времени могут приходить разные данные, то это превращается в кучу одинакового кода:

```javascript
if (Object.hasOwn(data, 'name')) {
  user.name = data.name;
}

// И так нужно перечислить все возможные свойства
```

С помощью слияния (часто говорят "мержа") мы можем сократить все до одной строчки:

```javascript
Object.assign(user, data);
console.log(user);
// => { name: 'Tirion 2', email: 'support@hexlet.io', age: 33 };
```

Функция [Object.assign()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) берёт объект, переданный первым параметром, и переносит в него всё из объектов, переданных остальными параметрами. В нашей ситуации это один объект, переданный вторым параметром.

Слияние работает так. Если какое-то свойство было только в первом объекте, то оно остается тем, что и было. Если свойство присутствует во втором (и далее) объекте, то оно записывается в первый независимо от того, было оно там или нет. Поэтому, если свойство присутствовало и в первом объекте и во втором, то оно будет перезаписано значением из второго объекта:

```javascript
const obj1 = { a: 'a', b: 'b' };
const obj2 = { c: 'c', b: 'v' };
Object.assign(obj1, obj2);
console.log(obj1);
// => { a: 'a', b: 'v', c: 'c' }
```

У функции `Object.assign()` есть одно ограничение: она выполняет только *поверхностное* слияние. Вложенные объекты не сравниваются, а просто заменяются:

```javascript
const obj1 = { a: { a: 1 } }
const obj2 = { a: { b: 1 } }
Object.assign(obj1, obj2);
console.log(obj1);
// => { a: { b: 1 } }
```

Как и любой другой мощный механизм, слияние нуждается в аккуратном использовании. В объектах бывают поля, которые не должны быть перезаписаны при слиянии, например, количество денег на счету у пользователя. Если не контролировать состав данных из второго объекта, то туда могут попасть свойства (случайно или злонамеренно), которые приведут к перезаписыванию важных свойств.

*Если говорить про веб-формы, то технически всегда можно послать больше данных, чем описано в форме.*

------

#### Дополнительные материалы

1. [Функция has из библиотеки Lodash](https://lodash.com/docs/#has)
