## О курсе—Протокол HTTP

Аббревиатуру HTTP слышал в своей жизни практически каждый человек на планете. Она появляется в тот момент, когда мы загружаем страницы в интернете: [https://hexlet.io](https://hexlet.io/). HTTP — это язык (протокол), который договорились использовать разработчики браузеров, серверов, сайтов, мобильных приложений и обычных программ для обмена данными по сети. Благодаря этому у нас есть возможность использовать разные браузеры и открывать разные сайты, не задумываясь о том, подходят ли они друг другу. Как если бы существовал только один тип зарядок для всех устройств, было бы круто, правда?

HTTP работает по клиент-серверной модели. Это значит, что во время взаимодействия существует две стороны: клиент – запрашивает данные, сервер – отдает клиенту ответ на его запрос. Например, браузер играет роль клиента.

![HTTP Запрос Ответ](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjRhNzhmZTQ2M2EyYjM2MDJkZTI5MzZkMmMyNzg0NDBlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=4fdc1a22b2293c56f245d6072850fe173b6d4309bd534fa5f232824bfc504f7a)

Каждый раз, когда мы вводим адрес сайта или кликаем по ссылке, происходит новый запрос к серверу, который формирует HTML-страницу и возвращает ее браузеру, а он уже ее отображает. Примерно то же самое происходит и в мобильных приложениях, хотя от нас это скрыто. Данные и логика большинства приложений находятся на сервере, и приложение просто обращается к нему, когда это требуется.

HTTP пронизывает всю разработку от и до, будь это бекенд или фронтенд. Любой веб-разработчик пишет код, который выполняет HTTP-запросы или, как минимум, формирует HTTP-ответы (простейшие сайты). Знание HTTP-протокола — это часть фундамента, которым должен обладать любой веб-программист в современном мире.

На что это влияет? Вот некоторые моменты, которые вы сможете делать лучше, зная как устроен HTTP:

- Кеширование (техника ускорения вычислений и экономии ресурсов). Кеширование в HTTP очень сильно влияет на производительность web-приложений.
- Отладка. Способность быстро находить источник проблемы и устранять его. Резко падает количество магии.
- Производительность. Последние версии протокола позволяют очень эффективно использовать каналы связи.
- Безопасность. Через сеть постоянно передаются секретные данные (пароли, ключи, личная информация). Держать их в секрете получится только зная как работает HTTP.
- Дизайн (Архитектура). Правильное использование HTTP позволяет делать поведение сайтов и приложений (мобильных) гораздо более предсказуемым, устойчивым к ошибкам, простым в обслуживании.
- Аутентификация. Способность сайтов запоминать пользователей тоже базируется на возможностях HTTP (cookies).

Этот курс знакомит с HTTP на самом фундаментальном уровне, который не зависит от используемого языка, браузера и технологий. Он рассказывает про устройство самого протокола и учит правильно его использовать.

## HTTP 1.0—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/135604487" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

HTTP – текстовый протокол, с помощью которого взаимодействуют клиент, например, браузер и сервер. Работает это так. Пользователь шлёт определенный запрос на сервер, запрашивая или передавая нужные данные, а сервер, в зависимости от запроса, выполняет нужную логику и возвращает результат, обычно это HTML-страница либо редирект.

Для того, чтобы посмотреть, как работает HTTP, мы сделаем запрос к серверу google и разберём, как он выглядит. Для этого используется специальная утилита, которая называется _telnet_ ([пример HTTP-запроса, выполненного с помощью утилиты telnet](https://asciinema.org/a/10703)).

```
## Передаем адрес сайта и указываем tcp порт
## После этого происходит подключение к серверу по протоколу tcp
telnet google.com 80
```

HTTP – протокол прикладного уровня. Другими словами, он предназначен для общения между двумя программами (клиентом и сервером), находящимися на разных компьютерах. Но, сам по себе, HTTP не может соединять два удаленных компьютера. Для этого используются другие протоколы, среди которых TCP. Именно TCP позволяет соединить программы на удаленных компьютерах, создав канал для общения друг с другом. Для этого нужно знать два параметра: ip-адрес компьютера, к которому нужно подключиться, и порт, на котором "висит" нужная программа.

Команда telnet выше делает именно это, она выполняет соединение по TCP и только после этого входит в режим взаимодействия по HTTP. При условии, что указан правильный ip-адрес и порт для соединения. И на этом моменте возникает два вопроса:

Мы передали адрес сайта, откуда берется ip-адрес? Любой адрес сайта это просто имя, за которым скрывается ip-адрес. Имя задано для удобства, так его проще запомнить. Однако все сетевые программы, среди которых браузеры и telnet, выполняют преобразование имени сайта в его ip-адрес. Делается это с помощью системы DNS, еще одного столпа интернета.

```
## Пример того как можно узнать ip-адрес с помощью утилиты ping
## В вашем случае адрес может быть другим, ip-адреса могут меняться
ping google.com ## 74.125.21.139

## Затем можно использовать его для соединения с сервером
telnet 74.125.21.139 80
```

Почему порт имеет номер 80? Это общепринятое соглашение. Сайты, доступные по HTTP, доступны на порту 80, а по HTTPS – на порту 443. Именно поэтому в браузерах порты не указываются, браузер подставляет их автоматически.

Если соединение произошло успешно, то telnet выводит на экран такие строчки:

```
telnet google.com 80

Trying 74.125.21.139...
Connected to google.com.
Escape character is '^]'.
```

После подключения веб-сервер входит в режим ожидания HTTP-запроса. Осталось его послать.

### Что из себя представляет сам запрос?

![HTTP запрос](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImMxOTMyMjZkNGU3NzdlYmQxMTNmN2ZjZjZlYzM0MDdhLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f7429f7f338b17bd459f5f22023aaa246007ed1a9ff1d50972780e1a35140807)

Запрос состоит из нескольких частей. Первая часть — _request line_. Вторая — заголовки.

В _request line_ мы указываем специальное слово, ещё говорят глагол. В HTTP описаны разные глаголы, но мы сейчас не будем вдаваться в подробности. Просто скажем, что они определяют, как реагировать на этот запрос. И в данном случае мы будем использовать глагол HEAD. Он очень простой, и просит сервер отдать только заголовки, без содержимого. Более распространённым является GET. Именно с помощью GET мы запрашиваем содержимое сайта.

После глагола указывается путь к ресурсу _request URI_. Если мы указываем `/`, это обозначает просто корень сайта. Дальше всё, что нужно сделать, это указать название протокола и его версию. В этом курсе рассматриваются только версии HTTP 1.0 и 1.1, это основа протокола и знакомство с ним стоит начинать именно c них. Между версиями есть принципиальные отличия, которые нужно хорошо знать и понимать. Версия 1.0 продолжает использоваться в различных целях утилитами командной строки.

В принципе этого достаточно, и для 1.0 больше ничего делать не нужно:

```
HEAD / HTTP/1.0
```

Дальше идут заголовки. Что это? Заголовки позволяют передавать дополнительную информацию, например браузеры предоставляют информацию о себе, чтобы было понятно откуда идет запрос. Кроме этого они указывают какие форматы сжатия поддерживают, в каком формате готовы принимать ответ и так далее. Количество стандартных заголовков достаточно большое, помимо них можно добавлять любые свои.

Давайте рассмотрим, как выглядят заголовки. Мы указываем имя и через двоеточие какое-то значение: _REFERER: value_. Заголовки часто указывают заглавными буквами, но регистр здесь не важен. Порядок заголовков также не специфицирован. В каком бы порядке мы не передали заголовки, тело ответа будет разбираться только всё вместе.

Браузерами используется много заголовков, например _user-agent_. Этот заголовок используется для аналитики, а также, когда необходимо адаптировать страницы сайта под разные экраны или браузеры. Но и без него все должно работать:

```
HEAD / HTTP/1.0
User-Agent: google сhrome
```

Важно помнить, поскольку это протокол, и у него есть определенные правила, то нарушать их нельзя. HTTP — текстовый протокол. Все правила основаны на простых соглашениях. Например, несколько заголовков отделяются друг от друга переводом строки (и никак иначе!). Мы не можем записать их в одну строку, через запятую или как-то ещё. Всё очень строго. А каким образом сервер поймёт, что вы закончили передавать данные? Это должен быть какой-то маркер, определитель. В HTTP это делается с помощью двух переводов строки. После этого сервер считает что все данные были отправлены и больше данных не будет. То есть фактически два перевода строки (перевод после последнего заголовка и пустая строка) приводят к отправке данных.

### Что из себя представляет ответ?

![HTTP ответ](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjhkZTAwYmIwZWMzNDRlN2RjMzg1ZjdlOWE2M2EwZTFmLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9d4c6ac9d36c1683ba5bce30cd796875176879ef8ec6acfb4de42be757d3e288)

Давайте сделаем запрос и посмотрим, что нам вернётся в ответ. Сделаем HEAD запрос и посмотрим, что будет возвращено:

```
telnet google.com 80

Trying 64.233.164.100...
Connected to google.com.
Escape character is '^]'.
HEAD / HTTP/1.0

HTTP/1.0 200 OK
Date: Sat, 18 Jan 2020 09:24:50 GMT
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
P3P: CP="This is not a P3P policy! See g.co/p3phelp for more info."
Server: gws
X-XSS-Protection: 0
X-Frame-Options: SAMEORIGIN
Set-Cookie: 1P_JAR=2020-01-18-09; expires=Mon, 17-Feb-2020 09:24:50 GMT; path=/; domain=.google.com; Secure
Set-Cookie: NID=196=wsHLMAMfnAaSyF7zduokI8TJeE5UoIKPHYC58HYH93VMnev9Nc2bAjhRdzoc4UhmuOd7ZVCorDnzGDe51yPefsRMeVyOFnYdHYYgQNqI8A1dYuk4pDK4OJurQgL4lX8kiNGSNi_kkUESFQ-MqLCB_YspxA9JRejhZdkTRtGyHNk; expires=Sun, 19-Jul-2020 09:24:50 GMT; path=/; domain=.google.com; HttpOnly
Accept-Ranges: none
Vary: Accept-Encoding

Connection closed by foreign host.
```

В ответ к нам приходит _response_. Он состоит из _status line_ `HTTP/1.0 200 OK`. Это строка ответа, в которой указан протокол (здесь он совпадает) и статус ответа `200 OK`. В HTTP определено множество различных статусов (400, 500 и т.д.). Они могут информировать, что информация была не найдена, были ошибки на сервере и т.д. Все статусы имеют мнемоническое название, которое передается так же последним значением. 200 и `OK` обозначает, что всё прошло хорошо — _success_!

Далее выводится большое количество различных заголовков. В них нет ничего сложного, и их не нужно все учить (есть какие-то общие, и они достаточно понятны). Все заголовки состоят из ключа, двоеточия и значения. Можно заметить, что есть вещи связанные с кодировкой, кешированием. Некоторые заголовки специфичны для текущего сервера. Например, `X-XSS-Protection: 0`, где `X` указывает на кастомный заголовок. Но никакой веб-сервер, никакой веб-браузер не будут ломаться при посылке таких дополнительных заголовков.

Именно в HTTP 1.0 в конце после получения данных происходит закрытие соединения.

В конце мы видим одну интересную деталь: _Connection closed by foreign host._ Запрос соединения был закрыт внешним хостом. Так работает практически всё в интернете. Обычно сервера настроены на 30-секундный интервал и закрывают соединение, если в течение этого интервала ничего не приходит.

Поэтому с telnet новичкам работать чуть тяжелее. Они медленно набирают запрос, и за это время соединение закрывается, что довольно неприятно. Поэтому лучше делать записи в отдельном файле и после этого вставлять их в telnet.

---

##### Дополнительные материалы

1. [DNS](https://guides.hexlet.io/dns/)

## HTTP 1.1—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/135604484" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

Протокол HTTP 1.1 расширяет возможности предыдущей версии и добавляет виртуальные хосты. Сейчас мы посмотрим, для чего это нужно, и как это работает.

Предыдущая версия требует наличия только _request line_. В ней мы описываем, какой путь на сайте мы хотим посмотреть (_query string_). Но упоминания сайта как такового здесь нет. При этом мы подключаемся по telnet к конкретному IP адресу. Отсюда можно сделать вывод, что понятие домена (доменного имени) при использовании HTTP 1.0 не важно. Действительно, эта версия была создана в те времена, когда считалось, что один IP адрес соответствует одному сайту. Естественно это не могло продолжаться долго, потому что рост интернета был стремительный. И HTTP 1.1 ввел такое понятие как виртуальные хосты. С точки зрения реализации в протоколе HTTP, появилась одна небольшая деталь. Кроме request line стал обязательным ещё и заголовок, который называется host. Он определяет, какой именно домен должен быть возвращён с этого IP адреса.

```
HEAD / HTTP/1.1
host: hexlet.io
```

На самом деле, иногда в поведение HTTP и серверов заложены какие-то умолчания, например, они могут исправлять ошибки пользователей. То есть можно сделать запрос HTTP 1.1 без указания хоста и получить что-то в ответ. По-хорошему такой запрос вообще не должен проходить, но часто веб-серверы отдают сайт, который указан в настройках по дефолту. Например, в Nginx есть сайт по умолчанию. Но так нельзя делать запросы в принципе, это не соответствует стандарту. Нужно всегда указывать хост, иначе ответ не гарантирован. Сегодня он один, а завтра другой. Некоторые библиотеки вообще могут так не работать. Виртуальные хосты являются неотъемлемым атрибутом HTTP 1.1. Их нельзя игнорировать.

Сейчас мы можем сделать GET-запрос с использованием протокола версии 1.1 и посмотреть, что он нам вернет:

```
telnet google.com 80

GET / HTTP/1.1
host: google.com

HTTP/1.1 301 Moved Permanently
Location: http://www.google.com/
Content-Type: text/html; charset=UTF-8
Date: Fri, 28 Feb 2020 06:06:40 GMT
Expires: Sun, 29 Mar 2020 06:06:40 GMT
Cache-Control: public, max-age=2592000
Server: gws
Content-Length: 219
X-XSS-Protection: 0
X-Frame-Options: SAMEORIGIN

<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY>
<H1>301 Moved</H1>
The document has moved
<A HREF="http://www.google.com/">here</A>.
</BODY></HTML>
```

Как мы уже знаем, есть много разных кодов. В итоге мы получили ответ, который отличается от 200. Здесь есть ещё одна интересная деталь, которая введена в HTTP 1.1, и на которую стоит обратить внимание. После выполнения запроса мы не выпали из telnet и не оказались в bash. Это значит, что подключение не было закрыто, и мы можем продолжить вводить данные. Cделаем HEAD-запрос на тот же самый домен:

```
HEAD / HTTP/1.1
host: google.com

HTTP/1.1 301 Moved Permanently
Location: http://www.google.com/
Content-Type: text/html; charset=UTF-8
Date: Fri, 28 Feb 2020 06:11:31 GMT
Expires: Sun, 29 Mar 2020 06:11:31 GMT
Cache-Control: public, max-age=2592000
Server: gws
Content-Length: 219
X-XSS-Protection: 0
X-Frame-Options: SAMEORIGIN
```

Мы снова получили ответ, но уже без body, поскольку использовали HEAD, а не GET-запрос.

![Механизм работы keep-alive](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjMxYTI5YjFiZTEyMTJiY2ZmZGYxMDQzZjA5NGIyNTZlLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c50e693e6ccd7f9b940635ab9a7b294ebb03db8109702d015bb36c5ba887e91f)

HTTP 1.1 вводит ещё одно понятие по умолчанию, которое называется _keep-alive_. _keep-alive_ означает, что соединение TCP, по которому ходит HTTP, не закрывается. Причём по умолчанию так должны себя вести все веб-сервера. Основная цель введения этой фичи в том, чтобы сократить использование ресурсов, уменьшить нагрузку на процессор, открывать меньше TCP-соединений (установка каждого TCP-соединения занимает время), уменьшить время ожидания (latency). Когда мы открываем сайт, то обычно с одного домена грузится несколько ресурсов. _keep-alive_ позволяет открывать и использовать одно соединение, которое не будет закрыто до тех пор, пока это не будет указано явно, либо не произойдет таймаут. Таймаут зависит от того, какой браузер и какой веб-сервер используется.

Мы также можем указать, что хотим закрыть соединение. Для этого после установки соединения и передачи стандартных заголовков нужно передать еще один заголовок. Он называется `connection: close`. Тогда _keep-alive_ будет отключен, и после получения ответа мы увидим собщение, что хост закрыл соединение: _Connection closed by foreign host_.

---

##### Дополнительные материалы

1. [Стандарт HTTP 1.1](https://www.ietf.org/rfc/rfc2616.txt)
2. [Википедия / Постоянное HTTP-соединение](https://ru.wikipedia.org/wiki/Постоянное_HTTP-соединение)

## Тело HTTP-запроса—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/135604486" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

HTTP _request_ и _response_ могут содержать так называемое тело (_body_).

![Структура и тело запроса](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijg0MThkYWQyMDRjNzAwNTIzMWYwNjc5YjM2ZDcxNmJkLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=672804ba817b02bcbbb5b4241803fb3fafa403e97cfe05ede563b15e354513e1)

Мы уже знаем, что сам HTTP запрос состоит из заголовков и опционального тела запроса. Для отделения заголовков от тела существуют определенные правила. Давайте посмотрим на примере, как работать с _body_ и каким образом посылать какие-то данные кроме заголовков. Сделаем HTTP запрос к хосту _hexlet.io_:

```
telnet hexlet.io 80

GET / HTTP/1.1
Host: hexlet.io

HTTP/1.1 301 Moved Permanently
Cache-Control: private
Content-Type: text/html; charset=UTF-8
Referrer-Policy: no-referrer
Location: https://34.102.241.4/
Content-Length: 218
Date: Tue, 07 Jul 2020 03:50:16 GMT

<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY>
<H1>301 Moved</H1>
The document has moved
<A HREF="https://34.102.241.4/">here</A>.
</BODY></HTML>
```

В ответ мы получаем какие-то заголовки и далее идёт тело, которое нас как раз и интересует. В данном случае это не какая-то страница нашего сайта, а просто страница которую отдаёт сервер. Она связана с перенаправлением.

Если с заголовками всё понятно, они отделяются друг от друга переводом строки и для отправки мы добавляем еще один перевод, который выглядит как пустая строка. То как быть с телом запроса? Оно может содержать внутри всё что угодно. Мы не можем кодировать перевод строки как специальный символ. Ведь те самые два перевода строки могут находиться внутри тела запроса. Но существуют и другие причины по которым в текстовом протоколе нельзя просто так определить когда заканчивается тело. Если бы мы приняли ответ при отсутствии каких-то специальных механизмов, то после того как сервер отправил первые два перевода строки мы сразу увидели бы ответ и всё что посылалось дальше вообще не считалось бы частью ответа HTTP _response_. Для решения этой проблемы был придуман другой, более универсальный механизм. Он основан на передаче специального заголовка.

Во время отправки ответа сервер формирует специальный заголовок, который называется _Content-Length_. Это и есть ключ к тому как работать с _body_. Перед тем как отправить тело ответа, происходит вычисление его длины и записывается количество байт.

```
## число — количество байт
Content-Length: 218
```

После того, как передан такой заголовок другая сторона будет ожидать ровно столько байт, сколько в нём указано. Как мы помним, для _response_ и _request_ это работает абсолютно одинаково. После того как был передан последний символ, соединение закрывается. Стоит уточнить, что закрывается именно HTTP-сессия. На сервере может быть активен _keep-alive_, но ключевой момент в том, что запрос считается завершённым и отображается.

Указание размера тела нужно не только для отправки ответа, но и при запросах, когда на сервер посылаются, например, данные формы.

Практика показывает, что не все серверы правильно работают при наличии только заголовка _Content-Length_. Им не хватает еще одного. Тип содержимого запроса или ответа, которое содержит _body_, должен быть как-то идентифицирован. По умолчанию в стандарте сказано, что сервер может сам попытаться определить содержимое контента на основе различных способов. Например, мы в _query string_ делаем запрос _image.png_.

```
POST /image.png HTTP/1.1
```

Совсем не обязательно, но сервер может понять, что это картинка в формате png, и как-то это использовать. Во всех остальных случаях, когда сервер не может определить тип контента, он должен использовать заголовок _Content-Type: application/octet-stream_. Это означает, что в теле запроса передаётся просто поток байт. Хотя серверы должны работать именно так, но часто всё происходит по другому. Если указан только _Content-Length_, то сервер отказывается принимать данные. Он просто закрывает соединение после двух переводов строки, еще до _body_. Этот нюанс выяснен экспериментальным путём.

Еще одно замечание по поводу _body_. С точки зрения стандарта HTTP тело может присутствовать в любом запросе и никак не связано с глаголом. Посылать _body_ можно в _HEAD_, _POST_, _PUT_ и других запросах. Если мы посылаем _body_ с _GET_, хотя это не описано в стандарте, сервер никак не будет на это реагировать, более того, он и не должен, так как с практической точки зрения это не имеет смысла. Также есть типы запросов при которых он не будет посылать в ответ _body_ ни в коем случае. Например, ответ на _HEAD_, когда мы запрашиваем только заголовки, так как такова семантика этого глагола. Еще тело не отправляется, когда мы получаем в ответ такие статусы как 204 — нет контента и некоторые другие.

---

##### Дополнительные материалы

1. [Википедия / Тело сообщения](https://ru.wikipedia.org/wiki/HTTP#.D0.A2.D0.B5.D0.BB.D0.BE_.D1.81.D0.BE.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.B8.D1.8F)
2. [Формат HTTP-запросов](http://citforum.ru/internet/cgi_tut/rqst.shtml)
3. [Формат HTTP-ответов](http://citforum.ru/internet/cgi_tut/spns.shtml)

## Отправка форм—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/135943271" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

В этом уроке мы рассмотрим особенности отправки форм в HTTP. Работать будем с локально поднятым сервером, так как со сторонними серверами при тестировании на них наших уроков возникают сложности. В принципе, вы можете поэкспериментировать на любом доступном сервере. Только убедитесь, что он работает по HTTP, а не по HTTPS, так как там взаимодействие происходит немного по-другому и одного telnet будет недостаточно.

При отправке формы мы отправляем какие-то данные и, так как в HTTP не предусмотрены специальные места для отправки данных из форм, они отправляются в теле запроса. При этом в зависимости от того, какой заголовок _Content-Type_ установлен, интерпретируется то, как будут закодированы данные при отправке. Обычно используется следующий формат _Content-Type: application/x-www-form-urlencoded_. Это простой формат — ключ равно значение и амперсанд между ними.

```
login=smith&password=12345678
```

Таким нехитрым способом, мы можем продолжать строку, передавая столько данных, сколько захотим. Теперь попробуем сделать запрос к нашему локальному серверу.

```
telnet localhost 8080

POST /login HTTP/1.1
Host: hexlettesthost.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

login=smith&password=12345678 ## отправляем данные
HTTP/1.1 200 OK
X-Powered-By: Express
Connection: close
Content-Type: text/html; charset=utf-8
Content-Length: 7
ETag: W/"c-r0WEeVxJ7IpMIG20rN7HX9ndB4c"
Date: Thu, 09 Jul 2020 03:32:54 GMT

Done!
Connection closed by foreign host.
```

После отправки сервер, получив те 29 символов, которые мы указали в _Content-Length_, сразу отправляет нам ответ _HTTP/1.1 200 OK_, в _body_ которого одно слово `Done!`. Как видим, в ответе также присутствует _Content-Length_ равный `7`.

Есть еще несколько особенностей, которые нужно знать, когда мы работаем с формами в HTTP. Первая из них связана с кодированием. Поскольку это текстовый формат, то в нём очень легко допустить различные неоднозначности. Предположим в пароле используется знак `=`.

```
login=smith&password=1234=5678
```

Каким образом правильно распарсить этот результат? Не исключено, что сервер поймёт то, что мы отправляем, так как парсинг происходит слева направо, но это ничем не гарантировано. Более того, в названии поля также могут быть специальные символы. Поэтому все, что отправляется на сервер, должно быть закодировано. Обычно кодированием занимаются браузеры. Но в целом, если вы пишете какие-то скрипты и используемые библиотеки об этом не заботятся, это должны сделать вы. Закодированный символ `=` выглядит так — `%3D` и не важно, какой это запрос: _POST_ или _GET_. Такие закодированные последовательности символов вы можете часто видеть в адресной строке браузера. _body_ с закодированным `=` приводится в примере ниже:

```
login=smith&password=1234%3D5678
```

Еще одна особенность связана с тем, что иногда нам нужно отправить данные вложенные друг в друга. Например, массив опций. В таком случае тело может выглядеть так:

![Кодирование данных формы](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImZmY2Q2Yzc2OWE3ZmVhZWE0NjYzZDcwZmI3MzUzNzhhLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f517103b6a0ff4efdd016b0f05d6bafd30bd9e8e2eb77f556929648a38afb4c7)

```
user[login]=smith&user[password]=12345678
```

Нюанс в том, что HTTP не умеет работать с такими данными. Их обработкой занимаются мидлвары (англ. middlewares — промежуточное программное обеспечение). Но если вы, например, пишете свою собственную реализацию сервера, вам придется парсить такие данные самостоятельно.

### Другие способы кодирования

Помимо обычного кодирования _ключ=значение_ существуют и другие форматы, но самым популярным на сегодняшний день является формат JSON. У него достаточно много преимуществ, в числе которых:

- JSON представляет из себя строку, что и необходимо при передаче данных по сети
- Не зависит от языка
- С его помощью можно описывать сложные иерархические структуры
- Легко читается человеком

В данный момент он считается стандартом для обмена информацией между сервисами в интернете. Строка JSON выглядит следующим образом:

```
{
    "firstName": "John",
    "lastName": "Smith",
    "children": [
        {
            "firstName": "Max",
            "lastName": "Smith",
        },
        {
            "firstName": "Annie",
            "lastName": "Smith",
        }
    ]
}
```

Для отправки данных в этом формате используется заголовок _Content-Type: application/json_.

---

##### Дополнительные материалы

1. [Отправка данных по HTTP](https://developer.mozilla.org/ru/docs/Learn/HTML/Forms)
2. [JSON](https://ru.wikipedia.org/wiki/JSON)

## Transfer-Encoding—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/136121888" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

Иногда данные, которые передаются серверу, могут быть достаточно большими. И более того, мы можем не знать их конечный размер. Например, если нужно скачать архив или во время видео-трансляции.

Для решения этой проблемы можно загрузить данные полностью в оперативную память на сервере, вычислить _Content-Length_ и осуществить передачу. После того, как контент будет целиком принят браузером, тот его моментально отобразит.

![Передача данных чанками](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImFlNTBhMmQyM2YwNjdjMmI3ODUyMGE2ZThjYWZmMzIwLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=3af55b25e0ac241058a004ef8f8c5d34d14086ec48d10bfa67c9357958a1b104)

Существует еще одно решение, которое позволяет надежно передавать данные, когда мы не знаем их конечный размер. По [ссылке](https://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx) находится пример изображения, которое отрисовывается постепенно по мере того, как происходит передача данных. Для этого используется механизм передачи небольшими частями, чанками (англ. chunks), и специальный заголовок _Transfer-Encoding_ со значением _chunked_.

В стандартном ответе мы получаем всё _body_ целиком и после этого его обрабатываем. Мы не можем обрабатывать его частями потому, что тогда будем вводить какие-то свои уникальные правила внутри протокола. Но при передаче чанками мы можем обрабатывать ответ до полного получения _body_.

Сделаем запрос к сайту _httpwatch.com_:

```
telnet httpwatch.com 80

GET https://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx HTTP/1.1
Host: httpwatch.com
Connection: close

HTTP/1.1 200 OK
Cache-Control: no-cache, no-store
Pragma: no-cache
Trailer: X-HttpWatch-Sample
## вместо Content-Length здесь заголовок Transfer-Encoding
Transfer-Encoding: chunked
Content-Type: image/jpeg; charset=utf-8
Expires: -1
Server: Microsoft-IIS/10.0
X-AspNet-Version: 4.0.30319
X-Powered-By: ASP.NET
Arr-Disable-Session-Affinity: True
Date: Fri, 10 Jul 2020 09:18:05 GMT

400 ## длина чанка
Какие-то данные первого чанка
400
Данные второго чанка
400
и так далее
0 ## последний чанк нулевой длины
```

Обратите внимание, что заголовки как всегда отделяются от тела запроса переводом строки. В начале каждого чанка указывается его размер. За ним располагаются данные и в конце чанка делается перевод строки, затем идёт следующий чанк и так далее. Таким образом можно передавать сколько угодно чанков, время ограничено только таймаутами внутри сервера.

Чтобы завершить передачу, нужно передать последний чанк, который должен быть нулевой длины. После него делается два перевода строки и запрос считается полностью переданным.

### Формат сообщений

Для отделения записей размеров блоков (частей) от их содержания используется разделитель CRLF (как строка: «\r\n»; как байты в формате HEX: 0x0D, 0x0A). Длина блока — это размер содержания блока, разделители CRLF не учитываются.

Схематическое представление: `<длина блока в HEX><CRLF><содержание блока><CRLF>`

Последний блок строится по той же схеме, потому имеет следующий вид по причине отсутствия содержания: `0<CRLF><CRLF>`

[Стандарт](https://tools.ietf.org/html/rfc2616#section-3.7.1) также позволяет использовать в качестве разделителя только CR или только LF.

---

##### Дополнительные материалы

1. [Ссылка на изображение, передаваемое с помощью chunks (пример из видео)](https://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx)
2. [Chunked transfer encoding / Википедия](https://ru.wikipedia.org/wiki/Chunked_transfer_encoding)
3. [RFC2616 Hypertext Transfer Protocol](https://tools.ietf.org/html/rfc2616)

## Передача данных query string—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/136285605" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

Помимо того, что данные на сервер можно передавать через _body_, которое используется при _POST_ запросах и отправке форм, мы также можем передать так называемую строку запроса _query string_. Это параметры _ключ=значение_ которые располагаются в _request line_ после указания глагола _POST_ или _GET_.

```
POST /login?key=value HTTP/1.1
```

Стоит сказать, что указатель на конкретную страницу может отсутствовать и параметры можно передавать на основную страницу домена.

```
GET /?key=value HTTP/1.1
```

_query string_ имеет такой же формат как и строка в _body_ при _POST_ запросе, только в начале ставится знак `?`. После него мы можем передавать параметры `key=value&key2=value2` и так далее.

![Структура query string](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjhlYTE0OTVmMzMxYWQ5MTJhZTliMmYwNjM4OTQxYTBlLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c5378d5fb74a9887573f9a97b7efde714a8ed8593b6c07d92f953ad9819f48e1)

Параметры _query string_ не имеют никакого отношения к _GET_-запросам, хотя многие разработчики называют их _GET_-параметрами. На собеседованиях иногда задают вопрос: "Можно ли одновременно отправить _POST_ и _GET_ параметры?". Правильный ответ — конечно можно, так как никакой связи между ними нет. Более того, в некоторых языках существуют способы получения этих данных отдельно друг от друга. Например, в PHP есть глобальный массив `$_REQUEST`, в который попадают как параметры, переданные через _query string_, так и переданные в _POST_.

Но как понять, когда и для чего использовать _query string_? Для этого нужно определить, что на самом деле значат глаголы HTTP. Семантика HTTP-глаголов выражается не только в том, какой вам будет возвращён ответ, а еще и в том, как можно с ним работать. Глагол _GET_ считается идемпотентным. Это означает, что его повторное выполнение всегда возвращает один и тот же результат, т.е. это обычный запрос. Мы спрашиваем систему о чём-то, она возвращает нам данные и при этом не изменяет своего внутреннего состояния. Таким образом любой повторный запрос отработает точно так же — детерминировано. В качестве аналогии можно привести чистую функцию. В реальности состояние системы конечно же может поменяться и мы не можем это контролировать, поэтому кэширование не является тривиальной задачей.

_POST_-запрос, напротив, не является идемпотентным и предназначен для изменения данных. Таким образом повторный запрос может приводить к другим результатам. Если первым _POST_-запросом мы удаляем данные, то вторым получим ошибку _404_. Такие запросы никогда не кешируются.

Поисковые роботы ходят по сайтам только по _GET_-ссылкам, так как они учитывают семантику и знают, что _GET_-запросы можно делать безболезненно и с сайтом ничего страшного не произойдет.

Параметры _query string_ в _GET_-запросах используются при работе с формами, которые бывают как минимум двух типов: на изменение, создание или добавление данных и на их выборку. Именно при разработке второго типа форм и используется _query string_. Это может быть какая-то фильтрация или поисковая форма. Если мы в поисковике наберём запрос, например, какое-то слово и нажмем кнопку _Поиск_, то увидим, что нас отправит на страницу, в URI которой будет отправлен _query string_. Это очень важный момент, так как именно благодаря этому мы не производим никаких изменений и можем дать ссылку на этот запрос. Очень важно придерживаться семантики глаголов. Например, в некоторых старых банковских системах запросы почему-то реализовывались через _POST_. При таком подходе нельзя не только дать ссылку на запрос, но даже простое обновление страницы с помощью F5 приводит к повторной отправке данных.

---

##### Дополнительные материалы

1. [Query String / Wikipedia](https://en.wikipedia.org/wiki/Query_string)
2. [RFC 3986 (соответствующий стандарт)](https://tools.ietf.org/html/rfc3986)

## Перенаправления—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/136735227" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

Давайте посмотрим, как в HTTP работают редиректы. Если сделать запрос на hexlet.io, то в ответ мы получим редирект:

```
telnet hexlet.io 80
GET / HTTP/1.1
host: hexlet.io

HTTP/1.1 301 Moved Permanently
Date: Thu, 14 May 2020 15:00:05 GMT
Transfer-Encoding: chunked
Connection: keep-alive
Cache-Control: max-age=3600
Expires: Thu, 14 May 2020 16:00:05 GMT
Location: https://hexlet.io/
Server: cloudflare
CF-RAY: 59357c73fadaf2a0-WAW
cf-request-id: 02b54c363b0000f2a07c8f0200000001

0
```

Это связано с тем, что hexlet.io работает только по HTTPS. Но HTTP он тоже обрабатывает. Ведь браузеру, который будет обращаться к сайту, нужно подсказать, что нужно сделать редирект.

![301 Redirect](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjlkZGNiZDZjYWRlMzRiMjlmN2E5OGU1YTIxNWRlZjFlLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=1502c459596070382dc92e8edb5c8f5cfc4a73747eed6f64e761df54f129a7e8)

Как это работает? Возвращается заголовок 300 (формат редиректов). В нашем примере мы видим _301 Moved Permanently_. Это означает, что ресурс, на который послали запрос, перемещён навсегда, и больше не имеет смысла сюда никогда заходить. Этим активно пользуются при SEO. Поисковики сохраняют все параметры страниц по старому адресу в индексе.

Редиректы бывают разных видов, например, временный редирект _302 Found_. Он используется, если что-то произошло: сайт не работает, заблокирован и т.д. В основном это технические истории.

Но как узнать, куда происходит перенаправление? И вновь никакой магии — всё основано на заголовках. В принципе не важен даже _body_. В зависимости от того, как работает система, через которую послан запрос, _body_ может отобразиться, а может и нет. Главное, что появляется заголовок _Location_. Он обязан быть в случае такого статуса ответа, который указывает то место, куда нужно перейти.

Всё. Дальше, браузер сделал бы перенаправление автоматически. Но так как мы находимся в telnet, то никакую работу он за нас не делает и просто возвращает этот редирект.

Иногда на сайтах происходят ошибки, и те постоянно выдают редиректы. Браузер будет пытаться бесконечно переходить по ним. Чтобы не убить систему, существуют различные защиты. Например, они умеют отслеживать циклические редиректы, и сообщать о том, что необходимо остановить работу.

Библиотеки, с которыми часто работают программисты, обычно имеют опции, которые говорят, нужно ли следовать за редиректом, и если следовать, то на какую глубину.

---

##### Дополнительные материалы

1. [HTTP 301](https://ru.wikipedia.org/wiki/HTTP_301)

## Базовая аутентификация—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/136828406" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

HTTP обладает фичей, которая называется базовая аутентификация. Работает она следующим образом.

![Схема работы базовой аутентификации](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImQ0ZjEwYzMyMjI1ZWZkZTRjNzlmOTVmZGU3YjE1MmIzLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=20d579722df3c453f68cfa6936de5a74e07874a2c8d1b3efdf70acbfbbf2a633)

При заходе на конкретную страницу или сайт, которые требуют аутентификации, вы увидите окно авторизации. Окно рисуется браузером и требует ввода имени и пароля.

Обычно, если ввести неправильные данные, то браузер запросит их повторно. А если нажать на _Сancel_, то мы получим ошибку с кодом 401. Т.е. при любой попытке зайти на страницу, которая требует базовой авторизации, будет получен ответ 401. При этом нет разницы между отправкой формы с некорректными данными и кликом на кнопку _Сancel_.

В итоге браузер рисует эту форму, когда встречает ошибку 401. Работает она очень просто: либо вы отсылаете правильный заголовок (правильные данные) либо получаете ошибку 401. Никакой магии, никаких вариантов действий.

Давайте посмотрим, какие данные требуются при таком взаимодействии:

```
HTTP/1.1 401 Access Denied
WWW-Authenticate: Basic realm="My Server"
Content-Length: 0
```

Вы не можете зайти и получаете `Access Denied` и заголовок от сервера `WWW-Authenticate: Basic realm="My Server"`. В этом заголовке есть ключ, значение которого выводится в диалоговом окне. Больше оно нигде не используется.

После ввода логина и пароля происходит отправка следующих заголовков:

```
GET /securefiles/ HTTP/1.1
Host: www.httpwatch.com
Authorization: Basic aHR0cHdhdGNoDmY=
```

Во-первых, это стандартные заголовки для HTTP 1.1. Во-вторых (и это самое главное), заголовок _Authorization_, в котором есть обязательное слово `Basic` и после пробела закодированая фраза. Эта фраза состоит из имени пользователя и пароля — `<username>:<password>`, закодированных в _base64_.

Этого достаточно. После отправки корректных данных происходит аутентификация, и вы получаете доступ на сайт или страницу, к которому обратились.

---

##### Дополнительные материалы

1. [Basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication)

## Cookies—Протокол HTTP

<iframe allowfullscreen="true" allowscriptaccess="always" src="https://player.vimeo.com/video/136920265" style="box-sizing: border-box; border: 0px; height: 417.656px; left: 0px; position: absolute; top: 0px; width: 742.5px;"></iframe>

Видео может быть заблокировано из-за расширений браузера. В [статье](https://help.hexlet.io/ru/articles/111155-ne-zagruzhaetsya-video-ili-blok-na-sayte) вы найдете решение этой проблемы.

HTTP является протоколом без сохранения состояния (англ. stateless protocol). Это означает, что каждая пара запрос-ответ не связана с предыдущим запросом-ответом. В реальной жизни это оказывается не очень удобно, так как иногда нам нужно запомнить аутентификацию пользователя или, например, хранить данные корзины с товаром пользователя в интернет-магазине. Тут возникает проблема: "Как запомнить, что это тот пользователь, с которым мы только что работали?" Решение этой проблемы было найдено более 10 лет назад, когда был придуман механизм, который называется — Cookie.

![Механизм работы cookie](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQxMTYyOTY2MzIyMjEwOTc0YjBmZTA3NGRkYjI2OGJjLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a4f094e788f5f8edbb511ec3b77dacc8fa91dbef85fc6093982fae7cc137a521)

Давайте сделаем запрос к сайту Хекслета и посмотрим как этот механизм работает. Мы будем использовать программу [_curl_](https://ru.wikipedia.org/wiki/CURL). Она позволяет делать HTTP запросы и флагами управлять различными их параметрами. В отличие от _telnet_ нам не нужно заранее устанавливать соединение и потом набирать сырой запрос. При работе с _curl_ можно сразу определить параметры и она сама отправит все нужные заголовки запроса, в том числе и по HTTPS.

Давайте выполним запрос для получения только заголовков, для этого добавим к запуску _curl_ флаг _--head_.

```bash
curl --head https://ru.hexlet.io

HTTP/2 200
server: nginx/1.19.1
date: Thu, 16 Jul 2020 03:38:11 GMT
content-type: text/html; charset=utf-8
vary: Accept-Encoding
x-xss-protection: 1; mode=block
x-content-type-options: nosniff
x-download-options: noopen
x-permitted-cross-domain-policies: none
referrer-policy: strict-origin-when-cross-origin
strict-transport-security: max-age=0
x-frame-options: ALLOW-FROM http://webvisor.com
etag: W/"eb99fa0d6ee702b85ba2a5e9b0425aea"
cache-control: max-age=0, private, must-revalidate
content-security-policy:
set-cookie: _hexlet_session2=AiUPd6RFbcrnoGnZSLAYSBzdJqxsQ4sTc%2BW0xXuOKzlenyv5GwkkbpdkD6IVDybDlD8vQcOcgGax98%2FmzIBJrz9f%2BDIJxWRpknZsRSfBXuC9yRfndovBUG6w4fTql4qp7zPozd2veFDLOU4koPVYiUQxgBLM6NkyYg%2Bhs%2BQe%2FSZezleVgMBVD%2FFC070DjV7t2eN01o26kcbd0pQsf9k1LE4JN0aDzSxu8elxLyAWkIJ5l3m%2BcI%2BpgOxk87Uwh9WdTHVuDaraiRaVJz1aZq5hr%2FgzaZiK%2Bgi6ChX60nhha1an610b1v3EE7xgkEM332uFPU0w675fHEr4APTdPDVtJRa3--qQi0cqcljC8i4klD--fXTErw9bhX7%2Fd1xfPE4Gww%3D%3D; domain=.hexlet.io; path=/; expires=Sun, 16 Aug 2020 03:38:11 GMT; secure; HttpOnly; SameSite=Lax
set-cookie: GCLB=CLTE8bzdlaS6Zg; path=/; HttpOnly; expires=Thu, 16-Jul-2020 03:39:50 GMT
x-request-id: 2f554de2-a21d-4e7d-964e-085914ac3f77
x-runtime: 0.056974
access-control-allow-origin: *
via: 1.1 google
alt-svc: clear
```

Мы видим два заголовка, которые занимаются установкой cookie — _set-cookie_. Обратите внимание, что каждая cookie посылается в отдельном заголовке. Соответственно таких заголовков может быть достаточно много. Внутри кука представляет из себя пару _ключ=значение_ и отделяется от дополнительных параметров точкой с запятой. Куки сохраняются в браузере на клиенте и при следующем запросе он отправляет их обратно на сервер. Непосредственно в браузере они никак не используются. Хорошая аналогия — это как получить номерок в гардеробе и потом вернуть его, чтобы понять какая куртка ваша. При этом сам номерок никакой ценности не представляет и его нельзя использовать самостоятельно.

Куки делятся как минимум на два типа:

- Сессионные
- Постоянные

Сессионные куки в нашем запросе не устанавливаются, так как мы видим дополнительные параметры в заголовке _set-cookie_. Если бы их не было, то кука называлась бы сессионной. Основное их отличие от постоянных в том, что как только закрывается браузер кука удаляется. Например, на некоторых сайтах, если вы не отметите галочку "запомнить меня" и после закрытия браузера зайдёте на сайт снова, то будете не авторизованы. Так происходит потому, что используется сессионная кука.

### Время жизни куки

![Время жизни куки](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjVkZDAwMTM1ZjFjMDBmMDcyZTE0YjBlNDAyNGQwNjY2LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=dbec439bc18895a803e96a29b35ed14f49a552bf4c4a6ee2018822865c600dec)

В данном случае устанавливаются постоянные куки. Они сохраняются на жёстком диске и место их хранения может быть разным в зависимости от браузера. Такие куки отличаются от сессионных тем, что можно управлять длиной их жизни при помощи параметра _expires_.

```
expires=Thu, 16-Jul-2020 03:39:50 GMT;
```

В параметре _expires_ указывается дата удаления куки, после которой она не будет отсылаться на сервер. Стоит сказать, что есть еще один параметр, который используется для тех же целей — _MAX-AGE_. В его значении указывается количество секунд по истечении которых кука будет удалена.

```
MAX-AGE=2592000;
```

Так как часть браузеров не поддерживают _MAX-AGE_, некоторые фреймворки часто устанавливают сразу оба параметра и браузеры просто игнорируют тот, который им не нужен. Таким образом заголовок _set-cookie_, который содержит два параметра _MAX-AGE_ и _expires_, считается валидным. В стандарте также говорится и о том, что регистр имени куки не имеет значения.

### Параметры domain и path

Параметры _domain_ и _path_ задают область видимости куки, то есть URL, на которые кука может отправляться. Если они не заданы, то по умолчанию кука будет пересылаться на сервер только для текущего пути и домена. В нашем примере в _path_ указан корень сайта.

```
domain=.hexlet.io; path=/;
```

То есть кука будет отправляться для всех страниц. Есть нюанс, если установлен _domain=.hexlet.io_, причём наличие точки перед именем домена не имеет значения, то кука будет работать не только для всех страниц сайта, но и для всех поддоменов. А если мы совсем не установим параметр _domain_, хотя по умолчанию его значение будет _hexlet.io_, то кука для поддоменов работать не будет.

Уникальность куки определяется тремя параметрами _key_ (имя куки), _domain_ и _path_. Это значит, что если какую-то куку нужно переустановить, например, поменять время её жизни, то при следующем запросе в _set-cookie_ эти параметры должны совпадать. Если хотя бы один из них отличается, то будет установлена новая кука.

### Удаление куки

Заголовка для удаления куки не существует, чтобы удалить её, нужно установить нулевой или отрицательный _MAX-AGE_, либо задать _expires_ в прошлом, тогда кука будет немедленно удалена.

### HttpOnly cookie

Можно заметить, что в нашем примере установлен дополнительный параметр _HttpOnly_. HttpOnly куки передаются с AJAX-запросами, но их нельзя получить через JavaScript на странице сайта. Это дополнительный уровень безопасности от XSS атак.

### Отправка на сервер

После того как мы обновляем страницу в браузере, происходит отправка следующего заголовка:

```
cookie: GCLB=CLiC7uWajOOrzAE; _hexlet_session2=gu3n8MCidqZ28VfjpzJuF74d4ohla6uYq9Q%2B2XBcalsa3VUCzURBWTXvscuzSI%2BF3lnHAN%2FUt6IJnXgkH%2B6jDKgyStVb8W%2BLHwIbypoxajN3fB5ksFT3Qu28RvDQpL6hBmqq7V2eFdfLMGtkmtcpfAUYNGffwaBAlQyQKnvhkCpEf5IIWkwWfe9Nt8dG3lIueeir9fGxZP7Fpcw9IP9HfgSansgXugtFI1rw06UhgrrK%2BEnaf4EmIgVdH6KYpDBKXpUUXz8vFRvkOMX5j%2BZNMTu%2BKDBzmGlFjcm1mCZl4ozZWDCocFO4CTW7z9LmzKYbcEGkUEhRbOu%2BTvLgVo80LilK--x3y6jxx%2FjYcLp5tr--9nrQ0XmAhtGAuIFvMYvWig%3D%3D
```

Все куки отправляются одним заголовком в формате _key=value; key=value_ без дополнительных параметров.

---

##### Дополнительные материалы

1. [HTTP Cookie / Mozilla](https://developer.mozilla.org/ru/docs/Web/HTTP/Куки)
2. [HTTP Куки / Википедия](https://ru.wikipedia.org/wiki/HTTP_cookie)
3. [RFC 6265: стандарт, описывающий cookie](https://tools.ietf.org/html/rfc6265)

## Дополнительные материалы

### [Протокол HTTP](https://ru.hexlet.io/courses/http_protocol)

1. [О курсе](https://ru.hexlet.io/courses/http_protocol/lessons/about/theory_unit)

   - Без материалов

2. [HTTP 1.0](https://ru.hexlet.io/courses/http_protocol/lessons/http_1_0/theory_unit)

   - [DNS](https://guides.hexlet.io/dns/)

3. [HTTP 1.1](https://ru.hexlet.io/courses/http_protocol/lessons/http_1_1/theory_unit)

   - [Стандарт HTTP 1.1](https://www.ietf.org/rfc/rfc2616.txt)
   - [Википедия / Постоянное HTTP-соединение](https://ru.wikipedia.org/wiki/Постоянное_HTTP-соединение)

4. [Тело HTTP-запроса](https://ru.hexlet.io/courses/http_protocol/lessons/body/theory_unit)

   - [Википедия / Тело сообщения](https://ru.wikipedia.org/wiki/HTTP#.D0.A2.D0.B5.D0.BB.D0.BE_.D1.81.D0.BE.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.B8.D1.8F)
   - [Формат HTTP-запросов](http://citforum.ru/internet/cgi_tut/rqst.shtml)
   - [Формат HTTP-ответов](http://citforum.ru/internet/cgi_tut/spns.shtml)

5. [Отправка форм](https://ru.hexlet.io/courses/http_protocol/lessons/forms/theory_unit)

   - [Отправка данных по HTTP](https://developer.mozilla.org/ru/docs/Learn/HTML/Forms)
   - [JSON](https://ru.wikipedia.org/wiki/JSON)

6. [Transfer-Encoding](https://ru.hexlet.io/courses/http_protocol/lessons/chunked/theory_unit)

   - [Ссылка на изображение, передаваемое с помощью chunks (пример из видео)](https://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx)
   - [Chunked transfer encoding / Википедия](https://ru.wikipedia.org/wiki/Chunked_transfer_encoding)
   - [RFC2616 Hypertext Transfer Protocol](https://tools.ietf.org/html/rfc2616)

7. [Передача данных query string](https://ru.hexlet.io/courses/http_protocol/lessons/query_string/theory_unit)

   - [Query String / Wikipedia](https://en.wikipedia.org/wiki/Query_string)
   - [RFC 3986 (соответствующий стандарт)](https://tools.ietf.org/html/rfc3986)

8. [Перенаправления](https://ru.hexlet.io/courses/http_protocol/lessons/redirect/theory_unit)

   - [HTTP 301](https://ru.wikipedia.org/wiki/HTTP_301)

9. [Базовая аутентификация](https://ru.hexlet.io/courses/http_protocol/lessons/basic_auth/theory_unit)

   - [Basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication)

10. [Cookies](https://ru.hexlet.io/courses/http_protocol/lessons/cookies/theory_unit)

    - [HTTP Cookie / Mozilla](https://developer.mozilla.org/ru/docs/Web/HTTP/Куки)
    - [HTTP Куки / Википедия](https://ru.wikipedia.org/wiki/HTTP_cookie)
    - [RFC 6265: стандарт, описывающий cookie](https://tools.ietf.org/html/rfc6265)
