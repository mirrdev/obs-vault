## Введение—JS: Архитектура фронтенда

Знание JavaScript и умение работать с DOM это базовые кирпичики, на которых строится всё остальное. Они необходимы, но не достаточны для создания приложений, которые хорошо работают, легко поддерживаются и расширяются. Скорее наоборот. Работа с чистым DOM без глубокого понимания принципов организации кода буквально сразу превратится в кашу.

Такой подход ещё работает для тех разработчиков, которые делают небольшие виджеты, например, на jQuery. Но как появится задача реализовать полноценное фронтенд-приложение, те подходы, которые использовались при создании виджетов, сразу начнут давать сбои. Достаточно добавить десяток-другой обработчиков, как код превратится в неподдерживаемую лапшу.

К счастью, научиться строить архитектуру фронтенд-приложений не так сложно. Более того, все эти подходы были разработаны десятки лет назад, буквально тогда, когда только появились первые визуальные интерфейсы. Сейчас в это трудно поверить, но всё уже придумано довольно давно.

Более того, эти подходы практически не меняются от фреймворка к фреймворку. Именно поэтому в этом курсе они даются "сырыми" без привязки к каким-то фреймворкам. Здесь рассказываются и изучаются глубинные подходы, которые являются определяющими в архитектуре.

Основные темы этого курса:

- Управление состоянием и его организация
- Model-View-Controller
- Контролируемые и не контролируемые формы
- Автоматное программирование
- Работа с текстами. Интернационализация, локализация, плюрализация

### Подготовка

Вопросы архитектуры, всплывают у разработчиков тогда, когда они, хотя бы немного, поработали с кодом и видят как быстро он становится неподдерживаемым. Этот курс не исключение, он создавался с учетом определенного опыта, который нужно иметь до. Этот опыт может быть получен самостоятельно вне Хекслета, так и на Хекслете в рамках профессии [Фронтенд-разработчик](https://ru.hexlet.io/programs/frontend). В программе этот курс идет после изучения самого языка JavaScript, прохождения нескольких проектов и курса по DOM API. Если вы не знаете фронтенд-разработку в этом объеме, то рекомендуем отложить этот курс и идти по профессии не пропуская практических заданий.

## Состояние приложения—JS: Архитектура фронтенда

Манипулирование DOM — задача простая только в самых примитивных ситуациях. Как только понадобится реализовать полноценное (пусть и небольшое) приложение, код моментально превращается в тыкву. Десятка обработчиков достаточно для того, чтобы потеряться. С каждым новым событием сложность кода растёт ещё быстрее, а ведь в реальных приложениях событий сотни. Почему так происходит?

Хотя подобная проблема касается не только фронтенда, именно в нём она достигает своего апогея. Событийная архитектура и DOM без должного внимания порождают запутанный код буквально сразу. Понятно, что где-то здесь появляется архитектура, но где конкретно и как — это вопрос.

Подойдём к правильной архитектуре со стороны бэкенда. Как вы уже знаете или догадываетесь, в бэкенде приложения состоят минимум из двух частей — базы данных и собственно самого кода. Формы, отправляемые на сервер, изменяют _состояние_ приложения (то есть его данные), которое хранится в базе, далее на основе этого состояния формируется ответ в виде HTML-страницы.

![Из браузера в базу данных через приложение](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImZjODVmNjQ3ZGNkM2Q2ZTc1NmM1ZmE3MGYyMDkwODM1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=923a6066a66438d766d22a52cc18a083aeb6bfcf831ee94745558b14e8fe0ac1)

По сути, в типичных веб-проектах приложение занимается двумя процессами: либо обновляет данные в базе, либо извлекает эти данные и на основе них формирует HTML. Необходимость базы данных довольно очевидна и понятна для всех, но то же самое не очевидно во фронтенде. DOM позволяет хранить состояние внутри себя и, более того, провоцирует так делать. На протяжении курса мы будем встречаться с этой ситуацией ещё не раз, когда нужно выполнить некоторое действие, а оно зависит от того, что сейчас на экране. Для работы с этими данными приходится обращаться к DOM.

<iframe allowfullscreen="true" allowpaymentrequest="true" allowtransparency="true" class="cp_embed_iframe " frameborder="0" height="265" width="100%" name="cp_embed_1" scrolling="no" src="https://codepen.io/hexlet/embed/KKgwPEd?height=265&amp;theme-id=light&amp;default-tab=js%2Cresult&amp;user=hexlet&amp;slug-hash=KKgwPEd&amp;pen-title=js_dom_state_in_dom&amp;name=cp_embed_1" title="js_dom_state_in_dom" loading="lazy" id="cp_embed_KKgwPEd" style="box-sizing: border-box; border: 0px; width: 742.5px; overflow: hidden; display: block;"></iframe>

Главная проблема такого подхода в отсутствии единого источника правды. Одни и те же данные, на одной странице, могут использоваться множество раз. Причем иногда по разному. Представьте себе ситуацию, в которой нужно вывести количество отображаемых статей на странице. Для того чтобы их посчитать, придется писать такой код:

```
// Каждая статья обозначается классом .article
const articles = document.querySelectorAll('.article');
articles.length; // количество статей
```

А если у нас часть статей выводится в одном блоке, а часть в другом? Тогда придется обращаться к каждому из этих блоков, чтобы собрать все статьи. Чем дальше мы будем фантазировать, тем больше сложностей возникнет с тем, как работать с этими данными: добавлять, обновлять и использовать. Глядя на код, невозможно легко понять, откуда брать данные. Кроме того, они сильно завязаны на конкретную структуру верстки.

### Отделение состояния приложения

Первый шаг в построении правильной архитектуры состоит в выделении данных, которыми манипулирует приложение из DOM, в отдельную переменную на уровне приложения (не на глобальном уровне! Каждый запуск приложения должен быть независим). Это позволит отделить работу с данными от их отображения.

При такой организации кода вырисовывается следующая схема работы:

- Возникает событие
- Обработчик события меняет состояние
- DOM обновляется на основе новых данных

Ниже реализация этой идеи на примере простого счётчика. Состояние в данном случае — одно число. Кнопка с плюсом увеличивает его на единицу, кнопка с минусом соответственно уменьшает.

<iframe allowfullscreen="true" allowpaymentrequest="true" allowtransparency="true" class="cp_embed_iframe " frameborder="0" height="520" width="100%" name="cp_embed_2" scrolling="no" src="https://codepen.io/hexlet/embed/pOpMgy?height=520&amp;theme-id=0&amp;slug-hash=pOpMgy&amp;default-tab=js%2Cresult&amp;user=hexlet&amp;pen-title=js_dom_state_simple&amp;editable=true&amp;name=cp_embed_2" title="js_dom_state_simple" loading="lazy" id="cp_embed_pOpMgy" style="box-sizing: border-box; border: 0px; width: 742.5px; overflow: hidden; display: block;"></iframe>

Здесь нет никаких обращений к DOM для извлечения текущего значения, оно хранится в переменной и доступно для всех обработчиков. Подобная организация упрощает не только хранение и работу с данными, но и отладку. В любой момент можно посмотреть внутрь состояния и сопоставить его с тем что выводится на экран. **Фактически, внешний вид страницы становится отражением состояния приложения на экране.**

---

##### Дополнительные материалы

1. [Скрипты, модули и библиотеки](https://ru.hexlet.io/blog/posts/skripty-moduli-i-biblioteki)
2. [Состояние в модулях](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)

## Комплексное состояние—JS: Архитектура фронтенда

Что включает в себя понятие **состояние**? Если коротко, то состояние — это данные нашего приложения в любой момент времени, например, открытые вкладки в редакторе или браузере. Их количество и содержимое меняются в зависимости от того, какие кнопки мы нажимаем и что пытаемся загрузить. В общем случае, любое визуальное изменение в приложении или на странице, это всегда изменение состояния и никак иначе. Невозможна ситуация, при которой на странице сайта меняется какая-то деталь, но состояние при этом остаётся тем же. Изменение представления возможно только на основе изменения состояния.

_Можно подумать, что анимация через CSS не меняет ничего в нашем приложении. Да, анимация в CSS не связана с нашим приложением, но внутри браузера это состояние есть, и оно меняется_.

Отличным примером состояния служит форма. Представьте себе поле для ввода телефона, которое отслеживает ошибки при вводе и сразу их показывает. Если ошибок нет, то оно позволяет выполнить отправку формы, иначе кнопка заблокирована. Что в данном случае является состоянием? Во-первых, все данные, вводимые в форму. Во-вторых, состояние корректности (валидности) данных формы: "валидно" и "не валидно". На основе этого состояния определяется, обводить красной рамкой поле ввода или нет. Ну и сами ошибки, которые нужно выводить тоже являются частью состояния.

<iframe allowfullscreen="true" allowpaymentrequest="true" allowtransparency="true" class="cp_embed_iframe " frameborder="0" height="520" width="100%" name="cp_embed_1" scrolling="no" src="https://codepen.io/hexlet/embed/BOYyLX?height=520&amp;theme-id=0&amp;slug-hash=BOYyLX&amp;default-tab=js%2Cresult&amp;user=hexlet&amp;pen-title=js_dom_state_object&amp;editable=true&amp;name=cp_embed_1" title="js_dom_state_object" loading="lazy" id="cp_embed_BOYyLX" style="box-sizing: border-box; border: 0px; width: 742.5px; overflow: hidden; display: block;"></iframe>

Как видно из примера, состояние описывается обычным JS-объектом, который создаётся при старте приложения:

```
// Константа потому что объект состояния всегда остается тем же
const state = {
  // Состояние формы выделено в отдельное свойство,
  // так как форм на странице может быть много
  registrationForm: {
    valid: true,
    errors: [],
  }
};
```

А вот логика обработчика разделилась на два независимых процесса: первый – изменение состояния, второй – отображение этого состояния на экране:

```
input.addEventListener('keyup', (e) => {
  const inputValue = e.target.value;
  // Сохраняем вводимые данные
  state.registrationForm.value = inputValue;
  // В зависимости от введенного значения определяется состояние формы, ее валидность.
  // Если значение неверное, то помечаем форму невалидной,
  // иначе помечаем форму валидной
  if (inputValue.match(/^\d+$/)) {
    state.registrationForm.valid = true;
    state.registrationForm.errors = [];
  } else {
    state.registrationForm.valid = false;
    state.registrationForm.errors.push('wrong format');
  }

  // Заблокированность кнопки определяется состоянием валидности
  submit.disabled = !state.registrationForm.valid;

  // Наличие ошибок (красная рамка) зависит от состояния валидности формы
  if (state.registrationForm.valid) {
    input.style.border = null;
  } else {
    input.style.border = 'thick solid red';
  }
});
```

Именно так устроены все современные фронтенд-фреймворки. Сама концепция отделения данных приложения от внешнего вида не нова, более того, в бекенд-разработке других вариантов просто нет (к счастью).

### Рекомендации по организации состояния

#### Что хранится в состоянии

В приложениях далеко не все данные могут изменяться с течением времени. К таким данным может относиться конфигурация, например таймауты, различные ключи доступа или настройки библиотек. Такие данные (можно сказать, что они статические) в состоянии не хранят. Достаточно иметь отдельные константы, созданные прямо по месту использования, либо импортируемые из специального модуля с настройками:

```
// Не очень
const state = {
  // тут всякое
  httpTimeout: 1000,
  apiKey: 'my super secret hash',
};

// Очень
const httpTimeout = 1000;
const apiKey = 'my super secret hash';
```

#### Объект состояния

Само состояние лучше всего организовывать в виде одной константы, содержащей объект. За таким объектом гораздо проще следить, чем за набором разных констант или переменных. Более того, как вы увидите позже, это позволяет реализовать удобное отслеживание изменений для реализации архитектуры MVC, к которой мы медленно подбираемся.

```
// Не очень
const state = {
  formState: { /* ... */ },
};

const posts = [];
let connected = false;

// Очень
const state = {
  formState: { /* ... */ },
  posts: [],
  connected: false,
};
```

#### Именование

Выделенное состояние само по себе — это уже отлично, но не менее важно правильное именование данных внутри состояния. Что, например, означают свойства `valid` или `connected` в объекте состояния догадаться можно, но к чему они относятся, без анализа кода понять невозможно. Эти слова слишком общие, они не задают контекст. Лучше всегда уточнять что имеется ввиду:

```
// не очень
const state = {
  valid: false,
  connected: true,
}

// очень
const state = {
  registrationFormValid: false,
  chatConnected: true,
}
```

#### Группировка

Еще один способ упростить понимание состояния – группировать свойства, относящиеся к одному процессу. Например, одна форма может оперировать десятком различных свойств. Если на странице таких форм несколько, то объект состояния быстро распухнет и будет тяжело понять что к чему относится даже с хорошим именованием.

```
// не очень
const state = {
  registrationFormValid: false,
  registrationFormErrors: [],
  registrationFormNameValue: '',
}

// очень
const state = {
  registrationForm: {
    valid: false,
    errors: [],
    fields: {
      name: '',
    },
  },
};
```

#### Визуальная структура

Частая ошибка при формировании состояния — привязка структуры состояния к визуальному оформлению. Проблема такой структуры в том, что если поменяется дизайн (даже небольшое расположение элементов), то объект состояния перестанет отражать реальность и его придётся править.

```
// Не очень
const state = {
  centralBlock: {
    valid: true,
  },
  sideBar: {
    formValue: 'value'
  },
};

// Очень
const state = {
  registrationForm: {
    valid: false,
  },
  searchForm: {
    value: 'value'
  },
};
```

#### Хранение DOM-элементов

Состояние приложения — это данные, а не их отображение. Поэтому хранение DOM-элементов в состоянии считается плохой практикой. Фактически это возврат к структуре до введения состояния, когда данные хранились внутри представления.

---

##### Дополнительные материалы

1. [Именование в программировании](https://ru.hexlet.io/blog/posts/naming-in-programming)

## Отрисовка (рендеринг) состояния—JS: Архитектура фронтенда

Обновление внешнего вида на основе состояния обычно выносят в отдельный слой, который называется представлением (View). В простейшем случае представлением является функция, которая принимает на вход состояние, анализирует его и производит необходимые изменения в DOM.

```
// Лучше вынести в отдельный файл, так как обычно там много кода
import render from './view.js';

const state = /* данные состояния */;

input.addEventListener('keyup', (e) => {
  state.registrationForm.value = e.target.value;
  if (input.value === '' || input.value.match(/^\d+$/)) {
    state.registrationForm.valid = true;
    state.registrationForm.errors = [];
  } else {
    state.registrationForm.valid = false;
    state.registrationForm.errors.push('wrong format');
  }

  render(state);
});
```

Пример того как `render()` может быть устроена внутри:

```
const render = (state) => {
  const submit = document.querySelector(/* .... */);
  const input = document.querySelector(/* .... */);

  submit.disabled = !state.registrationForm.valid;

  if (state.registrationForm.valid) {
    input.style.border = null;
  } else {
    input.style.border = 'thick solid red';
  }
};
```

У такого подхода могут быть проблемы с производительностью из-за необходимости постоянно выполнять поиск элементов по DOM. Чтобы избежать этого, можно превратить представление в объект и сохранить в него все нужные элементы ровно один раз, в момент инициализации.

```
const view = new View();
view.init(); // тут делаем выборки
view.render(state);
```

С ростом приложения увеличивается и количество обработчиков. Каждый из них может приводить к изменению только части страницы. Как поступать в таком случае? Создавать по рендеру на каждую ситуацию или описывать все возможные изменения в одной функции рендер?

Наиболее простым решением будет привязка таких функций к элементам состояния. Предположим, что у нас есть страница управления списком уроков в курсе. В состоянии это выглядит так:

```
const state = {
  lessons: [/* список уроков */],
  // остальная часть состояния
};
```

Для отрисовки этого списка подойдет одна функция `renderLessons()`, которая будет вызываться во всех обработчиках, изменяющих этот список: удаляющих или добавляющих элементы.

```
// Добавление
el1.addEventListener('submit', (e) => {
  // логика
  renderLessons(state.lessons);
})

// Удаление
el2.addEventListener('submit', (e) => {
  // логика
  renderLessons(state.lessons);
})
```

И самое интересное. Что происходит внутри этой функции? Кажется, что внутри функции рендеринга нужно определять, что произошло, и затем менять необходимую часть DOM, например, удалить какой-то элемент, которого больше нет. В реальности это очень затратный подход, его сложно программировать, так как появляется большое количество условных конструкций. Намного проще выполнять полную перерисовку в любой ситуации. Тогда код останется максимально простым.

У такого подхода есть серьезный недостаток – производительность. Но учитывайте два важных момента. Во-первых, производительность далеко не всегда проблема. Например, при реализации автокомплитов именно так и нужно поступать. Все будет работать быстро в любом случае. Во-вторых, именно эту проблему решают современные фронтенд фреймворки. Они сами знают как эффективнее всего обновить DOM.

Теперь наше приложение разделено на три независимых части: состояние (данные приложения), обработчики и рендеринг. Эта модель работы на тривиальных приложениях (в пару-тройку обработчиков) смотрится избыточной, но если обработчиков станет хотя бы 10, то вы увидите, что с приложением достаточно удобно работать. Виден поток данных, то есть движение данных в приложении от одних частей к другим, от обработчика до отрисовки в DOM. Всегда можно отследить, что изменилось, и как одни части приложения зависят от других. К тому же, сокращается дублирование. Например, изменение состояния может идти из разных частей приложения, но логика отрисовки при этом остаётся неизменной. В такой ситуации достаточно описать новый способ изменения уже существующего состояния, а рендеринг сделает всё остальное.

Кроме наличия разделения на три части, не менее важно то, как они друг с другом взаимодействуют:

- Состояние не знает ничего про остальные части системы — оно ядро.
- Рендеринг пользуется состоянием для отрисовки и добавляет новые обработчики в DOM.
- Обработчики знают про состояние, так как обновляют его и инициируют рендеринг.

Этот способ разделения по-прежнему обладает одним важным недостатком, который мы устраним в уроке, посвящённом MVC.

## Состояние отображения (UI State)—JS: Архитектура фронтенда

Изменение состояния фронтенд-приложения не всегда означает изменение данных, с которыми работает приложение. У данных может быть состояние, которое влияет только на внешний вид. На сервере, в базе данных, такое состояние отсутствует.

Представьте себе обычный [аккордеон](https://getbootstrap.com/docs/4.5/components/collapse/#accordion-example). Это способ отображения данных, с помощью которого можно скрыть или раскрыть какой-то из элементов списка. Для работы подобного аккордеона нужно состояние, описывающее отображение каждого элемента: свернут/раскрыт. Такое состояние называется UI-состоянием, то есть состоянием интерфейса пользователя. Где должно храниться это состояние?

Например, его можно поместить внутрь самих данных:

```
// Список компаний. За отображение в аккордеоне отвечает флаг visibility
const state = {
  companies: [
    { id: 1, name: 'Hexlet', description: 'online courses', visibility: 'hidden' },
    { id: 2, name: 'Google', description: 'search engine', visibility: 'shown' },
    { id: 3, name: 'Facebook', description: 'social network', visibility: 'hidden' },
  ],
};
```

Где-то дальше, в слое отображения, происходит вывод этих данных с учетом флага. Технически задача решена, но у данного способа хранения есть существенные недостатки.

Начнем с главного. Данные на фронтенде не появляются из ниоткуда. Данные приложения хранятся на сервере, приходят с сервера и уходят на сервер. А сервер ничего про внешний вид не знает и знать не должен, это не касается данных. И тут возникает серьезная проблема. Если UI-состояние хранится внутри данных, то придется постоянно выполнять две вещи:

1. Вводить дополнительную обработку для всех приходящих данных с сервера, добавляя туда UI-состояние.
2. Вводить дополнительную обработку для всех данных, уходящих на сервер, удаляя из них все UI-состояние.

А подобных элементов отображения, как правило, значительно больше, чем один. Сюда можно отнести видимость модальных окон, сортировку, скрытие/раскрытие во всех возможных проявлениях, различные режимы (редактирование), подтверждения и многое другое. Все это придется не просто хранить внутри данных, но и постоянно помнить про необходимость дополнительной обработки.

Но это еще не все. Далеко не всегда весь набор данных обрабатывается одинаково. Возможно, что один набор данных выводится на странице в разных местах либо только частично. Это значит, что UI-состояние у разных элементов может быть разное, либо у каких-то элементов его может не быть вообще. Как поступать в таком случае? Игнорировать различия и добавлять всем одинаковый набор данных или усложнять логику и делать заполнение выборочным?

Из-за перечисленных проблем UI-состояние хранят отдельно от самих данных. Причем для каждой ситуации это будет свой набор данных. Например, для аккордеона состояние может выглядеть так:

```
const state = {
  companies: [...],
  uiState: {
    accordion: [
      { companyId: 1, visibility: 'hidden' },
      { companyId: 2, visibility: 'shown' },
      { companyId: 3, visibility: 'hidden' },
    ],
  },
};
```

Отметим несколько моментов:

1. `companyId` нужен для связи с данными. Сами данные не дублируются. Подробнее о структуре данных в одном из следующих уроков.
2. UI-состояние может формироваться как в процессе работы приложения, так и на этапе инициализации при его запуске. Зависит от того, когда какой элемент появляется.

## Процессы и автоматы, их описывающие—JS: Архитектура фронтенда

Чем сложнее фронтенд-приложение, тем больше различных элементов оно содержит. Каждый из этих элементов как-то реагирует на то, что происходит вокруг: спиннеры крутятся, кнопки выключаются, меню появляются и пропадают, данные отправляются.

В идеале, любые изменения в интерфейсе являются следствием изменения данных, то есть состояния приложения. Представьте себе форму регистрации, у которой кнопка отправки (submit) заблокирована во время выполнения запроса на сервер (с точки зрения UX это обязательно для любых форм). В таком случае состояние может приобрести следующий вид:

```
const state = {
  registrationProcess: {
    valid: true,
    submitDisabled: true,
    isLoading: false,
  }
};
```

В реальных приложениях всё ещё сложнее. Во время отправки данных блокируется не только кнопка отправки, но и поле для ввода. Более того, отправка данных в одном месте, может повлиять и на остальные блоки на странице, которые могут пропадать, блокироваться или видоизменяться. Не говоря уже о том, что причин блокировки кнопки может быть несколько. Она может быть заблокирована просто потому, что в форму введены некорректные данные.

Решая эту задачу в лоб, получится состояние с большим количеством флагов:

```
const state = {
  registrationProcess: {
    valid: true,
    submitDisabled: true,
    inputDisabled: true,
    showSpinner: true,
    blockAuthentication: true,
  }
};
```

Каждый флаг отвечает за свой элемент на экране. С ростом количества флагов, начнёт усложняться логика обновления состояния (нужно согласовывать их между собой и не забывать обновлять) и логика вывода (начнут появляться варианты зависимости внешнего вывода от разных флагов).

Проблема данного подхода в том, что он опирается не на причины происходящего, а на их следствия. Изменение активности кнопки, блокирование элементов, отображение спиннеров — всё это следствия каких-то процессов. Умение выделить эти процессы и правильно описать в состоянии, один из краеугольных камней хорошей архитектуры.

В примере выше большая часть флагов связана с процессом обработки данных формы. Предположим, что после отправки формы, данные уходят на сервер, затем от него приходит ответ и дальше результат отображается пользователю. Результат может быть как успешным, так и не успешным. Мы должны продумывать все исходы. Весь процесс условно можно разбить на несколько промежуточных состояний:

_Предложенный набор не является универсальным. Процессы могут быть устроены сложнее, а значит потребуется другой набор состояний. И имена состояний это причастия._

- _filling_ – заполнение формы. В этом состоянии всё активно и доступно для редактирования.
- _processing_ (или _sending_) – отправка формы. Это то самое состояние, когда пользователь ждёт, а приложение пытается предотвратить нежелательные действия, например, клики или изменения данных формы.
- _processed_ (или _finished_) – состояние, обозначающее что всё завершилось. В нём форма уже не отображается.
- _failed_ – состояние, обозначающее завершение с ошибкой. Например произошел сбой в сети во время загрузки или загруженные данные оказались неверными.

С точки зрения теории автоматов (а мы имеем дело с автоматным программированием в данном случае), такие состояния называются управляющими. Они определяют то, где мы сейчас находимся. Перепишем наше состояние:

```
const state = {
  registrationProcess: {
    state: 'filling',
  }
};
```

Даже такое, на первый взгляд, небольшое изменение резко упрощает систему. Теперь нам не нужно отслеживать каждый участвующий в этом процессе элемент. Главное, чтобы все возможные состояния описывали все возможные варианты поведения. Тогда все проверки в выводе сведутся к проверке общего состояния:

```
// Этих "ифов" может быть сколько угодно,
// главное, что они завязаны на общее состояние, а не проверку конкретных флагов
if (state.registrationProcess.state === 'processing') {
  // Блокируем кнопки
  // Активируем спиннеры
}

if (state.registrationProcess.state === 'failed') {
  // Выводим сообщение об ошибке
}
```

Кроме таких состояний, есть различные данные, сопровождающие наш процесс. Например, _processed_ может завершиться с ошибками. В таком случае можно ввести дополнительно массив (или объект, в зависимости от структуры) с ошибками, который будет заполняться при их наличии:

```
const state = {
  registrationProcess: {
    errors: ['Имя не заполнено', 'Адрес имеет неверный формат'],
    state: 'processed',
  }
};
```

Причём этот же массив с ошибками удобно использовать для валидации формы до отправки на сервер. То есть будучи в состоянии _filling_.

А что если мы захотим блокировать возможность отправки формы до того момента, пока не пройдёт валидация на фронтенде? Есть два подхода: либо мы проверяем, что _errors_ пуст, либо, что лучше, мы вводим явное состояние валидности формы. И тогда состояние нашего приложения становится таким:

```
const state = {
  registrationProcess: {
    errors: ['Имя не заполнено', 'Адрес имеет неверный формат'],
    state: 'processed',
    validationState: 'invalid' // или valid
  }
};
```

В некоторых ситуациях возможно объединение, когда процесс валидации соединён с процессом обработки самой регистрации. Тогда вместо отдельного состояния _validationState_, появится дополнительное состояние _invalid_ внутри _state_. Это не совсем корректно с точки зрения моделирования (потому что у нас действительно два разных процесса), но иногда такой способ позволяет написать чуть более простой код (до тех пор пока различий не станет много).

Глобально, такой подход в разработке называется программированием с явным выделенным состоянием. Он сводится к тому, что в рамках приложения находятся базовые процессы, от которых зависит всё остальное. Затем эти процессы моделируются с помощью конечных автоматов (FSM). Причём не важно, какие инструменты используются для разработки: чистый DOM, jQuery или любой мощный современный фреймворк. Он применим везде и везде нужен.

Это невероятно мощная парадигма программирования, которая описана в книге "Автоматное Программирование" в [наших рекомендациях](https://ru.hexlet.io/pages/recommended-books).

---

##### Дополнительные материалы

1. [Xstate (библиотека для моделирования конечных автоматов)](https://xstate.js.org/docs/)

## Нормализация данных—JS: Архитектура фронтенда

Данные приложения почти всегда имеют иерархическую структуру. Возьмём для примера список постов на Хекслете. У каждого поста есть автор и комментарии, у которых в свою очередь есть лайки. Эти данные можно представить так:

```
const posts = [
  {
    question: 'Как писать код?',
    likesCount: 2,
    comments: [
      {
        answer: 'Открой редактор!',
        likesCount: 1,
        createdAt: '11-12-2022',
      },
      {
        answer: 'Сидя!',
        likesCount: 3,
        createdAt: '11-12-2022',
      },
    ]
  },
  {
    question: 'Что лучше: vim или emacs?',
    likesCount: 2,
    comments: [
      {
        answer: 'FAR зе бест!',
        likesCount: 100,
        createdAt: '11-12-2022',
      },
    ]
  }
];
```

Иерархическое представление данных хорошо отражает их структуру. Сразу видно, что к чему относится. Данные удобно выводить и достаточно удобно изменять. Особенно если вывод на экране совпадает с их структурой, и данные между собой не пересекаются. Топики Хекслета как раз такой пример. Каждый топик живёт своей независимой жизнью (кое-какие зависимости есть, но они не касаются самих данных).

Однако, если данные связаны, то иерархическая структура превращается в проблему. Представьте себе, что надо выводить 10 последних комментариев. Как это сделать? Придётся ходить по всем топикам, брать все комментарии, объединять и искать самые свежие. Устрашающий пример:

```
const comments = posts.flatMap((p) => p.comments);
const sortedComments = comments.sort((c1, c2) => new Date(c2.createdAt) - new Date(c1.createdAt));
const lastComments = sortedComments.slice(0, 10);
```

Ещё хуже ситуация становится тогда, когда появляются связи многие-ко-многим. В таком случае непонятно кого куда вкладывать. И всегда будут возникать ситуации, когда получившаяся структура неудобна.

Один из способов выйти из этой ситуации — начать дублировать данные. Создавать дополнительные структуры, оптимизированные под конкретные задачи. И хотя, в общем, это не лишено смысла, всё же ручной способ поддерживать эти структуры ничего хорошего не принесёт. В тех же базах данных за формирование индексов отвечает сама база данных. Нам как программистам не надо об этом заботиться. А здесь придётся внедрять дополнительную синхронизацию во все этапы: добавление, изменение и удаление.

Другой способ – нормализовать данные, прямо как в реляционных базах данных. Представить их плоскими массивами. Например так:

```
// В реальном приложении всё будет храниться в одном объекте состояния

const posts = [
  {
    id: 3,
    question: 'Как писать код?',
    likesCount: 2,
  },
  {
    id: 100
    question: 'Что лучше: vim или emacs?',
    likesCount: 2,
  }
];

const comments = [
  {
    id: 1,
    postId: 3,
    answer: 'Открой редактор!',
    likesCount: 1,
  },
  {
    id: 8,
    postId: 3,
    answer: 'Сидя!',
    likesCount: 3,
  },
  {
    id: 3,
    postId: 100,
    answer: 'FAR зе бест!',
    likesCount: 100,
  },
]
```

Если между данными нет чётких границ и они зависимы друг от друга, то такая структура намного удобнее в работе. Она легко позволяет проводить какие-то общие агрегации и особенные варианты вывода. Немаловажно, что нормализованные данные не дублируются. В хорошо организованном состоянии данные не повторяются более одного раза.

_Иногда применяют технику обратную нормализации – денормализацию, но это больше про бэкенд, чем фронтенд_.

Но за всё приходится платить. Упрощая в одном месте, нормализация усложняет в другом. Теперь для извлечения комментариев конкретного топика придётся написать такой код:

```
const postId = /* идентификатор поста */;
const commentsForPost = comments.filter((c) => c.postId === postId);
```

Здесь кода не больше, чем при выборке конкретного поста. Но он сложнее в алгоритмическом смысле, на него тратится больше ресурсов. Является это проблемой или нет — вопрос открытый. Как правило, нет. Фронтенд очень редко оперирует большими количествами, например, десятками и сотнями тысяч. Чаще всего размеры коллекций ограничиваются сотней-другой элементов.

Подводя итог, можно сказать, что большинство механизмов для хранения состояния на фронтенде рекомендуют использовать второй способ хранения. Причём не важно, делается это в рамках какого-то фреймворка или нет. Такой подход легче масштабируется и работает неплохо для любых ситуаций. В то время как первый подход создаст много проблем в тот момент, когда структура данных перестанет совпадать с их отображением.

## MVC—JS: Архитектура фронтенда

Как говорилось ранее, наша схема работы с состоянием имеет один существенный недостаток — за вызов отрисовки отвечают обработчики. Ниже приведён пример, демонстрирующий вызов `render()`.

```
input.addEventListener('change', () => {
  const { registrationProcess } = state;
  if (input.value === '') {
    registrationProcess.validationState = 'valid';
    registrationProcess.errors = [];
  } else if (!input.value.match(/^\d+$/)) {
    registrationProcess.validationState = 'invalid';
    registrationProcess.errors = ['Bad format'];
  } else {
    registrationProcess.validationState = 'valid';
    registrationProcess.errors = [];
  }

  render(state);
});
```

Какие проблемы могут возникнуть при таком подходе?

_Здесь стоит сказать, что на бэкенде такой подход как раз оправдан. Бэкенд работает в рамках другой парадигмы, а именно клиент-серверной архитектуры. Обработчик на бэкенде по своей сути это функция, которая либо меняет состояние (что не приводит ни к каким перерисовкам, так как выполняется редирект), либо извлекает данные из базы для формирования ответа, например, в виде HTML. Во фронтенде изменение данных тут же влияет на экран._

Пример, который мы видим выше, очень упрощён: в нём вызывается только одна функция `render`, принимающая на вход всё состояние. Теперь представьте, что у нас в приложении десятки обработчиков (что немного) и большое состояние (что типично). В такой ситуации перерисовывать всё на каждое изменение довольно затратная операция. С другой стороны, можно вставить проверку внутри `render` на каждый кусок состояния и отслеживать, изменился ли он. Такой подход очень быстро станет проблемой сам по себе. Можно легко забыть что-то проверить, можно ошибиться в проверке, можно просто забыть поправить проверку после изменения структуры состояния.

Существует другой способ выполнить эту задачу. Он основан на такой концепции (говорят шаблон проектирования), как Наблюдатель (Observer). Его идея очень проста: одна часть системы наблюдает за изменением другой части системы. Если наблюдаемый изменился, то наблюдатель может сделать что-то полезное.

В JS подобный механизм можно реализовать через [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy), но это довольно сложно. Более простым решением будет использование готовой библиотеки [on-change](https://github.com/sindresorhus/on-change).

```
import onChange from 'on-change';

const app = () => {
  const state = {
    ui: {
      value: 'hello',
    },
  };

  const watchedState = onChange(state, (path, value, previousValue) => {
    alert('value changed!');
    console.log(path);
    // => 'ui.value'
    console.log(value);
    // => 'other value'
    console.log(previousValue);
    // => 'hello'
  });

  // После изменения атрибута возникнет алерт
  const el = document.querySelector('<selector>');
  el.addEventListener('change', () => {
    watchedState.ui.value = 'other value';
  });
}

// Где-то в другом файле (обычно в index.js)
app();
```

On-change позволяет "слушать" нужные части состояния и вызывать функции рендеринга при их изменении. То, какие части конкретно слушать и сколько вешать "вотчеров", зависит от задачи. В примитивных ситуациях достаточно одного вотчера на весь стейт (скорее это учебный проект), в реальных же ситуациях вотчеры делают так, чтобы было удобно (в каждой ситуации по-разному).

<iframe allowfullscreen="true" allowpaymentrequest="true" allowtransparency="true" class="cp_embed_iframe " frameborder="0" height="560" width="100%" name="cp_embed_1" scrolling="no" src="https://codepen.io/hexlet/embed/dqdJmg?height=560&amp;theme-id=0&amp;slug-hash=dqdJmg&amp;default-tab=js%2Cresult&amp;user=hexlet&amp;pen-title=js_dom_mvc_watch&amp;editable=true&amp;name=cp_embed_1" title="js_dom_mvc_watch" loading="lazy" id="cp_embed_dqdJmg" style="box-sizing: border-box; border: 0px; width: 742.5px; overflow: hidden; display: block;"></iframe>

Теперь обработчики ничего не знают про рендеринг и отвечают только за взаимодействие с состоянием. В свою очередь рендеринг следит за состоянием и меняет DOM только там, где нужно и так, как нужно. Этот способ организации приложения считается уже классическим и носит имя MVC (Model View Controller). Каждое слово обозначает слой приложения со своей зоной ответственности. Model — состояние приложения и бизнес-логика, View — слой, отвечающий за взаимодействие с DOM, Controller — обработчики.

Обратите внимание на то, что Model, Controller или View — это не файлы, не классы, ни что-либо ещё конкретное. Это логические слои, которые выполняют свою задачу и определённым образом взаимодействуют друг с другом.

Понимание MVC даёт ответ на то, как структурировать приложение, но самостоятельно его реализуют редко. Современные фреймворки построены на различных модификациях MVC и за нас определили правила взаимодействия. Остаётся только разобраться и следовать им.

![MVC](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImViOWEzY2Y5YzUzODA3ZDgyYzU5Mjk0MDg2ODExNzc4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d0d5173570ac62572520629083b75776438c4cd653d3042c66705815339b9bd2)

Самое важное на этой картинке – стрелки между слоями. Они определяют барьеры абстракции. Кто с кем и как может взаимодействовать, а кто нет. Например, на этой диаграмме нет стрелки из контроллера в представление. Это обозначает, что контроллер не может (не может!) менять представление минуя модель. То, что отражено на экране — это отображение состояния приложения и никак иначе. Такой код считается нарушением:

```
// Предположим, что на странице есть одна форма
// с полем для ввода задачи и кнопкой для её добавления

const form = document.querySelector('form');
const input = document.querySelector('form input');
form.addEventListener('submit', () => {
  watchedState.registrationProcess.state = 'processing';
  // Что-то делаем с данными, например, добавляем в состояние
  input.value = ''; // Очистка поля ввода напрямую! Нарушение MVC!
});
```

На диаграмме также отсутствует стрелка из представления в модель. Это значит, что слой представление не может менять модель во время своей работы:

```
const watchedState = onChange(state, (path) => {
  if (path === 'registrationProcess.state') {
    // Обновляется состояние! Нарушение MVC!
    watchedState.registrationProcess.alert = 'Sending data...';
  }
});
```

И, конечно, представление не может притворяться контроллером и выполнять, например, HTTP-запросы:

```
const watchedState = onChange(state, (path, value) => {
  if (path === 'registrationProcess.state') {
    // Делаем HTTP-запрос! Нарушение MVC!
    if (value === 'sending') {
      axios.post(endpoint, watchedState.registrationProcess.data);
    }
  }
});
```

Итого: контроллер что-то делает с данными, на изменение данных срабатывает слой представления и изменяет DOM.

---

##### Дополнительные материалы

1. [Backbone MVC](https://backbonejs.org/#View)
2. [Что такое MVC: рассказываем простыми словами](https://ru.hexlet.io/blog/posts/chto-takoe-mvc-rasskazyvaem-prostymi-slovami)

## Состояние форм—JS: Архитектура фронтенда

Состояние форм – отдельная тема для обсуждения. Существует два подхода к обработке состояния формы. Один из них отдаёт контроль состояния самой форме, другой предполагает его хранение в пользовательском приложении. Оба подхода имеют свои плюсы и минусы, которые обязательно знать при выборе того или иного решения.

В документации React такие подходы называют контролируемыми и неконтролируемыми формами. Эти названия довольно точно описывают происходящее, поэтому здесь мы будем использовать ту же терминологию.

### Неконтролируемые формы

Подход, при котором состояние формы хранится внутри самой формы и извлекается только при её отправке. Это привычный способ работы с формой вне фреймворков:

```
form.addEventListener('submit', (e) => {
  const formData = new FormData(e.target);
  // Обработка данных, например, отправка на сервер
});
```

К достоинствам этого способа относят:

- Простоту. Мало кода, не нужно хранить состояние.
- Скорость. Браузер делает всю работу сам. Минимум вмешательства со стороны пользовательского кода.

Несмотря на лёгкость и очевидность, этот подход обладает одним недостатком. При таком подходе невозможно реагировать на изменения формы в процессе её заполнения. Где это может быть нужно? Вот несколько примеров:

- Автодополнение. Выпадающие списки зависят от того, что было набрано.
- Валидация в процессе набора. Часто реализуется в виде красной рамки вокруг поля для ввода.
- Моментальная фильтрация. Такое часто используется на сервисах бронирования или поиска товаров. Достаточно выбрать какой-то пункт меню, как сразу же меняется выборка.

В такой ситуации нам понадобятся контролируемые формы.

### Контролируемые формы

При таком подходе состояние всех элементов формы отслеживается кодом приложения. Любое изменение анализируется и сохраняется. В зависимости от текущего состояния данных, код принимает решение что показать, а что нет. В таких формах зачастую даже нет кнопки отправки. Особенно там, где формы выполняют фильтрацию данных.

```
const state = {
  registrationForm: {
    state: 'valid',
    data: {
      name: '',
      email: '',
    },
    errors: [],
  },
};

// https://github.com/sindresorhus/on-change
const watchedState = onChange(state, (path, value) => {
  if (path === 'registrationForm.state') {
    if (value === 'invalid') {
      // Отрисовка ошибок, хранящихся где-то в состоянии
      // watchedState.registrationForm.errors
    }
  }
});

form.elements.name.addEventListener('change', (e) => {
  watchedState.registrationForm.data.name = e.target.value;
  // Действия: валидация, запросы, ...
});
form.elements.email.addEventListener('change', (e) => {
  watchedState.registrationForm.data.email = e.target.value;
  // Действия: валидация, запросы, ...
});
```

Если понадобится отправить эту форму, то сделать это будет даже проще, чем с неконтролируемыми формами. Данные уже извлечены из формы и готовы к отправке.

```
form.addEventListener('submit', (e) => {
  // Обработка данных, например, отправка на сервер
  // watchedState.registrationForm.data
});
```

Преимущества такого подхода:

- Позволяет реализовать любую реакцию во время изменения формы до или вместо её отправки.

И недостатки:

- Значительно больше кода при ручной реализации.
- Они медленнее из-за большего числа действий (и возможно тяжёлой реакции). Но проблема это или нет – зависит от конкретной ситуации.

Контролируемые формы требуют настолько больше кода, что работу с ними всячески пытаются автоматизировать. Создают библиотеки, например, [garlic.js](https://github.com/guillaumepotier/Garlic.js), которые в автоматическом режиме отслеживают изменение формы и предоставляют колбеки для реакции на эти изменения.

Особенно таких библиотек много для разных фреймворков. Например, в React их десятки.

### Что использовать?

В чистом JS предпочтительнее неконтролируемые формы. Так намного проще и быстрее. И только в том случае, когда нужна мгновенная реакция, можно вводить контроль данных формы. Причём не обязательно переходить от одного способа к другому целиком. Можно использовать гибрид, вводить контроль только тех данных, где без этого никак.

## Организация текстов интерфейса—JS: Архитектура фронтенда

Интерфейс любого сайта включает в себя не только визуальные компоненты, но и текст. Это могут быть названия кнопок, пунктов меню, сообщения об ошибках в форме, различные тексты, разбросанные по всему сайту.

_Важно, что они не хранятся в базе данных, а зашиты прямо в код в тех местах, где они используются._

Эти тексты со временем начинают причинять боль. Они расползаются по всем слоям приложения и засоряют его. Очень быстро появляется дублирование одних и тех же фраз. Становится сложно отслеживать их согласованность и адекватность. В конце концов, программисты становятся единственными людьми в компании, которые могут их поменять, потому что никто кроме них не понимает, как найти эти тексты.

При правильном подходе, подобные тексты хранятся в одном месте отдельно от кода. Такой способ значительно упрощает приложение:

- Текстами проще управлять, выполнять массовое обновление, отслеживать то, что устарело.
- Это могут делать не только программисты. Более того, тексты можно выгружать во внешние системы, которые дают возможность работать с ними множеству людей (об этом ниже).
- Упрощается интернационализация и локализация.

Так как организовать хранение текстов? Ответ для многих программистов может показаться неожиданным. Даже если ваш сайт не собирается быть мультиязычным, для работы с текстами всё равно используют i18n-библиотеки. i18n – расшифровывается как интернационализация (internationalization). Этим термином в программировании обозначают всё, что связано с переводами. Как правило, речь идёт про специальные библиотеки, которые позволяют переводить интерфейсы, оставляя код приложения простым.

Самое интересное, что эти библиотеки дают все те возможности, которые были перечислены ранее, и не требуют от программистов обязательно добавлять несколько языков. Считайте, что мультиязычность – это приятное дополнение, которое можно задействовать, если вдруг понадобится. Кроме базовых задач, эти библиотеки решают ещё множество сопутствующих. Ниже мы их рассмотрим.

У Хекслета на GitHub открыто большое количество проектов на разных языках. Во всех этих проектах есть тексты, и все они подставляются в код через i18n-библиотеки. Большая часть этих библиотек интегрирована с фреймворками и поставляется из коробки. Вот несколько примеров:

- [cv.hexlet.io](https://github.com/Hexlet/hexlet-cv/blob/master/config/locales/ru.views.yml)
- [sicp.hexlet.io](https://github.com/Hexlet/hexlet-sicp/blob/master/resources/lang/ru/layout.php)
- [code-basics.com](https://github.com/hexlet-basics/hexlet_basics/blob/master/services/web/assets/locales/ru/translation.json)

В каждом из этих проектов свои способы организации переводов, это видно по разным форматам файлов. Одно остаётся неизменным: строки не разбросаны по коду. Они все собраны в одном месте и подставляются в нужных местах через i18n-библиотеки.

В мире JS наиболее популярной библиотекой для работы с текстами стала [i18next](https://www.i18next.com/). Это не просто библиотека, а целый фреймворк, имеющий интеграции со всеми популярными решениями, такими как Angular, React или Vue.js. Пример использования:

```
import i18next from 'i18next';
// Инициализация, выполняется ровно один раз в асинхронной функции, запускающей приложение
const runApp = async () => {
  await i18next.init({
    lng: 'ru', // Текущий язык
    debug: true,
    resources: {
      ru: { // Тексты конкретного языка
        translation: { // Так называемый namespace по умолчанию
          key: 'Привет мир!',
        },
      },
    },
  });
};

// Где-то в коде приложения обращаемся к ключу (key)
// Библиотека по умолчанию ищет так: <текущий язык>.translation.<ключ> => ru.translation.key
i18next.t('key'); // "Привет мир!"
```

Единственное место, где появляется понятие "язык" — это инициализация. Нужно указать текущий язык (`lng`) и добавить тексты для этого языка. На этом всё: дальше мы только управляем текстами. Если появляется новый текст, то для него придумывается ключ и добавляется в объект _translation_. Затем этот текст извлекается по указанному ключу. Из кода выше видно, что этот текст очень легко переиспользовать. Достаточно обратиться к этому же ключу в другом месте программы.

Когда текста становится больше, то его можно вынести в отдельный файл. В таком случае инициализация меняется на такую:

```
import i18next from 'i18next';
// Просто пример. Структура может быть любой.
import ru from './locales/ru.js';

await i18next.init({
  lng: 'ru',
  debug: true,
  resources: {
    ru,
  },
});
```

В принципе, выносить тексты лучше сразу. Их никогда не бывает мало.

i18next поддерживает такое понятие как "бэкенды". Она позволяет загружать тексты из внешних источников, например, через AJAX-запрос (именно поэтому инициализация библиотеки — асинхронная). Подробнее в [официальной документации](https://www.i18next.com/overview/plugins-and-utils#backends).

Со временем вы заметите, что плоская структура _key-value_ не всегда удобна. Иногда захочется делать вложенность, группировать ключи. К счастью, с этим нет никаких проблем. I18next поддерживает такую возможность из коробки.

```
{
  translation: {
    key: 'Привет мир!',
    signUpForm: {
      name: 'Имя',
      email: 'Email',
    }
  }
}

i18next.t('signUpForm.name'); // Имя
i18next.t('signUpForm.email'); // Email
```

В некоторых ситуациях тексты зависят от различных динамических параметров, например, от имени пользователя. В таком случае используется встроенная интерполяция:

```
{
  translation: {
    greeting: 'Привет {{name}}!',
  }
}

i18next.t('greeting', { name: 'Иван' }); // "Привет Иван!"
```

В более сложных ситуациях одной интерполяции недостаточно. Представьте себе, что нам надо выводить количество баллов, как на Хекслете. Слово "балл" будет меняться в зависимости от числа баллов: 1 балл, 2 балла, 10 баллов. Как это сделать? С помощью плюрализации!

```
{
  translation: {
    { // Интерполяция не обязательна, зависит от задачи
      // Наименования ключей не соответствуют конкретным числам
      // Они обозначают разные группы чисел https://jsfiddle.net/6bpxsgd4
      key_one: '{{count}} балл',
      key_few: '{{count}} балла',
      key_many: '{{count}} баллов',
    }
  }
}

i18next.t('key', { count: 0 }); // "баллов"
i18next.t('key', { count: 1 }); // "балл"
i18next.t('key', { count: 2 }); // "балла"
i18next.t('key', { count: 5 }); // "баллов"
```

### Связь текстов с состоянием приложения

Типичная ошибка при работе с текстами – хранить их прямо в состоянии:

```
// Ошибки – это всего лишь один из возможных примеров
// То же самое касается любых других текстов
if (!isEmailUnique) {
  state.signUpForm.errors.email = i18next.t('signUpForm.errors.email.notUnique');
}
```

У такого подхода есть один очень серьезный недостаток. Он не сочетается с переключением языков. Представьте, что пользователь поменял язык интерфейса, а в состоянии в это время записаны тексты. Появляется проблема – как изменить тексты на правильный язык? В общем случае никак, потому что в строке текста нет информации о том, что это было. То есть невозможно сопоставить этот текст с ключом и найти соответствующий перевод в другом месте. Кроме того, сама задача очень непростая, текстов может быть много, они разбросаны по разным частям состояния. Придется писать специальную логику под каждую конкретную ситуацию (каждый конкретный кусок состояния).

Любые тексты, которые выводятся в зависимости от действий пользователя, не должны храниться в состоянии приложения. Эти тексты должны зависеть от состояния процессов:

```
// Где-то в представлении (View)
if (state.registrationProcess.finished) {
  div.innerHTML = i18next.t('registration.success');
}
```

Только в некоторых ситуациях, где нужно явно знать, какие тексты использовать – можно хранить ключи, например, для перевода ошибок.

```
// В файле переводов:
{
  translation: {
    key: 'Привет мир!',
    signUpForm: {
      name: 'Имя',
      email: 'Email',
      errors: [/* тут переводы ошибок */]
    }
  }
}

// Где-то в приложении
const state = {
  signUpForm: {
    valid: false,
    errors: {},
  }
};

// Где-то в обработчике
if (!isEmailUnique) {
  state.signUpForm.errors.email = 'signUpForm.errors.email.notUnique';
}

// Где-то во вью
div.innerHTML = i18next.t(state.signUpForm.errors.email);
```

В любом случае, готовые строки формируются только при выводе.

### Инициализация

Вернёмся к примеру из начала урока:

```
import i18next from 'i18next';
const runApp = async () => {
// Меняет объект i18next глобально
  await i18next.init({
    // конфигурация i18next
  });

  app(); // внутри приложения i18next.t теперь работает с выбранным языком и загруженными переводами.
};

// Где-то в коде приложения обращаемся к ключу (key)
i18next.t('key');
```

При инициализации глобальный объект i18next мутируется, и поэтому функция `i18next.t` может импортироваться напрямую из библиотеки. Это удобно с точки зрения использования, но добавляет проблем при необходимости многократной инициализации. Когда необходимо инициализировать приложение несколько раз? Например, в тестах, где на каждый тест происходит новый запуск приложения "с нуля", или при серверном рендеринге, когда для каждого пользователя на сервере создаётся свой экземпляр приложения. Для таких случаев библиотека содержит функцию `createInstance`, которая создаёт, как нетрудно догадаться, новый экземпляр i18next:

```
  import i18next from 'i18next';
  const runApp = async () => {
  // Глобальный объект i18next не меняется и каждый запуск приложения будет независим от других.
    const i18nextInstance = i18next.createInstance();
    await i18nextInstance.init({
      // конфигурация i18next
    });

    // инициализированный экземпляр необходимо передать в приложение
    app(i18nextInstance);
  };

  // Где-то в коде приложения обращаемся к экземпляру:
  i18nextInstance.t('key'); // "Привет мир!"
```

Такой подход с глобальным состоянием не уникален, например, библиотеку axios можно конфигурировать как глобально, так и [создавать инстанс](https://github.com/axios/axios#creating-an-instance). В общем случае, мутируемое глобальное состояние – зло и источник багов.

## Инициализация приложения—JS: Архитектура фронтенда

Работу любого приложения можно условно разделить на три стадии, через которые оно проходит в процессе жизни:

- Инициализацию
- Исполнение
- Завершение

В зависимости от того, как они реализованы, код может быть как удобным в тестировании и поддержке, так и наоборот, сложным и практически не тестируемым. В этом уроке мы рассмотрим самую главную часть – различия между инициализацией и исполнением, разберем конкретные примеры и научимся правильно разделять ответственности.

Что такое инициализация? Перед работой любого приложения нужно настроить все необходимые библиотеки и фреймворки, соединить их между собой и запустить. В бекенде с этим все сильно проще, так как этот процесс полностью контролируется фреймворками. Во фронтенде многое отдано на откуп самому разработчику, и поэтому часто возникают ситуации, когда процесс инициализации либо не выделен, либо выделен лишь частично и неудачно.

Что входит в инициализацию? Всё, что нужно сделать ровно один раз для последующего использования в приложении:

- Создание начального состояния
- Подключение вебсокетов
- Настройка i18next
- Загрузка и запуск фреймворка, если он есть
- Настройка различных библиотек: http-клиенты, работа с датами и так далее

Этот список далеко не полный, в каждой конкретной ситуации в инициализацию попадает что-то свое.

На практике процесс инициализации организуется так: создается функция, внутри которой выполняется вся необходимая настройка. Для удобства сделать это можно в файле _init.js_.

```
// Гипотетический пример
// файл init.js
import i18next from 'i18next';
import io from 'socket.io-client';

// Начальная функция
export default async () => {
  // создание экземпляра i18next
  const i18nextInstance = i18next.createInstance();
  await i18nextInstance.init({
    lng: 'ru',
    resources: /* переводы */
  });

  const state = {
    /* описание состояния */
  }

  // создание сокета
  const socket = new io();
  socket.on(/* настройка вебсокетов */);

  const form = document.querySelector('some-form');
  form.addEventListener('submit', (e) => {
   // А вот тут логика приложения и лучше ее выносить куда-то еще
   // где-то в таких обработчиках используется state и socket
  });
};
```

Запуск этой функции происходит уже в другом месте, например, в файле _index.js_, который является точкой входа в приложение:

```
import runApp from './init.js';

runApp();
```

Почему разделение именно такое? Во фронтенде приложение, как правило, глобально. То есть оно одно на всю страницу, грузится ровно один раз и один раз запускается и управляет всем происходящим так, как будто вокруг больше ничего нет (других приложений о которых нужно думать). Но так бывает не всегда. Например виджеты могут появляться на одной странице более одного раза, а значит каждый виджет должен быть вещью "в себе". То есть инициализация такого виджета работает в своем собственном окружении со своими собственными объектами и не меняет ничего вне (глобальные объекты). Иначе возникнут конфликты и один виджет будет мешать другому.

С другой стороны, в тестировании каждый тест строится так, что он не зависит от других тестов, то есть каждый тест работает так, как будто других тестов не существует. Такое поведение требует инициализации приложения для каждого теста "с нуля". Только в этом случае можно гарантировать, что изменения состояния приложения, сделанные в одном тесте не повлияют на другие тесты. Яркий пример – инициализация i18next. Эта библиотека экспортирует глобальный объект, который можно инициализировать только один раз, повторные инициализации того же объекта (например, при повторных запусках приложения в тестах) приведут к багам и запрещены документацией. По этой причине в примере выше каждый старт приложения создаёт свой собственный экземпляр i18next, который затем прокидывается в использующие его функции.

```
// Подробно тесты изучаются в других курсах
// Где-то в тестах
import runApp from '../src/init.js';

// Эта функция выполняется перед каждым тестом
beforeEach(() => {
  runApp(); // инициализация
});

test(/* тут тесты */)
test(/* тут тесты */)
```

В примере выше работа идет с функцией, которая позволяет инициализировать приложение, а не с файлом _index.js_, где эта функция вызывается. Если бы мы импортировали _index.js_, то во время импорта сразу произошла бы инициализация и она была бы глобальной с точки зрения тестов. В таком случае нормальное тестирование практически невозможно.

---

##### Дополнительные материалы

1. [Состояние на уровне модулей](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)
2. [Скрипты, модули и библиотеки](https://ru.hexlet.io/blog/posts/skripty-moduli-i-biblioteki)

## Дополнительные материалы

### [JS: Архитектура фронтенда](https://ru.hexlet.io/courses/js-frontend-architecture)

1. [Введение](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/intro/theory_unit)

   - Без материалов

2. [Состояние приложения](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/state/theory_unit)

   - [Скрипты, модули и библиотеки](https://ru.hexlet.io/blog/posts/skripty-moduli-i-biblioteki)
   - [Состояние в модулях](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)

3. [Комплексное состояние](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/complex-state/theory_unit)

   - [Именование в программировании](https://ru.hexlet.io/blog/posts/naming-in-programming)

4. [Отрисовка (рендеринг) состояния](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/rendering/theory_unit)

   - Без материалов

5. [Состояние отображения (UI State)](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/ui-state/theory_unit)

   - Без материалов

6. [Процессы и автоматы, их описывающие](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/processes/theory_unit)

   - [Xstate (библиотека для моделирования конечных автоматов)](https://xstate.js.org/docs/)

7. [Нормализация данных](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/shape-of-state/theory_unit)

   - Без материалов

8. [MVC](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/mvc/theory_unit)

   - [Backbone MVC](https://backbonejs.org/#View)
   - [Что такое MVC: рассказываем простыми словами](https://ru.hexlet.io/blog/posts/chto-takoe-mvc-rasskazyvaem-prostymi-slovami)

9. [Состояние форм](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/forms/theory_unit)

   - Без материалов

10. [Организация текстов интерфейса](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/i18n/theory_unit)

    - Без материалов

11. [Инициализация приложения](https://ru.hexlet.io/courses/js-frontend-architecture/lessons/initialization/theory_unit)

    - [Состояние на уровне модулей](https://ru.hexlet.io/blog/posts/sovershennyy-kod-sostoyanie-v-modulyah)
    - [Скрипты, модули и библиотеки](https://ru.hexlet.io/blog/posts/skripty-moduli-i-biblioteki)
